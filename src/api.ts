/* tslint:disable */
/* eslint-disable */
/**
 * sudosos-back-end
 * SudoSOS
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AcceptTosRequest
 */
export interface AcceptTosRequest {
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof AcceptTosRequest
     */
    'extensiveDataProcessing': boolean;
}
/**
 * 
 * @export
 * @interface ActionResponse
 */
export interface ActionResponse {
    /**
     * The name of the action performed on the entity.
     * @type {string}
     * @memberof ActionResponse
     */
    'action': string;
    /**
     * The ownership relations with permissions.
     * @type {Array<RelationResponse>}
     * @memberof ActionResponse
     */
    'relations': Array<RelationResponse>;
}
/**
 * 
 * @export
 * @interface AddRoleRequest
 */
export interface AddRoleRequest {
    /**
     * Role to add to the user.
     * @type {number}
     * @memberof AddRoleRequest
     */
    'roleId': number;
}
/**
 * 
 * @export
 * @interface AuthenticationEanRequest
 */
export interface AuthenticationEanRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationEanRequest
     */
    'eanCode': string;
}
/**
 * 
 * @export
 * @interface AuthenticationKeyRequest
 */
export interface AuthenticationKeyRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationKeyRequest
     */
    'userId': number;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationKeyRequest
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface AuthenticationLDAPRequest
 */
export interface AuthenticationLDAPRequest {
    /**
     * The AD account name to authenticate
     * @type {string}
     * @memberof AuthenticationLDAPRequest
     */
    'accountName': string;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationLDAPRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationLocalRequest
 */
export interface AuthenticationLocalRequest {
    /**
     * The users mail to authenticate
     * @type {string}
     * @memberof AuthenticationLocalRequest
     */
    'accountMail': string;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationLocalRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationMockRequest
 */
export interface AuthenticationMockRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationMockRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationMockRequest
     */
    'nonce': string;
}
/**
 * 
 * @export
 * @interface AuthenticationNfcRequest
 */
export interface AuthenticationNfcRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationNfcRequest
     */
    'nfcCode': string;
}
/**
 * 
 * @export
 * @interface AuthenticationPinRequest
 */
export interface AuthenticationPinRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationPinRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationPinRequest
     */
    'pin': string;
}
/**
 * 
 * @export
 * @interface AuthenticationQRConfirmRequest
 */
export interface AuthenticationQRConfirmRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationQRConfirmRequest
     */
    'sessionId': string;
}
/**
 * 
 * @export
 * @interface AuthenticationResetTokenRequest
 */
export interface AuthenticationResetTokenRequest {
    /**
     * The mail of the user
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'accountMail': string;
    /**
     * The reset token passcode
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'token': string;
    /**
     * The new password to set
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     * 
     * @type {UserResponse}
     * @memberof AuthenticationResponse
     */
    'user': UserResponse;
    /**
     * The RBAC roles that the user has. (DEPRECATED)
     * @type {Array<string>}
     * @memberof AuthenticationResponse
     */
    'roles': Array<string>;
    /**
     * The organs that the user is a member of.
     * @type {Array<UserResponse>}
     * @memberof AuthenticationResponse
     */
    'organs': Array<UserResponse>;
    /**
     * The JWT token that can be used as Bearer token for authentication.
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'token': string;
    /**
     * Whether the related user has accepted the Terms of Service  or is not required to.
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'acceptedToS': string;
    /**
     * All unique RBAC permissions the user has
     * @type {Array<RoleWithPermissionsResponse>}
     * @memberof AuthenticationResponse
     */
    'rolesWithPermissions': Array<RoleWithPermissionsResponse>;
}
/**
 * 
 * @export
 * @interface BalanceResponse
 */
export interface BalanceResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BalanceResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BalanceResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BalanceResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BalanceResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof BalanceResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof BalanceResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof BalanceResponse
     */
    'nickname'?: string;
    /**
     * The user\'s type
     * @type {string}
     * @memberof BalanceResponse
     */
    'type': string;
    /**
     * Date at which this user had this balance
     * @type {string}
     * @memberof BalanceResponse
     */
    'date': string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BalanceResponse
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BalanceResponse
     */
    'fine'?: DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BalanceResponse
     */
    'fineWaived'?: DineroObjectResponse;
    /**
     * Timestamp of the first fine
     * @type {string}
     * @memberof BalanceResponse
     */
    'fineSince'?: string;
    /**
     * The number of fines this user has received. 0 if no unpaid fines.
     * @type {number}
     * @memberof BalanceResponse
     */
    'nrFines': number;
    /**
     * The ID of the last transaction that was present when the balance was cached. -1 if the user has not made any transactions
     * @type {number}
     * @memberof BalanceResponse
     */
    'lastTransactionId'?: number;
    /**
     * The timestamp of this user\'s last transaction. NULL if this user has not made any transactions
     * @type {string}
     * @memberof BalanceResponse
     */
    'lastTransactionDate'?: string;
    /**
     * The ID of the last transfer that was present when the balance was cached. -1 if the user has not made any transfers
     * @type {number}
     * @memberof BalanceResponse
     */
    'lastTransferId'?: number;
}
/**
 * API Request for creating a `banner` entity.
 * @export
 * @interface BannerRequest
 */
export interface BannerRequest {
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerRequest
     */
    'name'?: string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerRequest
     */
    'duration'?: number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerRequest
     */
    'active'?: boolean;
    /**
     * The starting date from which the advertisement should be shown
     * @type {string}
     * @memberof BannerRequest
     */
    'startDate'?: string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerRequest
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface BannerResponse
 */
export interface BannerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BannerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BannerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BannerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BannerResponse
     */
    'version'?: number;
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerResponse
     */
    'name': string;
    /**
     * Location of the image
     * @type {string}
     * @memberof BannerResponse
     */
    'image'?: string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerResponse
     */
    'duration': number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerResponse
     */
    'active': boolean;
    /**
     * The starting date from which the banner should be shown
     * @type {string}
     * @memberof BannerResponse
     */
    'startDate': string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerResponse
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface BaseContainerResponse
 */
export interface BaseContainerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof BaseContainerResponse
     */
    'public'?: boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'revision'?: number;
}
/**
 * 
 * @export
 * @interface BaseContainerSummaryResponse
 */
export interface BaseContainerSummaryResponse {
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BaseContainerSummaryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {number}
     * @memberof BaseContainerSummaryResponse
     */
    'amountOfProducts': number;
}
/**
 * 
 * @export
 * @interface BaseEventAnswerResponse
 */
export interface BaseEventAnswerResponse {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseEventAnswerResponse
     */
    'user': BaseUserResponse;
    /**
     * Filled in availability per slot.
     * @type {string}
     * @memberof BaseEventAnswerResponse
     */
    'availability'?: string;
    /**
     * Whether this user is selected for the shift in the event
     * @type {boolean}
     * @memberof BaseEventAnswerResponse
     */
    'selected': boolean;
}
/**
 * 
 * @export
 * @interface BaseEventResponse
 */
export interface BaseEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseEventResponse
     */
    'version'?: number;
    /**
     * Name of the borrel.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseEventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'endDate': string;
    /**
     * The tpye of event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface BaseEventShiftResponse
 */
export interface BaseEventShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseEventShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseEventShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BaseFineHandoutEventResponse
 */
export interface BaseFineHandoutEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseFineHandoutEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseFineHandoutEventResponse
     */
    'version'?: number;
    /**
     * Reference date of fines
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'referenceDate': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseFineHandoutEventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * The amount of fines that were handed out
     * @type {number}
     * @memberof BaseFineHandoutEventResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface BaseInvoiceResponse
 */
export interface BaseInvoiceResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseInvoiceResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseInvoiceResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseInvoiceResponse
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'addressee': string;
    /**
     * Reference of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'reference': string;
    /**
     * Special attention to the addressee
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'attention': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'description': string;
    /**
     * 
     * @type {InvoiceStatusResponse}
     * @memberof BaseInvoiceResponse
     */
    'currentState': InvoiceStatusResponse;
    /**
     * Street of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'street': string;
    /**
     * Postal code of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'postalCode': string;
    /**
     *  City of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'city': string;
    /**
     *  Country of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'country': string;
    /**
     * Date of the invoice
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'date': string;
    /**
     * 
     * @type {TransferResponse}
     * @memberof BaseInvoiceResponse
     */
    'transfer'?: TransferResponse;
    /**
     * Pdf url path linked to the invoice
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'pdf'?: string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BaseInvoiceResponse
     */
    'totalInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface BasePayoutRequestResponse
 */
export interface BasePayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BasePayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BasePayoutRequestResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BasePayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BasePayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BasePayoutRequestResponse
     */
    'amount': DineroObjectResponse;
    /**
     * The current status of the payout request
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'status'?: BasePayoutRequestResponseStatusEnum;
    /**
     * The PDF of the payout request
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'pdf'?: string;
}

export const BasePayoutRequestResponseStatusEnum = {
    Created: 'CREATED',
    Approved: 'APPROVED',
    Denied: 'DENIED',
    Cancelled: 'CANCELLED'
} as const;

export type BasePayoutRequestResponseStatusEnum = typeof BasePayoutRequestResponseStatusEnum[keyof typeof BasePayoutRequestResponseStatusEnum];

/**
 * 
 * @export
 * @interface BasePointOfSaleResponse
 */
export interface BasePointOfSaleResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BasePointOfSaleResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BasePointOfSaleResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BaseProductResponse
 */
export interface BaseProductResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseProductResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseProductResponse
     */
    'version'?: number;
    /**
     * The name of the product.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BaseProductResponse
     */
    'priceInclVat': DineroObjectResponse;
    /**
     * 
     * @type {BaseVatGroupResponse}
     * @memberof BaseProductResponse
     */
    'vat': BaseVatGroupResponse;
}
/**
 * 
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseResponse
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface BaseTransactionResponse
 */
export interface BaseTransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseTransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseTransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseTransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseTransactionResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseTransactionResponse
     */
    'from': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseTransactionResponse
     */
    'createdBy'?: BaseUserResponse;
    /**
     * 
     * @type {BasePointOfSaleResponse}
     * @memberof BaseTransactionResponse
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     * 
     * @type {Dinero}
     * @memberof BaseTransactionResponse
     */
    'value': Dinero;
}
/**
 * 
 * @export
 * @interface BaseUserResponse
 */
export interface BaseUserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseUserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseUserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof BaseUserResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof BaseUserResponse
     */
    'nickname'?: string;
}
/**
 * 
 * @export
 * @interface BaseVatGroupResponse
 */
export interface BaseVatGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseVatGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseVatGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'version'?: number;
    /**
     * Percentage of VAT
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'percentage': number;
    /**
     * Whether VAT should be hidden
     * @type {boolean}
     * @memberof BaseVatGroupResponse
     */
    'hidden': boolean;
}
/**
 * 
 * @export
 * @interface BaseWriteOffResponse
 */
export interface BaseWriteOffResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseWriteOffResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseWriteOffResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseWriteOffResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseWriteOffResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseWriteOffResponse
     */
    'to': BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BaseWriteOffResponse
     */
    'amount': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface ContainerResponse
 */
export interface ContainerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ContainerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ContainerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ContainerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ContainerResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof ContainerResponse
     */
    'public'?: boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof ContainerResponse
     */
    'revision'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof ContainerResponse
     */
    'owner': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface ContainerSummaryRecord
 */
export interface ContainerSummaryRecord {
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ContainerSummaryRecord
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {number}
     * @memberof ContainerSummaryRecord
     */
    'amountOfProducts': number;
    /**
     * 
     * @type {ContainerSummaryRecordAllOfUser}
     * @memberof ContainerSummaryRecord
     */
    'user': ContainerSummaryRecordAllOfUser;
    /**
     * 
     * @type {number}
     * @memberof ContainerSummaryRecord
     */
    'containerId': number;
}
/**
 * 
 * @export
 * @interface ContainerSummaryRecordAllOfUser
 */
export interface ContainerSummaryRecordAllOfUser {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ContainerSummaryRecordAllOfUser
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ContainerSummaryRecordAllOfUser
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ContainerSummaryRecordAllOfUser
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ContainerSummaryRecordAllOfUser
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof ContainerSummaryRecordAllOfUser
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof ContainerSummaryRecordAllOfUser
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof ContainerSummaryRecordAllOfUser
     */
    'nickname'?: string;
}
/**
 * 
 * @export
 * @interface ContainerSummaryResponse
 */
export interface ContainerSummaryResponse {
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ContainerSummaryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {number}
     * @memberof ContainerSummaryResponse
     */
    'amountOfProducts': number;
    /**
     * All summaries matching the request, excluding all people who have extensiveDataProcessing disabled.
     * @type {Array<ContainerSummaryRecord>}
     * @memberof ContainerSummaryResponse
     */
    'summaries': Array<ContainerSummaryRecord>;
}
/**
 * 
 * @export
 * @interface ContainerWithProductsResponse
 */
export interface ContainerWithProductsResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof ContainerWithProductsResponse
     */
    'public'?: boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'revision'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof ContainerWithProductsResponse
     */
    'owner': BaseUserResponse;
    /**
     * The products in the container.
     * @type {Array<ProductResponse>}
     * @memberof ContainerWithProductsResponse
     */
    'products': Array<ProductResponse>;
}
/**
 * 
 * @export
 * @interface CreateContainerRequest
 */
export interface CreateContainerRequest {
    /**
     * Name of the container
     * @type {string}
     * @memberof CreateContainerRequest
     */
    'name': string;
    /**
     *    IDs or requests of the products to add to the container
     * @type {Array<number>}
     * @memberof CreateContainerRequest
     */
    'products': Array<number>;
    /**
     * Whether the container is public or not
     * @type {boolean}
     * @memberof CreateContainerRequest
     */
    'public': boolean;
    /**
     * Id of the user who will own the container, if undefined it will    default to the token ID.
     * @type {number}
     * @memberof CreateContainerRequest
     */
    'ownerId'?: number;
}
/**
 * 
 * @export
 * @interface CreateEventRequest
 */
export interface CreateEventRequest {
    /**
     * Name of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'name': string;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'endDate': string;
    /**
     * The type of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'type'?: string;
    /**
     * IDs of shifts that are in this event per participant per borrel.
     * @type {Array<number>}
     * @memberof CreateEventRequest
     */
    'shiftIds': Array<number>;
}
/**
 * 
 * @export
 * @interface CreateInvoiceRequest
 */
export interface CreateInvoiceRequest {
    /**
     * The recipient of the Invoice.
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'forId': number;
    /**
     * The creator of the Invoice, defaults to the ID of the requester.
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'byId'?: number;
    /**
     * Name of the addressed, defaults to the fullname of the person being invoiced.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'addressee'?: string;
    /**
     * The description of the invoice.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'description': string;
    /**
     * The reference of the invoice.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'reference': string;
    /**
     * IDs of the transactions to add to the Invoice.
     * @type {Array<number>}
     * @memberof CreateInvoiceRequest
     */
    'transactionIDs': Array<number>;
    /**
     * Street to use on the invoice, overwrites the users default.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'street'?: string;
    /**
     * Postal code to use on the invoice, overwrites the users default.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'postalCode'?: string;
    /**
     * City to use on the invoice, overwrites the users default.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'city'?: string;
    /**
     * Country to use on the invoice, overwrites the users default.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'country'?: string;
    /**
     * Date to use on the invoice, overwrites the creation date.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'date'?: string;
    /**
     * Attention to use on the invoice.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'attention'?: string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof CreateInvoiceRequest
     */
    'amount': DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface CreatePermissionParams
 */
export interface CreatePermissionParams {
    /**
     * Entity
     * @type {string}
     * @memberof CreatePermissionParams
     */
    'entity': string;
    /**
     * Action
     * @type {string}
     * @memberof CreatePermissionParams
     */
    'action': string;
    /**
     * Relation
     * @type {string}
     * @memberof CreatePermissionParams
     */
    'relation': string;
    /**
     * Attributes
     * @type {Array<string>}
     * @memberof CreatePermissionParams
     */
    'attributes': Array<string>;
}
/**
 * 
 * @export
 * @interface CreatePointOfSaleRequest
 */
export interface CreatePointOfSaleRequest {
    /**
     * Name of the POS
     * @type {string}
     * @memberof CreatePointOfSaleRequest
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof CreatePointOfSaleRequest
     */
    'useAuthentication': boolean;
    /**
     * IDs or Requests of the containers to add to the POS
     * @type {Array<number>}
     * @memberof CreatePointOfSaleRequest
     */
    'containers': Array<number>;
    /**
     * ID of the user who will own the POS, if undefined it will    default to the token ID.
     * @type {number}
     * @memberof CreatePointOfSaleRequest
     */
    'ownerId': number;
    /**
     * Users that have at least one of the given roles can create transactions in this POS (but not open/close/edit it)
     * @type {Array<number>}
     * @memberof CreatePointOfSaleRequest
     */
    'cashierRoleIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface CreateProductRequest
 */
export interface CreateProductRequest {
    /**
     * Name of the product
     * @type {string}
     * @memberof CreateProductRequest
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof CreateProductRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * VAT group ID of the product
     * @type {number}
     * @memberof CreateProductRequest
     */
    'vat': number;
    /**
     * Category of the product
     * @type {number}
     * @memberof CreateProductRequest
     */
    'category': number;
    /**
     * Alcohol percentage of the product in 2 decimals
     * @type {number}
     * @memberof CreateProductRequest
     */
    'alcoholPercentage': number;
    /**
     * If product is featured
     * @type {boolean}
     * @memberof CreateProductRequest
     */
    'featured'?: boolean;
    /**
     * If product is preferred
     * @type {boolean}
     * @memberof CreateProductRequest
     */
    'preferred'?: boolean;
    /**
     * If product is shown on narrowcasting screens
     * @type {boolean}
     * @memberof CreateProductRequest
     */
    'priceList'?: boolean;
    /**
     * ID of the owner
     * @type {number}
     * @memberof CreateProductRequest
     */
    'ownerId': number;
}
/**
 * 
 * @export
 * @interface CreateSellerPayoutRequest
 */
export interface CreateSellerPayoutRequest {
    /**
     * The user to create the Seller Payout for
     * @type {number}
     * @memberof CreateSellerPayoutRequest
     */
    'requestedById': number;
    /**
     * Reference of the seller payout
     * @type {string}
     * @memberof CreateSellerPayoutRequest
     */
    'reference': string;
    /**
     * The lower bound of the range of transactions to be paid out
     * @type {string}
     * @memberof CreateSellerPayoutRequest
     */
    'startDate': string;
    /**
     * the upper bound of the range of transactions to be paid out.
     * @type {string}
     * @memberof CreateSellerPayoutRequest
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface CreateShiftRequest
 */
export interface CreateShiftRequest {
    /**
     * Name of the event
     * @type {string}
     * @memberof CreateShiftRequest
     */
    'name': string;
    /**
     * Roles that (can) have this shift
     * @type {Array<string>}
     * @memberof CreateShiftRequest
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'canGoIntoDebt': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'ofAge': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface Dinero
 */
export interface Dinero {
    /**
     * The amount of money as integer in the given precision.
     * @type {number}
     * @memberof Dinero
     */
    'amount': number;
    /**
     * The precision of the amount, in decimal places.
     * @type {number}
     * @memberof Dinero
     */
    'precision': number;
    /**
     * The ISO 4217 currency code.
     * @type {string}
     * @memberof Dinero
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface DineroObject
 */
export interface DineroObject {
    /**
     * amount
     * @type {number}
     * @memberof DineroObject
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObject
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObject
     */
    'precision': number;
}
/**
 * 
 * @export
 * @interface DineroObjectRequest
 */
export interface DineroObjectRequest {
    /**
     * amount
     * @type {number}
     * @memberof DineroObjectRequest
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObjectRequest
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObjectRequest
     */
    'precision': number;
}
/**
 * 
 * @export
 * @interface DineroObjectResponse
 */
export interface DineroObjectResponse {
    /**
     * amount
     * @type {number}
     * @memberof DineroObjectResponse
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObjectResponse
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObjectResponse
     */
    'precision': number;
}
/**
 * 
 * @export
 * @interface EventAnswerAssignmentRequest
 */
export interface EventAnswerAssignmentRequest {
    /**
     * Whether this user is selected for the given shift at the given event
     * @type {boolean}
     * @memberof EventAnswerAssignmentRequest
     */
    'selected': boolean;
}
/**
 * 
 * @export
 * @interface EventAnswerAvailabilityRequest
 */
export interface EventAnswerAvailabilityRequest {
    /**
     * New availability of the given user for the given event (YES, NO, LATER, NA)
     * @type {string}
     * @memberof EventAnswerAvailabilityRequest
     */
    'availability': string;
}
/**
 * 
 * @export
 * @interface EventInShiftResponse
 */
export interface EventInShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventInShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventInShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'name': string;
    /**
     * Which roles can fill in this shift.
     * @type {Array<string>}
     * @memberof EventInShiftResponse
     */
    'roles': Array<string>;
    /**
     * Answers for this shift.
     * @type {Array<BaseEventAnswerResponse>}
     * @memberof EventInShiftResponse
     */
    'answers'?: Array<BaseEventAnswerResponse>;
}
/**
 * 
 * @export
 * @interface EventPlanningSelectedCount
 */
export interface EventPlanningSelectedCount {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'nickname'?: string;
    /**
     * Number of times this user was selected for this shift
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventResponse
     */
    'version'?: number;
    /**
     * Name of the borrel.
     * @type {string}
     * @memberof EventResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof EventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof EventResponse
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof EventResponse
     */
    'endDate': string;
    /**
     * The tpye of event.
     * @type {string}
     * @memberof EventResponse
     */
    'type': string;
    /**
     * Shifts for this event
     * @type {Array<EventInShiftResponse>}
     * @memberof EventResponse
     */
    'shifts': Array<EventInShiftResponse>;
}
/**
 * 
 * @export
 * @interface EventShiftResponse
 */
export interface EventShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'name': string;
    /**
     * Which roles can fill in this shift.
     * @type {Array<string>}
     * @memberof EventShiftResponse
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface FinancialMutationResponse
 */
export interface FinancialMutationResponse {
    /**
     * Type of mutation (\'transfer\' or \'transaction\') (Optional)
     * @type {string}
     * @memberof FinancialMutationResponse
     */
    'type': FinancialMutationResponseTypeEnum;
    /**
     * 
     * @type {FinancialMutationResponseMutation}
     * @memberof FinancialMutationResponse
     */
    'mutation'?: FinancialMutationResponseMutation;
}

export const FinancialMutationResponseTypeEnum = {
    Transfer: 'transfer',
    Transaction: 'transaction'
} as const;

export type FinancialMutationResponseTypeEnum = typeof FinancialMutationResponseTypeEnum[keyof typeof FinancialMutationResponseTypeEnum];

/**
 * @type FinancialMutationResponseMutation
 * Details of mutation, this can be either of type TransferResponse or BaseTransactionResponse
 * @export
 */
export type FinancialMutationResponseMutation = BaseTransactionResponse | TransferResponse;

/**
 * 
 * @export
 * @interface FineHandoutEventResponse
 */
export interface FineHandoutEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof FineHandoutEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof FineHandoutEventResponse
     */
    'version'?: number;
    /**
     * Reference date of fines
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'referenceDate': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof FineHandoutEventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * The amount of fines that were handed out
     * @type {number}
     * @memberof FineHandoutEventResponse
     */
    'count': number;
    /**
     * Fines that have been handed out
     * @type {Array<FineResponse>}
     * @memberof FineHandoutEventResponse
     */
    'fines': Array<FineResponse>;
}
/**
 * 
 * @export
 * @interface FineReportResponse
 */
export interface FineReportResponse {
    /**
     * From date of the report
     * @type {string}
     * @memberof FineReportResponse
     */
    'fromDate': string;
    /**
     * To date of the report
     * @type {string}
     * @memberof FineReportResponse
     */
    'toDate': string;
    /**
     * Number of fines
     * @type {number}
     * @memberof FineReportResponse
     */
    'count': number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof FineReportResponse
     */
    'handedOut': DineroObjectResponse;
    /**
     * Number of fines waived
     * @type {number}
     * @memberof FineReportResponse
     */
    'waivedCount': number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof FineReportResponse
     */
    'waived': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface FineResponse
 */
export interface FineResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof FineResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof FineResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof FineResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof FineResponse
     */
    'version'?: number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof FineResponse
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof FineResponse
     */
    'user': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface GEWISAuthenticationPinRequest
 */
export interface GEWISAuthenticationPinRequest {
    /**
     * 
     * @type {number}
     * @memberof GEWISAuthenticationPinRequest
     */
    'gewisId': number;
    /**
     * 
     * @type {string}
     * @memberof GEWISAuthenticationPinRequest
     */
    'pin': string;
}
/**
 * 
 * @export
 * @interface GetAllBalanceUserTypesParameterInner
 */
export interface GetAllBalanceUserTypesParameterInner {
}
/**
 * @type GetAllPayoutRequestsRequestedByIdParameter
 * @export
 */
export type GetAllPayoutRequestsRequestedByIdParameter = Array<number> | number;

/**
 * 
 * @export
 * @interface GewisUserResponse
 */
export interface GewisUserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof GewisUserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof GewisUserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'nickname'?: string;
    /**
     * Whether the user activated
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'active': boolean;
    /**
     * Whether the user is deleted
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'deleted': boolean;
    /**
     * The type of user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'type': string;
    /**
     * If local user, the e-mail of the user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'email'?: string;
    /**
     * Whether this user has accepted the TOS
     * @type {string}
     * @memberof GewisUserResponse
     */
    'acceptedToS'?: string;
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'extensiveDataProcessing'?: boolean;
    /**
     * Whether someone is old enough to drink beer
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'ofAge'?: boolean;
    /**
     * Whether this user can get a negative balance
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'canGoIntoDebt': boolean;
    /**
     * The m-Number of the user
     * @type {number}
     * @memberof GewisUserResponse
     */
    'gewisId'?: number;
}
/**
 * 
 * @export
 * @interface GewiswebAuthenticationRequest
 */
export interface GewiswebAuthenticationRequest {
    /**
     * The gewisweb JWT token.
     * @type {string}
     * @memberof GewiswebAuthenticationRequest
     */
    'token': string;
    /**
     * The nonce used in the newly signed JWT token.
     * @type {string}
     * @memberof GewiswebAuthenticationRequest
     */
    'nonce': string;
}
/**
 * 
 * @export
 * @interface HandoutFinesRequest
 */
export interface HandoutFinesRequest {
    /**
     * Users to fine. If a user is not eligible for a fine, a fine of 0,00 will be handed out.
     * @type {Array<number>}
     * @memberof HandoutFinesRequest
     */
    'userIds': Array<number>;
    /**
     * Reference date to calculate the balance and thus the height of the fine for.
     * @type {string}
     * @memberof HandoutFinesRequest
     */
    'referenceDate': string;
}
/**
 * 
 * @export
 * @interface InvoiceEntryRequest
 */
export interface InvoiceEntryRequest {
    /**
     * The description of the entry
     * @type {string}
     * @memberof InvoiceEntryRequest
     */
    'description': string;
    /**
     * Amount of item sold.
     * @type {number}
     * @memberof InvoiceEntryRequest
     */
    'amount': number;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof InvoiceEntryRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * The percentage of VAT applied to this item
     * @type {number}
     * @memberof InvoiceEntryRequest
     */
    'vatPercentage': number;
}
/**
 * 
 * @export
 * @interface InvoiceEntryResponse
 */
export interface InvoiceEntryResponse {
    /**
     * The description of the entry
     * @type {string}
     * @memberof InvoiceEntryResponse
     */
    'description': string;
    /**
     * Amount of products sold.
     * @type {number}
     * @memberof InvoiceEntryResponse
     */
    'amount': number;
    /**
     * 
     * @type {DineroObject}
     * @memberof InvoiceEntryResponse
     */
    'priceInclVat': DineroObject;
    /**
     * The percentage of VAT applied to this entry
     * @type {number}
     * @memberof InvoiceEntryResponse
     */
    'vatPercentage': number;
    /**
     * If the entry is a custom entry or not.
     * @type {boolean}
     * @memberof InvoiceEntryResponse
     */
    'custom': boolean;
}
/**
 * 
 * @export
 * @interface InvoiceResponse
 */
export interface InvoiceResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof InvoiceResponse
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'addressee': string;
    /**
     * Reference of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'reference': string;
    /**
     * Special attention to the addressee
     * @type {string}
     * @memberof InvoiceResponse
     */
    'attention': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'description': string;
    /**
     * 
     * @type {InvoiceStatusResponse}
     * @memberof InvoiceResponse
     */
    'currentState': InvoiceStatusResponse;
    /**
     * Street of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'street': string;
    /**
     * Postal code of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'postalCode': string;
    /**
     *  City of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'city': string;
    /**
     *  Country of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'country': string;
    /**
     * Date of the invoice
     * @type {string}
     * @memberof InvoiceResponse
     */
    'date': string;
    /**
     * 
     * @type {TransferResponse}
     * @memberof InvoiceResponse
     */
    'transfer'?: TransferResponse;
    /**
     * Pdf url path linked to the invoice
     * @type {string}
     * @memberof InvoiceResponse
     */
    'pdf'?: string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof InvoiceResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * The entries of the invoice
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponse
     */
    'invoiceEntries': Array<InvoiceEntryResponse>;
}
/**
 * 
 * @export
 * @interface InvoiceResponseTypes
 */
export interface InvoiceResponseTypes {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof InvoiceResponseTypes
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof InvoiceResponseTypes
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof InvoiceResponseTypes
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'addressee': string;
    /**
     * Reference of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'reference': string;
    /**
     * Special attention to the addressee
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'attention': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'description': string;
    /**
     * 
     * @type {InvoiceStatusResponse}
     * @memberof InvoiceResponseTypes
     */
    'currentState': InvoiceStatusResponse;
    /**
     * Street of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'street': string;
    /**
     * Postal code of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'postalCode': string;
    /**
     *  City of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'city': string;
    /**
     *  Country of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'country': string;
    /**
     * Date of the invoice
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'date': string;
    /**
     * 
     * @type {TransferResponse}
     * @memberof InvoiceResponseTypes
     */
    'transfer'?: TransferResponse;
    /**
     * Pdf url path linked to the invoice
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'pdf'?: string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof InvoiceResponseTypes
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * The entries of the invoice
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponseTypes
     */
    'invoiceEntries'?: Array<InvoiceEntryResponse>;
}
/**
 * 
 * @export
 * @interface InvoiceStatusResponse
 */
export interface InvoiceStatusResponse {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof InvoiceStatusResponse
     */
    'changedBy': BaseUserResponse;
    /**
     * The state of the invoice
     * @type {string}
     * @memberof InvoiceStatusResponse
     */
    'state': InvoiceStatusResponseStateEnum;
}

export const InvoiceStatusResponseStateEnum = {
    Created: 'CREATED',
    Sent: 'SENT',
    Paid: 'PAID',
    Deleted: 'DELETED'
} as const;

export type InvoiceStatusResponseStateEnum = typeof InvoiceStatusResponseStateEnum[keyof typeof InvoiceStatusResponseStateEnum];

/**
 * 
 * @export
 * @interface InvoiceUserResponse
 */
export interface InvoiceUserResponse {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof InvoiceUserResponse
     */
    'user': BaseUserResponse;
    /**
     * Default street to use for invoices.
     * @type {string}
     * @memberof InvoiceUserResponse
     */
    'street': string;
    /**
     * Default postal code to use for invoices.
     * @type {string}
     * @memberof InvoiceUserResponse
     */
    'postalCode': string;
    /**
     * Default city to use for invoices.
     * @type {string}
     * @memberof InvoiceUserResponse
     */
    'city': string;
    /**
     * Default country to use for invoices.
     * @type {string}
     * @memberof InvoiceUserResponse
     */
    'country': string;
    /**
     * Whether invoices should be automatically generated
     * @type {boolean}
     * @memberof InvoiceUserResponse
     */
    'automatic': boolean;
}
/**
 * 
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * The message response text.
     * @type {string}
     * @memberof MessageResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PaginatedBalanceResponse
 */
export interface PaginatedBalanceResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBalanceResponse
     */
    '_pagination'?: PaginationResult;
    /**
     * Returned balance responses
     * @type {Array<BalanceResponse>}
     * @memberof PaginatedBalanceResponse
     */
    'records'?: Array<BalanceResponse>;
}
/**
 * Paginated API Response for the `banner` entity.
 * @export
 * @interface PaginatedBannerResponse
 */
export interface PaginatedBannerResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBannerResponse
     */
    '_pagination'?: PaginationResult;
    /**
     * Returned banners
     * @type {Array<BannerResponse>}
     * @memberof PaginatedBannerResponse
     */
    'records'?: Array<BannerResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedBaseEventResponse
 */
export interface PaginatedBaseEventResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBaseEventResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned borrel Schemas
     * @type {Array<BaseEventResponse>}
     * @memberof PaginatedBaseEventResponse
     */
    'records': Array<BaseEventResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedBasePayoutRequestResponse
 */
export interface PaginatedBasePayoutRequestResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBasePayoutRequestResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned payout requests
     * @type {Array<BasePayoutRequestResponse>}
     * @memberof PaginatedBasePayoutRequestResponse
     */
    'records': Array<BasePayoutRequestResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedBaseTransactionResponse
 */
export interface PaginatedBaseTransactionResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBaseTransactionResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned banners
     * @type {Array<BaseTransactionResponse>}
     * @memberof PaginatedBaseTransactionResponse
     */
    'records': Array<BaseTransactionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedContainerResponse
 */
export interface PaginatedContainerResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedContainerResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned containers
     * @type {Array<ContainerResponse>}
     * @memberof PaginatedContainerResponse
     */
    'records': Array<ContainerResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedContainerWithProductResponse
 */
export interface PaginatedContainerWithProductResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedContainerWithProductResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned containers
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PaginatedContainerWithProductResponse
     */
    'records': Array<ContainerWithProductsResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedEventShiftResponse
 */
export interface PaginatedEventShiftResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedEventShiftResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned event shifts
     * @type {Array<EventShiftResponse>}
     * @memberof PaginatedEventShiftResponse
     */
    'records': Array<EventShiftResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedFinancialMutationResponse
 */
export interface PaginatedFinancialMutationResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedFinancialMutationResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned mutations
     * @type {Array<FinancialMutationResponse>}
     * @memberof PaginatedFinancialMutationResponse
     */
    'records': Array<FinancialMutationResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedFineHandoutEventResponse
 */
export interface PaginatedFineHandoutEventResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedFineHandoutEventResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned fine handout events
     * @type {Array<BaseFineHandoutEventResponse>}
     * @memberof PaginatedFineHandoutEventResponse
     */
    'records': Array<BaseFineHandoutEventResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedInvoiceResponse
 */
export interface PaginatedInvoiceResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedInvoiceResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned Invoices
     * @type {Array<InvoiceResponseTypes>}
     * @memberof PaginatedInvoiceResponse
     */
    'records': Array<InvoiceResponseTypes>;
}
/**
 * 
 * @export
 * @interface PaginatedPointOfSaleResponse
 */
export interface PaginatedPointOfSaleResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedPointOfSaleResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned points of sale
     * @type {Array<PointOfSaleResponse>}
     * @memberof PaginatedPointOfSaleResponse
     */
    'records': Array<PointOfSaleResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedProductCategoryResponse
 */
export interface PaginatedProductCategoryResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedProductCategoryResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned product categories
     * @type {Array<ProductCategoryResponse>}
     * @memberof PaginatedProductCategoryResponse
     */
    'records': Array<ProductCategoryResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedProductResponse
 */
export interface PaginatedProductResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedProductResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned products
     * @type {Array<ProductResponse>}
     * @memberof PaginatedProductResponse
     */
    'records': Array<ProductResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedSellerPayoutResponse
 */
export interface PaginatedSellerPayoutResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedSellerPayoutResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<SellerPayoutResponse>}
     * @memberof PaginatedSellerPayoutResponse
     */
    'records': Array<SellerPayoutResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedTransferResponse
 */
export interface PaginatedTransferResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedTransferResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned transfers
     * @type {Array<TransferResponse>}
     * @memberof PaginatedTransferResponse
     */
    'records': Array<TransferResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedUserResponse
 */
export interface PaginatedUserResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedUserResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned users
     * @type {Array<UserResponse>}
     * @memberof PaginatedUserResponse
     */
    'records': Array<UserResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedVatGroupResponse
 */
export interface PaginatedVatGroupResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedVatGroupResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned VAT groups
     * @type {Array<VatGroupResponse>}
     * @memberof PaginatedVatGroupResponse
     */
    'records': Array<VatGroupResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedVoucherGroupResponse
 */
export interface PaginatedVoucherGroupResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedVoucherGroupResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned voucher groups
     * @type {Array<VoucherGroupResponse>}
     * @memberof PaginatedVoucherGroupResponse
     */
    'records': Array<VoucherGroupResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedWriteOffResponse
 */
export interface PaginatedWriteOffResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedWriteOffResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned write-offs
     * @type {Array<WriteOffResponse>}
     * @memberof PaginatedWriteOffResponse
     */
    'records': Array<WriteOffResponse>;
}
/**
 * 
 * @export
 * @interface PaginationResult
 */
export interface PaginationResult {
    /**
     * Number of records queried
     * @type {number}
     * @memberof PaginationResult
     */
    'take': number;
    /**
     * Number of skipped records
     * @type {number}
     * @memberof PaginationResult
     */
    'skip': number;
    /**
     * Total number of resulting records
     * @type {number}
     * @memberof PaginationResult
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface PayoutRequestRequest
 */
export interface PayoutRequestRequest {
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof PayoutRequestRequest
     */
    'amount': DineroObjectRequest;
    /**
     * The bank account number to transfer the money to
     * @type {string}
     * @memberof PayoutRequestRequest
     */
    'bankAccountNumber': string;
    /**
     * The name of the owner of the bank account
     * @type {string}
     * @memberof PayoutRequestRequest
     */
    'bankAccountName': string;
    /**
     * The ID of the user who requested the payout
     * @type {number}
     * @memberof PayoutRequestRequest
     */
    'forId': number;
}
/**
 * 
 * @export
 * @interface PayoutRequestResponse
 */
export interface PayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PayoutRequestResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof PayoutRequestResponse
     */
    'amount': DineroObjectResponse;
    /**
     * The current status of the payout request
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'status'?: PayoutRequestResponseStatusEnum;
    /**
     * The PDF of the payout request
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'pdf'?: string;
    /**
     * Statuses of this payout response over time
     * @type {Array<PayoutRequestStatusResponse>}
     * @memberof PayoutRequestResponse
     */
    'statuses': Array<PayoutRequestStatusResponse>;
    /**
     * Bank account number
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'bankAccountNumber': string;
    /**
     * Name of the account owner
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'bankAccountName': string;
}

export const PayoutRequestResponseStatusEnum = {
    Created: 'CREATED',
    Approved: 'APPROVED',
    Denied: 'DENIED',
    Cancelled: 'CANCELLED'
} as const;

export type PayoutRequestResponseStatusEnum = typeof PayoutRequestResponseStatusEnum[keyof typeof PayoutRequestResponseStatusEnum];

/**
 * 
 * @export
 * @interface PayoutRequestStatusRequest
 */
export interface PayoutRequestStatusRequest {
    /**
     * PayoutRequestState to change to.
     * @type {string}
     * @memberof PayoutRequestStatusRequest
     */
    'state'?: PayoutRequestStatusRequestStateEnum;
}

export const PayoutRequestStatusRequestStateEnum = {
    Created: 'CREATED',
    Approved: 'APPROVED',
    Denied: 'DENIED',
    Cancelled: 'CANCELLED'
} as const;

export type PayoutRequestStatusRequestStateEnum = typeof PayoutRequestStatusRequestStateEnum[keyof typeof PayoutRequestStatusRequestStateEnum];

/**
 * 
 * @export
 * @interface PayoutRequestStatusResponse
 */
export interface PayoutRequestStatusResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PayoutRequestStatusResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PayoutRequestStatusResponse
     */
    'version'?: number;
    /**
     * The state of this status change
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface PdfUrlResponse
 */
export interface PdfUrlResponse {
    /**
     * The pdf url
     * @type {string}
     * @memberof PdfUrlResponse
     */
    'pdf'?: string;
}
/**
 * 
 * @export
 * @interface PermissionResponse
 */
export interface PermissionResponse {
    /**
     * The name of the entity for which the permissions are.
     * @type {string}
     * @memberof PermissionResponse
     */
    'entity': string;
    /**
     * The permissions per action.
     * @type {Array<ActionResponse>}
     * @memberof PermissionResponse
     */
    'actions': Array<ActionResponse>;
}
/**
 * 
 * @export
 * @interface PointOfSaleAssociateUsersResponse
 */
export interface PointOfSaleAssociateUsersResponse {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PointOfSaleAssociateUsersResponse
     */
    'owner': BaseUserResponse;
    /**
     * Members that belong to the owner
     * @type {Array<BaseUserResponse>}
     * @memberof PointOfSaleAssociateUsersResponse
     */
    'ownerMembers': Array<BaseUserResponse>;
    /**
     * Users that belong to at least one cashier role of this point of sale
     * @type {Array<BaseUserResponse>}
     * @memberof PointOfSaleAssociateUsersResponse
     */
    'cashiers': Array<BaseUserResponse>;
}
/**
 * 
 * @export
 * @interface PointOfSaleResponse
 */
export interface PointOfSaleResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PointOfSaleResponse
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleResponse
     */
    'useAuthentication': boolean;
    /**
     * The roles that are cashiers of this POS
     * @type {Array<RoleResponse>}
     * @memberof PointOfSaleResponse
     */
    'cashierRoles': Array<RoleResponse>;
}
/**
 * 
 * @export
 * @interface PointOfSaleWithContainersResponse
 */
export interface PointOfSaleWithContainersResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PointOfSaleWithContainersResponse
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleWithContainersResponse
     */
    'useAuthentication': boolean;
    /**
     * The roles that are cashiers of this POS
     * @type {Array<RoleResponse>}
     * @memberof PointOfSaleWithContainersResponse
     */
    'cashierRoles': Array<RoleResponse>;
    /**
     * The containers in the point-of-sale.
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PointOfSaleWithContainersResponse
     */
    'containers': Array<ContainerWithProductsResponse>;
}
/**
 * 
 * @export
 * @interface ProductCategoryRequest
 */
export interface ProductCategoryRequest {
    /**
     * Name/label of the productCategory
     * @type {string}
     * @memberof ProductCategoryRequest
     */
    'name': string;
    /**
     * ID of the parent product category
     * @type {number}
     * @memberof ProductCategoryRequest
     */
    'parentCategoryId'?: number;
}
/**
 * 
 * @export
 * @interface ProductCategoryResponse
 */
export interface ProductCategoryResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ProductCategoryResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ProductCategoryResponse
     */
    'version'?: number;
    /**
     * The name of the productCategory.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'name': string;
    /**
     * 
     * @type {ProductCategoryResponse}
     * @memberof ProductCategoryResponse
     */
    'parent'?: ProductCategoryResponse;
}
/**
 * 
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ProductResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ProductResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ProductResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ProductResponse
     */
    'version'?: number;
    /**
     * The name of the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ProductResponse
     */
    'priceInclVat': DineroObjectResponse;
    /**
     * 
     * @type {BaseVatGroupResponse}
     * @memberof ProductResponse
     */
    'vat': BaseVatGroupResponse;
    /**
     * The product revision ID
     * @type {number}
     * @memberof ProductResponse
     */
    'revision': number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof ProductResponse
     */
    'owner': BaseUserResponse;
    /**
     * 
     * @type {ProductCategoryResponse}
     * @memberof ProductResponse
     */
    'category': ProductCategoryResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ProductResponse
     */
    'priceExclVat': DineroObjectResponse;
    /**
     * The URL to the picture representing this product.
     * @type {string}
     * @memberof ProductResponse
     */
    'image'?: string;
    /**
     * The percentage of alcohol in this product.
     * @type {number}
     * @memberof ProductResponse
     */
    'alcoholPercentage': number;
    /**
     * If product is featured
     * @type {boolean}
     * @memberof ProductResponse
     */
    'featured': boolean;
    /**
     * If product is preferred
     * @type {boolean}
     * @memberof ProductResponse
     */
    'preferred': boolean;
    /**
     * If product is shown on narrow casting screens
     * @type {boolean}
     * @memberof ProductResponse
     */
    'priceList': boolean;
}
/**
 * 
 * @export
 * @interface QRCodeResponse
 */
export interface QRCodeResponse {
    /**
     * The session ID
     * @type {string}
     * @memberof QRCodeResponse
     */
    'sessionId': string;
    /**
     * The QR code URL
     * @type {string}
     * @memberof QRCodeResponse
     */
    'qrCodeUrl': string;
    /**
     * The expiry date of the QR code
     * @type {string}
     * @memberof QRCodeResponse
     */
    'expiresAt': string;
}
/**
 * 
 * @export
 * @interface QRStatusResponse
 */
export interface QRStatusResponse {
    /**
     * The status of the QR code
     * @type {string}
     * @memberof QRStatusResponse
     */
    'status': QRStatusResponseStatusEnum;
}

export const QRStatusResponseStatusEnum = {
    Pending: 'PENDING',
    Confirmed: 'CONFIRMED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED'
} as const;

export type QRStatusResponseStatusEnum = typeof QRStatusResponseStatusEnum[keyof typeof QRStatusResponseStatusEnum];

/**
 * 
 * @export
 * @interface RelationResponse
 */
export interface RelationResponse {
    /**
     * The the ownership relation towards the entity.
     * @type {string}
     * @memberof RelationResponse
     */
    'relation': string;
    /**
     * The attributes of the entity for which there is access.
     * @type {Array<string>}
     * @memberof RelationResponse
     */
    'attributes': Array<string>;
}
/**
 * 
 * @export
 * @interface ReportCategoryEntryResponse
 */
export interface ReportCategoryEntryResponse {
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportCategoryEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportCategoryEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {ProductCategoryResponse}
     * @memberof ReportCategoryEntryResponse
     */
    'category': ProductCategoryResponse;
}
/**
 * 
 * @export
 * @interface ReportContainerEntryResponse
 */
export interface ReportContainerEntryResponse {
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportContainerEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportContainerEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {BaseContainerResponse}
     * @memberof ReportContainerEntryResponse
     */
    'container': BaseContainerResponse;
}
/**
 * 
 * @export
 * @interface ReportDataResponse
 */
export interface ReportDataResponse {
    /**
     * products
     * @type {Array<ReportProductEntryResponse>}
     * @memberof ReportDataResponse
     */
    'products'?: Array<ReportProductEntryResponse>;
    /**
     * categories
     * @type {Array<ReportCategoryEntryResponse>}
     * @memberof ReportDataResponse
     */
    'categories'?: Array<ReportCategoryEntryResponse>;
    /**
     * vat
     * @type {Array<ReportVatEntryResponse>}
     * @memberof ReportDataResponse
     */
    'vat'?: Array<ReportVatEntryResponse>;
    /**
     * pos
     * @type {Array<ReportPosEntryResponse>}
     * @memberof ReportDataResponse
     */
    'pos'?: Array<ReportPosEntryResponse>;
    /**
     * containers
     * @type {Array<ReportContainerEntryResponse>}
     * @memberof ReportDataResponse
     */
    'containers'?: Array<ReportContainerEntryResponse>;
}
/**
 * 
 * @export
 * @interface ReportEntryResponse
 */
export interface ReportEntryResponse {
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface ReportPosEntryResponse
 */
export interface ReportPosEntryResponse {
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportPosEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportPosEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {BasePointOfSaleResponse}
     * @memberof ReportPosEntryResponse
     */
    'pos': BasePointOfSaleResponse;
}
/**
 * 
 * @export
 * @interface ReportProductEntryResponse
 */
export interface ReportProductEntryResponse {
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportProductEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportProductEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * count
     * @type {number}
     * @memberof ReportProductEntryResponse
     */
    'count': number;
    /**
     * 
     * @type {BaseProductResponse}
     * @memberof ReportProductEntryResponse
     */
    'product': BaseProductResponse;
}
/**
 * 
 * @export
 * @interface ReportResponse
 */
export interface ReportResponse {
    /**
     * forId
     * @type {number}
     * @memberof ReportResponse
     */
    'forId': number;
    /**
     * fromDate
     * @type {string}
     * @memberof ReportResponse
     */
    'fromDate': string;
    /**
     * tillDate
     * @type {string}
     * @memberof ReportResponse
     */
    'tillDate': string;
    /**
     * 
     * @type {ReportDataResponse}
     * @memberof ReportResponse
     */
    'data': ReportDataResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportResponse
     */
    'totalInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface ReportVatEntryResponse
 */
export interface ReportVatEntryResponse {
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportVatEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ReportVatEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {VatGroupResponse}
     * @memberof ReportVatEntryResponse
     */
    'vat': VatGroupResponse;
}
/**
 * 
 * @export
 * @interface ResetLocalRequest
 */
export interface ResetLocalRequest {
    /**
     * The mail of the user
     * @type {string}
     * @memberof ResetLocalRequest
     */
    'accountMail': string;
}
/**
 * 
 * @export
 * @interface RevisionRequest
 */
export interface RevisionRequest {
    /**
     * revision id
     * @type {number}
     * @memberof RevisionRequest
     */
    'id': number;
    /**
     * revision number
     * @type {number}
     * @memberof RevisionRequest
     */
    'revision': number;
}
/**
 * 
 * @export
 * @interface RoleResponse
 */
export interface RoleResponse {
    /**
     * The ID of the role.
     * @type {number}
     * @memberof RoleResponse
     */
    'id': number;
    /**
     * The name of the role.
     * @type {string}
     * @memberof RoleResponse
     */
    'name': string;
    /**
     * Whether the role is a system default role
     * @type {boolean}
     * @memberof RoleResponse
     */
    'systemDefault': boolean;
    /**
     * The user types this role is default for
     * @type {Array<string>}
     * @memberof RoleResponse
     */
    'userTypes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RoleWithPermissionsResponse
 */
export interface RoleWithPermissionsResponse {
    /**
     * The ID of the role.
     * @type {number}
     * @memberof RoleWithPermissionsResponse
     */
    'id': number;
    /**
     * The name of the role.
     * @type {string}
     * @memberof RoleWithPermissionsResponse
     */
    'name': string;
    /**
     * Whether the role is a system default role
     * @type {boolean}
     * @memberof RoleWithPermissionsResponse
     */
    'systemDefault': boolean;
    /**
     * The user types this role is default for
     * @type {Array<string>}
     * @memberof RoleWithPermissionsResponse
     */
    'userTypes'?: Array<string>;
    /**
     * The permissions with regards to the entity.
     * @type {Array<PermissionResponse>}
     * @memberof RoleWithPermissionsResponse
     */
    'permissions': Array<PermissionResponse>;
}
/**
 * 
 * @export
 * @interface SellerPayoutResponse
 */
export interface SellerPayoutResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SellerPayoutResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SellerPayoutResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SellerPayoutResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SellerPayoutResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof SellerPayoutResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof SellerPayoutResponse
     */
    'amount': DineroObjectResponse;
    /**
     * The lower bound of the time range used for this seller payout (inclusive)
     * @type {string}
     * @memberof SellerPayoutResponse
     */
    'startDate': string;
    /**
     * The upper bound of the time range used for this seller payout (exclusive)
     * @type {string}
     * @memberof SellerPayoutResponse
     */
    'endDate': string;
    /**
     * Reference of the payout
     * @type {string}
     * @memberof SellerPayoutResponse
     */
    'reference': string;
}
/**
 * 
 * @export
 * @interface ServerStatusResponse
 */
export interface ServerStatusResponse {
    /**
     * Whether the server is in maintenance mode
     * @type {boolean}
     * @memberof ServerStatusResponse
     */
    'maintenanceMode': boolean;
}
/**
 * 
 * @export
 * @interface SimpleFileRequest
 */
export interface SimpleFileRequest {
    /**
     * Name of the file
     * @type {string}
     * @memberof SimpleFileRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface SimpleFileResponse
 */
export interface SimpleFileResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SimpleFileResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SimpleFileResponse
     */
    'version'?: number;
    /**
     * The filename of the file
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'downloadName': string;
    /**
     * The location of the file in storage
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'location': string;
    /**
     * 
     * @type {UserResponse}
     * @memberof SimpleFileResponse
     */
    'createdBy': UserResponse;
}
/**
 * 
 * @export
 * @interface StripeDepositResponse
 */
export interface StripeDepositResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripeDepositResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripeDepositResponse
     */
    'version'?: number;
    /**
     * The ID of the payment intent in Stripe
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'stripeId': string;
    /**
     * Current status of the deposit
     * @type {Array<StripePaymentIntentStatusResponse>}
     * @memberof StripeDepositResponse
     */
    'depositStatus': Array<StripePaymentIntentStatusResponse>;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof StripeDepositResponse
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof StripeDepositResponse
     */
    'to': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface StripePaymentIntentResponse
 */
export interface StripePaymentIntentResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripePaymentIntentResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripePaymentIntentResponse
     */
    'version'?: number;
    /**
     * ID of the intent in Stripe.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'stripeId': string;
    /**
     * The client secret of the created Payment Intent.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'clientSecret': string;
}
/**
 * 
 * @export
 * @interface StripePaymentIntentStatusResponse
 */
export interface StripePaymentIntentStatusResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripePaymentIntentStatusResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentStatusResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentStatusResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripePaymentIntentStatusResponse
     */
    'version'?: number;
    /**
     * State of the Stripe deposit. It can be 1 (\'CREATED\'), 2 (\'PROCESSING\'), 3 (\'SUCCEEDED\'), or 4 (\'FAILED\')
     * @type {number}
     * @memberof StripePaymentIntentStatusResponse
     */
    'state': number;
}
/**
 * 
 * @export
 * @interface StripePublicKeyResponse
 */
export interface StripePublicKeyResponse {
    /**
     * Stripe public key
     * @type {string}
     * @memberof StripePublicKeyResponse
     */
    'publicKey': string;
    /**
     * Redirect url after payment
     * @type {string}
     * @memberof StripePublicKeyResponse
     */
    'returnUrl': string;
}
/**
 * 
 * @export
 * @interface StripeRequest
 */
export interface StripeRequest {
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof StripeRequest
     */
    'amount'?: DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface SubTransactionRequest
 */
export interface SubTransactionRequest {
    /**
     * to user id
     * @type {number}
     * @memberof SubTransactionRequest
     */
    'to': number;
    /**
     * 
     * @type {RevisionRequest}
     * @memberof SubTransactionRequest
     */
    'container': RevisionRequest;
    /**
     * subtransaction rows
     * @type {Array<SubTransactionRowRequest>}
     * @memberof SubTransactionRequest
     */
    'subTransactionRows': Array<SubTransactionRowRequest>;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof SubTransactionRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface SubTransactionResponse
 */
export interface SubTransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SubTransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SubTransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SubTransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SubTransactionResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof SubTransactionResponse
     */
    'to': BaseUserResponse;
    /**
     * 
     * @type {BaseContainerResponse}
     * @memberof SubTransactionResponse
     */
    'container': BaseContainerResponse;
    /**
     * The rows of this     SubTransaction
     * @type {Array<SubTransactionRowResponse>}
     * @memberof SubTransactionResponse
     */
    'subTransactionRows': Array<SubTransactionRowResponse>;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof SubTransactionResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface SubTransactionRowRequest
 */
export interface SubTransactionRowRequest {
    /**
     * 
     * @type {RevisionRequest}
     * @memberof SubTransactionRowRequest
     */
    'product'?: RevisionRequest;
    /**
     * amount of this product in subtransaction
     * @type {number}
     * @memberof SubTransactionRowRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof SubTransactionRowRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface SubTransactionRowResponse
 */
export interface SubTransactionRowResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SubTransactionRowResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SubTransactionRowResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseProductResponse}
     * @memberof SubTransactionRowResponse
     */
    'product': BaseProductResponse;
    /**
     * The amount that has been bought
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'amount': number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof SubTransactionRowResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TotalBalanceResponse
 */
export interface TotalBalanceResponse {
    /**
     * Date at which this total balance was calculated
     * @type {string}
     * @memberof TotalBalanceResponse
     */
    'date': string;
    /**
     * The total amount of positive balance in SudoSOS
     * @type {number}
     * @memberof TotalBalanceResponse
     */
    'totalPositive': number;
    /**
     * The total amount of negative balance in SudoSOS
     * @type {number}
     * @memberof TotalBalanceResponse
     */
    'totalNegative': number;
    /**
     * 
     * @type {UserTypeTotalBalanceResponse}
     * @memberof TotalBalanceResponse
     */
    'userTypeBalances': UserTypeTotalBalanceResponse;
}
/**
 * 
 * @export
 * @interface TransactionFilterParameters
 */
export interface TransactionFilterParameters {
    /**
     * 
     * @type {Array<number>}
     * @memberof TransactionFilterParameters
     */
    'transactionId'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'fromId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'createdById'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'toId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionFilterParameters
     */
    'exclusiveToId'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'pointOfSaleId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'pointOfSaleRevision'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'containerId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'containerRevision'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'productId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'productRevision'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionFilterParameters
     */
    'fromDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionFilterParameters
     */
    'tillDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'invoiceId'?: number;
}
/**
 * 
 * @export
 * @interface TransactionReportCategoryEntryResponse
 */
export interface TransactionReportCategoryEntryResponse {
    /**
     * 
     * @type {ProductCategoryResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'category': ProductCategoryResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionReportDataResponse
 */
export interface TransactionReportDataResponse {
    /**
     * The entries grouped by product
     * @type {Array<TransactionReportEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'entries': Array<TransactionReportEntryResponse>;
    /**
     * The entries grouped by category
     * @type {Array<TransactionReportCategoryEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'categories': Array<TransactionReportCategoryEntryResponse>;
    /**
     * The entries grouped by vat
     * @type {Array<TransactionReportVatEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'vat': Array<TransactionReportVatEntryResponse>;
}
/**
 * 
 * @export
 * @interface TransactionReportEntryResponse
 */
export interface TransactionReportEntryResponse {
    /**
     * The amount of times this product is in the report
     * @type {number}
     * @memberof TransactionReportEntryResponse
     */
    'count': number;
    /**
     * 
     * @type {BaseProductResponse}
     * @memberof TransactionReportEntryResponse
     */
    'product': BaseProductResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionReportResponse
 */
export interface TransactionReportResponse {
    /**
     * 
     * @type {TransactionFilterParameters}
     * @memberof TransactionReportResponse
     */
    'parameters': TransactionFilterParameters;
    /**
     * 
     * @type {TransactionReportDataResponse}
     * @memberof TransactionReportResponse
     */
    'data': TransactionReportDataResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportResponse
     */
    'totalInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionReportVatEntryResponse
 */
export interface TransactionReportVatEntryResponse {
    /**
     * 
     * @type {BaseVatGroupResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'vat': BaseVatGroupResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionRequest
 */
export interface TransactionRequest {
    /**
     * from user id
     * @type {number}
     * @memberof TransactionRequest
     */
    'from': number;
    /**
     * createdBy user id
     * @type {number}
     * @memberof TransactionRequest
     */
    'createdBy'?: number;
    /**
     * subtransactions
     * @type {Array<SubTransactionRequest>}
     * @memberof TransactionRequest
     */
    'subTransactions': Array<SubTransactionRequest>;
    /**
     * 
     * @type {RevisionRequest}
     * @memberof TransactionRequest
     */
    'pointOfSale': RevisionRequest;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof TransactionRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof TransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof TransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof TransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof TransactionResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransactionResponse
     */
    'from': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransactionResponse
     */
    'createdBy'?: BaseUserResponse;
    /**
     * The subtransactions belonging to this transaction.
     * @type {Array<SubTransactionResponse>}
     * @memberof TransactionResponse
     */
    'subTransactions': Array<SubTransactionResponse>;
    /**
     * 
     * @type {BasePointOfSaleResponse}
     * @memberof TransactionResponse
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransferRequest
 */
export interface TransferRequest {
    /**
     * Date on which the transfer should be created
     * @type {string}
     * @memberof TransferRequest
     */
    'createdAt'?: string;
    /**
     * Description of the transfer.
     * @type {string}
     * @memberof TransferRequest
     */
    'description': string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof TransferRequest
     */
    'amount': DineroObjectRequest;
    /**
     * from which user the money is being transferred.
     * @type {number}
     * @memberof TransferRequest
     */
    'fromId'?: number;
    /**
     * to which user the money is being transferred.
     * @type {number}
     * @memberof TransferRequest
     */
    'toId'?: number;
    /**
     * The vat group id for the transfer.
     * @type {number}
     * @memberof TransferRequest
     */
    'vatId'?: number;
}
/**
 * 
 * @export
 * @interface TransferResponse
 */
export interface TransferResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof TransferResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof TransferResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof TransferResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof TransferResponse
     */
    'version'?: number;
    /**
     * Description of the transfer
     * @type {string}
     * @memberof TransferResponse
     */
    'description': string;
    /**
     * 
     * @type {Dinero}
     * @memberof TransferResponse
     */
    'amountInclVat': Dinero;
    /**
     * 
     * @type {Dinero}
     * @memberof TransferResponse
     */
    'amount': Dinero;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransferResponse
     */
    'from'?: BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransferResponse
     */
    'to'?: BaseUserResponse;
    /**
     * 
     * @type {BaseInvoiceResponse}
     * @memberof TransferResponse
     */
    'invoice'?: BaseInvoiceResponse;
    /**
     * 
     * @type {StripeDepositResponse}
     * @memberof TransferResponse
     */
    'deposit'?: StripeDepositResponse;
    /**
     * 
     * @type {BasePayoutRequestResponse}
     * @memberof TransferResponse
     */
    'payoutRequest'?: BasePayoutRequestResponse;
    /**
     * 
     * @type {FineResponse}
     * @memberof TransferResponse
     */
    'fine'?: FineResponse;
    /**
     * 
     * @type {VatGroupResponse}
     * @memberof TransferResponse
     */
    'vat'?: VatGroupResponse;
    /**
     * 
     * @type {BaseWriteOffResponse}
     * @memberof TransferResponse
     */
    'writeOff'?: BaseWriteOffResponse;
    /**
     * 
     * @type {UserFineGroupResponse}
     * @memberof TransferResponse
     */
    'waivedFines'?: UserFineGroupResponse;
}
/**
 * 
 * @export
 * @interface UpdateContainerRequest
 */
export interface UpdateContainerRequest {
    /**
     * Name of the container
     * @type {string}
     * @memberof UpdateContainerRequest
     */
    'name': string;
    /**
     *    IDs or requests of the products to add to the container
     * @type {Array<number>}
     * @memberof UpdateContainerRequest
     */
    'products': Array<number>;
    /**
     * Whether the container is public or not
     * @type {boolean}
     * @memberof UpdateContainerRequest
     */
    'public': boolean;
}
/**
 * 
 * @export
 * @interface UpdateEventRequest
 */
export interface UpdateEventRequest {
    /**
     * Name of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'name'?: string;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'startDate'?: string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'endDate'?: string;
    /**
     * The type of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'type'?: string;
    /**
     * IDs of shifts that are in this event per participant per borrel.
     * @type {Array<number>}
     * @memberof UpdateEventRequest
     */
    'shiftIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UpdateInvoiceRequest
 */
export interface UpdateInvoiceRequest {
    /**
     * The user who updates the Invoice, defaults to the ID of the requester.
     * @type {number}
     * @memberof UpdateInvoiceRequest
     */
    'byId'?: number;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'addressee'?: string;
    /**
     * The description of the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'description'?: string;
    /**
     * The state to set of the invoice,
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'state'?: UpdateInvoiceRequestStateEnum;
    /**
     * Street to use on the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'street'?: string;
    /**
     * Postal code to use on the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'postalCode'?: string;
    /**
     * City to use on the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'city'?: string;
    /**
     * Country to use on the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'country'?: string;
    /**
     * Reference to use on the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'reference'?: string;
    /**
     * Attention to use on the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'attention'?: string;
    /**
     * Date to use on the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'date'?: string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof UpdateInvoiceRequest
     */
    'amount'?: DineroObjectRequest;
}

export const UpdateInvoiceRequestStateEnum = {
    Created: 'CREATED',
    Sent: 'SENT',
    Paid: 'PAID',
    Deleted: 'DELETED'
} as const;

export type UpdateInvoiceRequestStateEnum = typeof UpdateInvoiceRequestStateEnum[keyof typeof UpdateInvoiceRequestStateEnum];

/**
 * 
 * @export
 * @interface UpdateInvoiceUserRequest
 */
export interface UpdateInvoiceUserRequest {
    /**
     * Default street to use for invoices.
     * @type {string}
     * @memberof UpdateInvoiceUserRequest
     */
    'street': string;
    /**
     * Default postal code to use for invoices.
     * @type {string}
     * @memberof UpdateInvoiceUserRequest
     */
    'postalCode': string;
    /**
     * Default city to use for invoices.
     * @type {string}
     * @memberof UpdateInvoiceUserRequest
     */
    'city': string;
    /**
     * Default country to use for invoices.
     * @type {string}
     * @memberof UpdateInvoiceUserRequest
     */
    'country': string;
    /**
     * Whether invoices should be automatically generated
     * @type {boolean}
     * @memberof UpdateInvoiceUserRequest
     */
    'automatic': boolean;
}
/**
 * 
 * @export
 * @interface UpdateKeyResponse
 */
export interface UpdateKeyResponse {
    /**
     * The key to return
     * @type {string}
     * @memberof UpdateKeyResponse
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface UpdateLocalRequest
 */
export interface UpdateLocalRequest {
    /**
     * The password to set
     * @type {string}
     * @memberof UpdateLocalRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UpdateMaintenanceModeRequest
 */
export interface UpdateMaintenanceModeRequest {
    /**
     * Whether maintenance mode should be enabled or disabled
     * @type {boolean}
     * @memberof UpdateMaintenanceModeRequest
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface UpdateNfcRequest
 */
export interface UpdateNfcRequest {
    /**
     * The NFC code to set
     * @type {string}
     * @memberof UpdateNfcRequest
     */
    'nfcCode': string;
}
/**
 * 
 * @export
 * @interface UpdatePinRequest
 */
export interface UpdatePinRequest {
    /**
     * The PIN code to set
     * @type {string}
     * @memberof UpdatePinRequest
     */
    'pin': string;
}
/**
 * 
 * @export
 * @interface UpdatePointOfSaleRequest
 */
export interface UpdatePointOfSaleRequest {
    /**
     * Name of the POS
     * @type {string}
     * @memberof UpdatePointOfSaleRequest
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof UpdatePointOfSaleRequest
     */
    'useAuthentication': boolean;
    /**
     * IDs or Requests of the containers to add to the POS
     * @type {Array<number>}
     * @memberof UpdatePointOfSaleRequest
     */
    'containers': Array<number>;
    /**
     * ID of the POS to update.
     * @type {number}
     * @memberof UpdatePointOfSaleRequest
     */
    'id': number;
    /**
     * Users that have at least one of the given roles can create transactions in this POS (but not open/close/edit it)
     * @type {Array<number>}
     * @memberof UpdatePointOfSaleRequest
     */
    'cashierRoleIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UpdateProductRequest
 */
export interface UpdateProductRequest {
    /**
     * Name of the product
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof UpdateProductRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * VAT group ID of the product
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'vat': number;
    /**
     * Category of the product
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'category': number;
    /**
     * Alcohol percentage of the product in 2 decimals
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'alcoholPercentage': number;
    /**
     * If product is featured
     * @type {boolean}
     * @memberof UpdateProductRequest
     */
    'featured'?: boolean;
    /**
     * If product is required
     * @type {boolean}
     * @memberof UpdateProductRequest
     */
    'preferred'?: boolean;
    /**
     * If product should be shown on narrowcasting screens
     * @type {boolean}
     * @memberof UpdateProductRequest
     */
    'priceList'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateRoleRequest
 */
export interface UpdateRoleRequest {
    /**
     * Name of the role
     * @type {string}
     * @memberof UpdateRoleRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateSellerPayoutRequest
 */
export interface UpdateSellerPayoutRequest {
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof UpdateSellerPayoutRequest
     */
    'amount': DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface UpdateShiftRequest
 */
export interface UpdateShiftRequest {
    /**
     * Name of the event
     * @type {string}
     * @memberof UpdateShiftRequest
     */
    'name'?: string;
    /**
     * Roles that (can) have this shift
     * @type {Array<string>}
     * @memberof UpdateShiftRequest
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'canGoIntoDebt'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'ofAge'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'extensiveDataProcessing'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateVatGroupRequest
 */
export interface UpdateVatGroupRequest {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof UpdateVatGroupRequest
     */
    'name': string;
    /**
     * Whether this group should be hidden in the financial overviews when its value is zero
     * @type {boolean}
     * @memberof UpdateVatGroupRequest
     */
    'deleted': boolean;
    /**
     * Whether this group should be hidden from transactions
     * @type {boolean}
     * @memberof UpdateVatGroupRequest
     */
    'hidden': boolean;
}
/**
 * 
 * @export
 * @interface UserFineGroupResponse
 */
export interface UserFineGroupResponse {
    /**
     * Fines that have been handed out
     * @type {Array<FineResponse>}
     * @memberof UserFineGroupResponse
     */
    'fines': Array<FineResponse>;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof UserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof UserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof UserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof UserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof UserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof UserResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof UserResponse
     */
    'nickname'?: string;
    /**
     * Whether the user activated
     * @type {boolean}
     * @memberof UserResponse
     */
    'active': boolean;
    /**
     * Whether the user is deleted
     * @type {boolean}
     * @memberof UserResponse
     */
    'deleted': boolean;
    /**
     * The type of user
     * @type {string}
     * @memberof UserResponse
     */
    'type': string;
    /**
     * If local user, the e-mail of the user
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * Whether this user has accepted the TOS
     * @type {string}
     * @memberof UserResponse
     */
    'acceptedToS'?: string;
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof UserResponse
     */
    'extensiveDataProcessing'?: boolean;
    /**
     * Whether someone is old enough to drink beer
     * @type {boolean}
     * @memberof UserResponse
     */
    'ofAge'?: boolean;
    /**
     * Whether this user can get a negative balance
     * @type {boolean}
     * @memberof UserResponse
     */
    'canGoIntoDebt': boolean;
}
/**
 * 
 * @export
 * @interface UserToFineResponse
 */
export interface UserToFineResponse {
    /**
     * User ID
     * @type {number}
     * @memberof UserToFineResponse
     */
    'id': number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof UserToFineResponse
     */
    'fineAmount': DineroObjectResponse;
    /**
     * Balances at the given reference dates
     * @type {Array<BalanceResponse>}
     * @memberof UserToFineResponse
     */
    'balances': Array<BalanceResponse>;
}
/**
 * 
 * @export
 * @interface UserTypeTotalBalanceResponse
 */
export interface UserTypeTotalBalanceResponse {
    /**
     * The user type
     * @type {string}
     * @memberof UserTypeTotalBalanceResponse
     */
    'userType': string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof UserTypeTotalBalanceResponse
     */
    'totalPositive': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof UserTypeTotalBalanceResponse
     */
    'totalNegative': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface VatDeclarationResponse
 */
export interface VatDeclarationResponse {
    /**
     * Calendar year of this result table
     * @type {number}
     * @memberof VatDeclarationResponse
     */
    'calendarYear': number;
    /**
     * The used VAT declaration period the rows below are based upon
     * @type {string}
     * @memberof VatDeclarationResponse
     */
    'period': string;
    /**
     * The rows of the result table
     * @type {Array<VatDeclarationRow>}
     * @memberof VatDeclarationResponse
     */
    'rows': Array<VatDeclarationRow>;
}
/**
 * 
 * @export
 * @interface VatDeclarationRow
 */
export interface VatDeclarationRow {
    /**
     * ID of the VAT group
     * @type {number}
     * @memberof VatDeclarationRow
     */
    'id': number;
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatDeclarationRow
     */
    'name': string;
    /**
     * Percentage of VAT in this group
     * @type {number}
     * @memberof VatDeclarationRow
     */
    'percentage': number;
    /**
     * Amount of VAT to be paid to the tax administration per period
     * @type {Array<DineroObject>}
     * @memberof VatDeclarationRow
     */
    'values': Array<DineroObject>;
}
/**
 * 
 * @export
 * @interface VatGroupRequest
 */
export interface VatGroupRequest {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroupRequest
     */
    'name': string;
    /**
     * Whether this group should be hidden in the financial overviews when its value is zero
     * @type {boolean}
     * @memberof VatGroupRequest
     */
    'deleted': boolean;
    /**
     * Whether this group should be hidden from transactions
     * @type {boolean}
     * @memberof VatGroupRequest
     */
    'hidden': boolean;
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroupRequest
     */
    'percentage': number;
}
/**
 * 
 * @export
 * @interface VatGroupResponse
 */
export interface VatGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof VatGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof VatGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof VatGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof VatGroupResponse
     */
    'version'?: number;
    /**
     * Percentage of VAT
     * @type {number}
     * @memberof VatGroupResponse
     */
    'percentage': number;
    /**
     * Whether VAT should be hidden
     * @type {boolean}
     * @memberof VatGroupResponse
     */
    'hidden': boolean;
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroupResponse
     */
    'name': string;
    /**
     * Whether this group is soft-deleted
     * @type {boolean}
     * @memberof VatGroupResponse
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface VoucherGroupRequest
 */
export interface VoucherGroupRequest {
    /**
     * Name of the group
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'name': string;
    /**
     * Date from which the included cards are active
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'activeStartDate': string;
    /**
     * Date from which cards are no longer active
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'activeEndDate': string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof VoucherGroupRequest
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the voucher group
     * @type {number}
     * @memberof VoucherGroupRequest
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface VoucherGroupResponse
 */
export interface VoucherGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'version'?: number;
    /**
     * Name of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'name': string;
    /**
     * Start date of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'activeStartDate'?: string;
    /**
     * End date of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'activeEndDate': string;
    /**
     * Users in the voucher group
     * @type {Array<UserResponse>}
     * @memberof VoucherGroupResponse
     */
    'users': Array<UserResponse>;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof VoucherGroupResponse
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the voucher group
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'amount': number;
}
/**
 * The total request and all its fields are optional for backwards compatibility\'s sake. If this request object is extended, it is probably best to make everything required and remove the backwards compatibility, as the frontend will (and should) already use this new object. See https://github.com/GEWIS/sudosos-backend/pull/344
 * @export
 * @interface WaiveFinesRequest
 */
export interface WaiveFinesRequest {
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof WaiveFinesRequest
     */
    'amount'?: DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface WriteOffRequest
 */
export interface WriteOffRequest {
    /**
     * The user who is the receiver of the write-off
     * @type {number}
     * @memberof WriteOffRequest
     */
    'toId': number;
}
/**
 * 
 * @export
 * @interface WriteOffResponse
 */
export interface WriteOffResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof WriteOffResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof WriteOffResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof WriteOffResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof WriteOffResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof WriteOffResponse
     */
    'to': BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof WriteOffResponse
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {TransferResponse}
     * @memberof WriteOffResponse
     */
    'transfer': TransferResponse;
}

/**
 * AuthenticateApi - axios parameter creator
 * @export
 */
export const AuthenticateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a JWT token for the given POS
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePointOfSale: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authenticatePointOfSale', 'id', id)
            const localVarPath = `/authentication/pointofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel QR code authentication
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelQRCode: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('cancelQRCode', 'sessionId', sessionId)
            const localVarPath = `/authentication/qr/{sessionId}/cancel`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm QR code authentication from mobile app
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmQRCode: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('confirmQRCode', 'sessionId', sessionId)
            const localVarPath = `/authentication/qr/{sessionId}/confirm`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EAN login and hand out token
         * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication: async (authenticationEanRequest: AuthenticationEanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationEanRequest' is not null or undefined
            assertParamExists('eanAuthentication', 'authenticationEanRequest', authenticationEanRequest)
            const localVarPath = `/authentication/ean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationEanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a QR code for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateQRCode: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authentication/qr/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the GEWISWeb public token used by SudoSOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGEWISWebPublic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authentication/gewisweb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of a QR authentication session
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQRStatus: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getQRStatus', 'sessionId', sessionId)
            const localVarPath = `/authentication/qr/{sessionId}/status`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication: async (authenticationLDAPRequest: AuthenticationLDAPRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationLDAPRequest' is not null or undefined
            assertParamExists('gewisLDAPAuthentication', 'authenticationLDAPRequest', authenticationLDAPRequest)
            const localVarPath = `/authentication/GEWIS/LDAP`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationLDAPRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication: async (gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gEWISAuthenticationPinRequest' is not null or undefined
            assertParamExists('gewisPinAuthentication', 'gEWISAuthenticationPinRequest', gEWISAuthenticationPinRequest)
            const localVarPath = `/authentication/GEWIS/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gEWISAuthenticationPinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication: async (gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gewiswebAuthenticationRequest' is not null or undefined
            assertParamExists('gewisWebAuthentication', 'gewiswebAuthenticationRequest', gewiswebAuthenticationRequest)
            const localVarPath = `/authentication/gewisweb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gewiswebAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Key login and hand out token.
         * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication: async (authenticationKeyRequest: AuthenticationKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationKeyRequest' is not null or undefined
            assertParamExists('keyAuthentication', 'authenticationKeyRequest', authenticationKeyRequest)
            const localVarPath = `/authentication/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAuthentication: async (authenticationLDAPRequest: AuthenticationLDAPRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationLDAPRequest' is not null or undefined
            assertParamExists('ldapAuthentication', 'authenticationLDAPRequest', authenticationLDAPRequest)
            const localVarPath = `/authentication/LDAP`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationLDAPRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Local login and hand out token
         * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication: async (authenticationLocalRequest: AuthenticationLocalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationLocalRequest' is not null or undefined
            assertParamExists('localAuthentication', 'authenticationLocalRequest', authenticationLocalRequest)
            const localVarPath = `/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationLocalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mock login and hand out token.
         * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication: async (authenticationMockRequest: AuthenticationMockRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationMockRequest' is not null or undefined
            assertParamExists('mockAuthentication', 'authenticationMockRequest', authenticationMockRequest)
            const localVarPath = `/authentication/mock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationMockRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary NFC login and hand out token
         * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication: async (authenticationNfcRequest: AuthenticationNfcRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationNfcRequest' is not null or undefined
            assertParamExists('nfcAuthentication', 'authenticationNfcRequest', authenticationNfcRequest)
            const localVarPath = `/authentication/nfc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationNfcRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PIN login and hand out token
         * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication: async (authenticationPinRequest: AuthenticationPinRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationPinRequest' is not null or undefined
            assertParamExists('pinAuthentication', 'authenticationPinRequest', authenticationPinRequest)
            const localVarPath = `/authentication/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationPinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authentication/refreshToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a reset token for the local authentication
         * @param {ResetLocalRequest} resetLocalRequest The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal: async (resetLocalRequest: ResetLocalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetLocalRequest' is not null or undefined
            assertParamExists('resetLocal', 'resetLocalRequest', resetLocalRequest)
            const localVarPath = `/authentication/local/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetLocalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken: async (authenticationResetTokenRequest: AuthenticationResetTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationResetTokenRequest' is not null or undefined
            assertParamExists('resetLocalWithToken', 'authenticationResetTokenRequest', authenticationResetTokenRequest)
            const localVarPath = `/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationResetTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticateApi - functional programming interface
 * @export
 */
export const AuthenticateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a JWT token for the given POS
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticatePointOfSale(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticatePointOfSale(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.authenticatePointOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel QR code authentication
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelQRCode(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelQRCode(sessionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.cancelQRCode']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Confirm QR code authentication from mobile app
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmQRCode(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmQRCode(sessionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.confirmQRCode']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary EAN login and hand out token
         * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eanAuthentication(authenticationEanRequest: AuthenticationEanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eanAuthentication(authenticationEanRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.eanAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Generate a QR code for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateQRCode(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QRCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateQRCode(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.generateQRCode']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the GEWISWeb public token used by SudoSOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGEWISWebPublic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGEWISWebPublic(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.getGEWISWebPublic']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the status of a QR authentication session
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQRStatus(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QRStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQRStatus(sessionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.getQRStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gewisLDAPAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gewisLDAPAuthentication(authenticationLDAPRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.gewisLDAPAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gewisPinAuthentication(gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gewisPinAuthentication(gEWISAuthenticationPinRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.gewisPinAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gewisWebAuthentication(gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gewisWebAuthentication(gewiswebAuthenticationRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.gewisWebAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Key login and hand out token.
         * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyAuthentication(authenticationKeyRequest: AuthenticationKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyAuthentication(authenticationKeyRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.keyAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ldapAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ldapAuthentication(authenticationLDAPRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.ldapAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Local login and hand out token
         * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localAuthentication(authenticationLocalRequest: AuthenticationLocalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localAuthentication(authenticationLocalRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.localAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Mock login and hand out token.
         * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mockAuthentication(authenticationMockRequest: AuthenticationMockRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mockAuthentication(authenticationMockRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.mockAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary NFC login and hand out token
         * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nfcAuthentication(authenticationNfcRequest: AuthenticationNfcRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nfcAuthentication(authenticationNfcRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.nfcAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary PIN login and hand out token
         * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinAuthentication(authenticationPinRequest: AuthenticationPinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinAuthentication(authenticationPinRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.pinAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.refreshToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a reset token for the local authentication
         * @param {ResetLocalRequest} resetLocalRequest The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetLocal(resetLocalRequest: ResetLocalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetLocal(resetLocalRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.resetLocal']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetLocalWithToken(authenticationResetTokenRequest: AuthenticationResetTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetLocalWithToken(authenticationResetTokenRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.resetLocalWithToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthenticateApi - factory interface
 * @export
 */
export const AuthenticateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticateApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a JWT token for the given POS
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePointOfSale(id: number, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.authenticatePointOfSale(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel QR code authentication
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelQRCode(sessionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelQRCode(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm QR code authentication from mobile app
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmQRCode(sessionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.confirmQRCode(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary EAN login and hand out token
         * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication(authenticationEanRequest: AuthenticationEanRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.eanAuthentication(authenticationEanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a QR code for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateQRCode(options?: any): AxiosPromise<QRCodeResponse> {
            return localVarFp.generateQRCode(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the GEWISWeb public token used by SudoSOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGEWISWebPublic(options?: any): AxiosPromise<string> {
            return localVarFp.getGEWISWebPublic(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status of a QR authentication session
         * @param {string} sessionId The session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQRStatus(sessionId: string, options?: any): AxiosPromise<QRStatusResponse> {
            return localVarFp.getQRStatus(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.gewisLDAPAuthentication(authenticationLDAPRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication(gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.gewisPinAuthentication(gEWISAuthenticationPinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication(gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.gewisWebAuthentication(gewiswebAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Key login and hand out token.
         * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication(authenticationKeyRequest: AuthenticationKeyRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.keyAuthentication(authenticationKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.ldapAuthentication(authenticationLDAPRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Local login and hand out token
         * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication(authenticationLocalRequest: AuthenticationLocalRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.localAuthentication(authenticationLocalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mock login and hand out token.
         * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication(authenticationMockRequest: AuthenticationMockRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.mockAuthentication(authenticationMockRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary NFC login and hand out token
         * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication(authenticationNfcRequest: AuthenticationNfcRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.nfcAuthentication(authenticationNfcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PIN login and hand out token
         * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication(authenticationPinRequest: AuthenticationPinRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.pinAuthentication(authenticationPinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a reset token for the local authentication
         * @param {ResetLocalRequest} resetLocalRequest The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal(resetLocalRequest: ResetLocalRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resetLocal(resetLocalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken(authenticationResetTokenRequest: AuthenticationResetTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resetLocalWithToken(authenticationResetTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticateApi - object-oriented interface
 * @export
 * @class AuthenticateApi
 * @extends {BaseAPI}
 */
export class AuthenticateApi extends BaseAPI {
    /**
     * 
     * @summary Get a JWT token for the given POS
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public authenticatePointOfSale(id: number, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).authenticatePointOfSale(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel QR code authentication
     * @param {string} sessionId The session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public cancelQRCode(sessionId: string, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).cancelQRCode(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm QR code authentication from mobile app
     * @param {string} sessionId The session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public confirmQRCode(sessionId: string, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).confirmQRCode(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary EAN login and hand out token
     * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public eanAuthentication(authenticationEanRequest: AuthenticationEanRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).eanAuthentication(authenticationEanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a QR code for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public generateQRCode(options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).generateQRCode(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the GEWISWeb public token used by SudoSOS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public getGEWISWebPublic(options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).getGEWISWebPublic(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status of a QR authentication session
     * @param {string} sessionId The session ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public getQRStatus(sessionId: string, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).getQRStatus(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public gewisLDAPAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).gewisLDAPAuthentication(authenticationLDAPRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public gewisPinAuthentication(gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).gewisPinAuthentication(gEWISAuthenticationPinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public gewisWebAuthentication(gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).gewisWebAuthentication(gewiswebAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Key login and hand out token.
     * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public keyAuthentication(authenticationKeyRequest: AuthenticationKeyRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).keyAuthentication(authenticationKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public ldapAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).ldapAuthentication(authenticationLDAPRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Local login and hand out token
     * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public localAuthentication(authenticationLocalRequest: AuthenticationLocalRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).localAuthentication(authenticationLocalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mock login and hand out token.
     * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public mockAuthentication(authenticationMockRequest: AuthenticationMockRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).mockAuthentication(authenticationMockRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary NFC login and hand out token
     * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public nfcAuthentication(authenticationNfcRequest: AuthenticationNfcRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).nfcAuthentication(authenticationNfcRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PIN login and hand out token
     * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public pinAuthentication(authenticationPinRequest: AuthenticationPinRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).pinAuthentication(authenticationPinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public refreshToken(options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a reset token for the local authentication
     * @param {ResetLocalRequest} resetLocalRequest The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public resetLocal(resetLocalRequest: ResetLocalRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).resetLocal(resetLocalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public resetLocalWithToken(authenticationResetTokenRequest: AuthenticationResetTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).resetLocalWithToken(authenticationResetTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BalanceApi - axios parameter creator
 * @export
 */
export const BalanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the calculated total balances in SudoSOS
         * @param {string} date The date for which to calculate the balance.
         * @param {boolean} [allowDeleted] Whether to include deleted users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateTotalBalances: async (date: string, allowDeleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('calculateTotalBalances', 'date', date)
            const localVarPath = `/balances/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (allowDeleted !== undefined) {
                localVarQueryParameter['allowDeleted'] = allowDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get balance of all users
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
         * @param {string} [orderBy] Column to order balance by - eg: id,amount
         * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
         * @param {boolean} [allowDeleted] Whether to include deleted users
         * @param {boolean} [inactive] Whether to only return inactive users
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance: async (date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userTypes?: GetAllBalanceUserTypesEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, allowDeleted?: boolean, inactive?: boolean, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/balances/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (minBalance !== undefined) {
                localVarQueryParameter['minBalance'] = minBalance;
            }

            if (maxBalance !== undefined) {
                localVarQueryParameter['maxBalance'] = maxBalance;
            }

            if (hasFine !== undefined) {
                localVarQueryParameter['hasFine'] = hasFine;
            }

            if (minFine !== undefined) {
                localVarQueryParameter['minFine'] = minFine;
            }

            if (maxFine !== undefined) {
                localVarQueryParameter['maxFine'] = maxFine;
            }

            if (userTypes) {
                localVarQueryParameter['userTypes'] = userTypes;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (allowDeleted !== undefined) {
                localVarQueryParameter['allowDeleted'] = allowDeleted;
            }

            if (inactive !== undefined) {
                localVarQueryParameter['inactive'] = inactive;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBalanceId', 'id', id)
            const localVarPath = `/balances/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceApi - functional programming interface
 * @export
 */
export const BalanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalanceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the calculated total balances in SudoSOS
         * @param {string} date The date for which to calculate the balance.
         * @param {boolean} [allowDeleted] Whether to include deleted users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateTotalBalances(date: string, allowDeleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TotalBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateTotalBalances(date, allowDeleted, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BalanceApi.calculateTotalBalances']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get balance of all users
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
         * @param {string} [orderBy] Column to order balance by - eg: id,amount
         * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
         * @param {boolean} [allowDeleted] Whether to include deleted users
         * @param {boolean} [inactive] Whether to only return inactive users
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userTypes?: GetAllBalanceUserTypesEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, allowDeleted?: boolean, inactive?: boolean, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userTypes, orderBy, orderDirection, allowDeleted, inactive, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BalanceApi.getAllBalance']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceId(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BalanceApi.getBalanceId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalances(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalances(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BalanceApi.getBalances']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BalanceApi - factory interface
 * @export
 */
export const BalanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalanceApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the calculated total balances in SudoSOS
         * @param {string} date The date for which to calculate the balance.
         * @param {boolean} [allowDeleted] Whether to include deleted users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateTotalBalances(date: string, allowDeleted?: boolean, options?: any): AxiosPromise<TotalBalanceResponse> {
            return localVarFp.calculateTotalBalances(date, allowDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get balance of all users
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
         * @param {string} [orderBy] Column to order balance by - eg: id,amount
         * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
         * @param {boolean} [allowDeleted] Whether to include deleted users
         * @param {boolean} [inactive] Whether to only return inactive users
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userTypes?: GetAllBalanceUserTypesEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, allowDeleted?: boolean, inactive?: boolean, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBalanceResponse> {
            return localVarFp.getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userTypes, orderBy, orderDirection, allowDeleted, inactive, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId(id: number, options?: any): AxiosPromise<BalanceResponse> {
            return localVarFp.getBalanceId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances(options?: any): AxiosPromise<BalanceResponse> {
            return localVarFp.getBalances(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalanceApi - object-oriented interface
 * @export
 * @class BalanceApi
 * @extends {BaseAPI}
 */
export class BalanceApi extends BaseAPI {
    /**
     * 
     * @summary Get the calculated total balances in SudoSOS
     * @param {string} date The date for which to calculate the balance.
     * @param {boolean} [allowDeleted] Whether to include deleted users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public calculateTotalBalances(date: string, allowDeleted?: boolean, options?: RawAxiosRequestConfig) {
        return BalanceApiFp(this.configuration).calculateTotalBalances(date, allowDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get balance of all users
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {boolean} [hasFine] Only users with(out) fines
     * @param {number} [minFine] Minimum fine
     * @param {number} [maxFine] Maximum fine
     * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
     * @param {string} [orderBy] Column to order balance by - eg: id,amount
     * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
     * @param {boolean} [allowDeleted] Whether to include deleted users
     * @param {boolean} [inactive] Whether to only return inactive users
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userTypes?: GetAllBalanceUserTypesEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, allowDeleted?: boolean, inactive?: boolean, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return BalanceApiFp(this.configuration).getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userTypes, orderBy, orderDirection, allowDeleted, inactive, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public getBalanceId(id: number, options?: RawAxiosRequestConfig) {
        return BalanceApiFp(this.configuration).getBalanceId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public getBalances(options?: RawAxiosRequestConfig) {
        return BalanceApiFp(this.configuration).getBalances(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllBalanceUserTypesEnum = {
} as const;
export type GetAllBalanceUserTypesEnum = typeof GetAllBalanceUserTypesEnum[keyof typeof GetAllBalanceUserTypesEnum];
/**
 * @export
 */
export const GetAllBalanceOrderDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetAllBalanceOrderDirectionEnum = typeof GetAllBalanceOrderDirectionEnum[keyof typeof GetAllBalanceOrderDirectionEnum];


/**
 * BannersApi - axios parameter creator
 * @export
 */
export const BannersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Saves a banner to the database
         * @param {BannerRequest} bannerRequest The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (bannerRequest: BannerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bannerRequest' is not null or undefined
            assertParamExists('create', 'bannerRequest', bannerRequest)
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bannerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banners/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/open/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBanner', 'id', id)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} bannerRequest The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: number, bannerRequest: BannerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'bannerRequest' is not null or undefined
            assertParamExists('update', 'bannerRequest', bannerRequest)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bannerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateImage', 'id', id)
            const localVarPath = `/banners/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BannersApi - functional programming interface
 * @export
 */
export const BannersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BannersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi._delete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Saves a banner to the database
         * @param {BannerRequest} bannerRequest The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(bannerRequest: BannerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(bannerRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.create']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActive(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActive(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.getActive']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBanners(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.getAllBanners']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOpenBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOpenBanners(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.getAllOpenBanners']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBanner(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBanner(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.getBanner']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} bannerRequest The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: number, bannerRequest: BannerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, bannerRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.update']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImage(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImage(id, file, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.updateImage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BannersApi - factory interface
 * @export
 */
export const BannersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BannersApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Saves a banner to the database
         * @param {BannerRequest} bannerRequest The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(bannerRequest: BannerRequest, options?: any): AxiosPromise<BannerResponse> {
            return localVarFp.create(bannerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse> {
            return localVarFp.getActive(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse> {
            return localVarFp.getAllBanners(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse> {
            return localVarFp.getAllOpenBanners(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner(id: number, options?: any): AxiosPromise<BannerResponse> {
            return localVarFp.getBanner(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} bannerRequest The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: number, bannerRequest: BannerRequest, options?: any): AxiosPromise<BannerResponse> {
            return localVarFp.update(id, bannerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id: number, file?: File, options?: any): AxiosPromise<void> {
            return localVarFp.updateImage(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BannersApi - object-oriented interface
 * @export
 * @class BannersApi
 * @extends {BaseAPI}
 */
export class BannersApi extends BaseAPI {
    /**
     * 
     * @summary Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public _delete(id: number, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Saves a banner to the database
     * @param {BannerRequest} bannerRequest The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public create(bannerRequest: BannerRequest, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).create(bannerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getActive(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).getActive(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getAllBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).getAllBanners(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getAllOpenBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).getAllOpenBanners(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getBanner(id: number, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).getBanner(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} bannerRequest The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public update(id: number, bannerRequest: BannerRequest, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).update(id, bannerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public updateImage(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).updateImage(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new container.
         * @param {CreateContainerRequest} createContainerRequest    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer: async (createContainerRequest: CreateContainerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createContainerRequest' is not null or undefined
            assertParamExists('createContainer', 'createContainerRequest', createContainerRequest)
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContainerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary (Soft) delete the given container. Cannot be undone.
         * @param {number} id The id of the container which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteContainer', 'id', id)
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductsContainer', 'id', id)
            const localVarPath = `/containers/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/containers/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleContainer', 'id', id)
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: async (id: number, updateContainerRequest: UpdateContainerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateContainer', 'id', id)
            // verify required parameter 'updateContainerRequest' is not null or undefined
            assertParamExists('updateContainer', 'updateContainerRequest', updateContainerRequest)
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContainerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new container.
         * @param {CreateContainerRequest} createContainerRequest    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainer(createContainerRequest: CreateContainerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainer(createContainerRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.createContainer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary (Soft) delete the given container. Cannot be undone.
         * @param {number} id The id of the container which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContainer(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContainer(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.deleteContainer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllContainers(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.getAllContainers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsContainer(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsContainer(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.getProductsContainer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicContainers(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.getPublicContainers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleContainer(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleContainer(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.getSingleContainer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainer(id: number, updateContainerRequest: UpdateContainerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainer(id, updateContainerRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.updateContainer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new container.
         * @param {CreateContainerRequest} createContainerRequest    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(createContainerRequest: CreateContainerRequest, options?: any): AxiosPromise<ContainerWithProductsResponse> {
            return localVarFp.createContainer(createContainerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary (Soft) delete the given container. Cannot be undone.
         * @param {number} id The id of the container which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getAllContainers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer(id: number, options?: any): AxiosPromise<Array<ProductResponse>> {
            return localVarFp.getProductsContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getPublicContainers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer(id: number, options?: any): AxiosPromise<ContainerWithProductsResponse> {
            return localVarFp.getSingleContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(id: number, updateContainerRequest: UpdateContainerRequest, options?: any): AxiosPromise<ContainerWithProductsResponse> {
            return localVarFp.updateContainer(id, updateContainerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new container.
     * @param {CreateContainerRequest} createContainerRequest    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public createContainer(createContainerRequest: CreateContainerRequest, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).createContainer(createContainerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary (Soft) delete the given container. Cannot be undone.
     * @param {number} id The id of the container which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public deleteContainer(id: number, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).deleteContainer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getAllContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getAllContainers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getProductsContainer(id: number, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getProductsContainer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getPublicContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getPublicContainers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getSingleContainer(id: number, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getSingleContainer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainer(id: number, updateContainerRequest: UpdateContainerRequest, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).updateContainer(id, updateContainerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DebtorsApi - axios parameter creator
 * @export
 */
export const DebtorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
         * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
         * @param {Array<string>} [userTypes] List of all user types fines should be calculated for (MEMBER, ORGAN, VOUCHER, LOCAL_USER, LOCAL_ADMIN, INVOICE, AUTOMATIC_INVOICE).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateFines: async (referenceDates: Array<string>, userTypes?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referenceDates' is not null or undefined
            assertParamExists('calculateFines', 'referenceDates', referenceDates)
            const localVarPath = `/fines/eligible`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userTypes) {
                localVarQueryParameter['userTypes'] = userTypes;
            }

            if (referenceDates) {
                localVarQueryParameter['referenceDates'] = referenceDates;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFine: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFine', 'id', id)
            const localVarPath = `/fines/single/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a report of all fines
         * @param {string} [fromDate] The start date of the report, inclusive
         * @param {string} [toDate] The end date of the report, exclusive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineReport: async (fromDate?: string, toDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fines/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a report of all fines in pdf format
         * @param {string} fromDate The start date of the report, inclusive
         * @param {string} toDate The end date of the report, exclusive
         * @param {GetFineReportPdfFileTypeEnum} fileType The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineReportPdf: async (fromDate: string, toDate: string, fileType: GetFineReportPdfFileTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('getFineReportPdf', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('getFineReportPdf', 'toDate', toDate)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('getFineReportPdf', 'fileType', fileType)
            const localVarPath = `/fines/report/pdf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoutFines: async (handoutFinesRequest: HandoutFinesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'handoutFinesRequest' is not null or undefined
            assertParamExists('handoutFines', 'handoutFinesRequest', handoutFinesRequest)
            const localVarPath = `/fines/handout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(handoutFinesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyAboutFutureFines: async (handoutFinesRequest: HandoutFinesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'handoutFinesRequest' is not null or undefined
            assertParamExists('notifyAboutFutureFines', 'handoutFinesRequest', handoutFinesRequest)
            const localVarPath = `/fines/notify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(handoutFinesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnAllFineHandoutEvents: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnSingleFineHandoutEvent: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('returnSingleFineHandoutEvent', 'id', id)
            const localVarPath = `/fines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DebtorsApi - functional programming interface
 * @export
 */
export const DebtorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DebtorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
         * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
         * @param {Array<string>} [userTypes] List of all user types fines should be calculated for (MEMBER, ORGAN, VOUCHER, LOCAL_USER, LOCAL_ADMIN, INVOICE, AUTOMATIC_INVOICE).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateFines(referenceDates: Array<string>, userTypes?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserToFineResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateFines(referenceDates, userTypes, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.calculateFines']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFine(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFine(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.deleteFine']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a report of all fines
         * @param {string} [fromDate] The start date of the report, inclusive
         * @param {string} [toDate] The end date of the report, exclusive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFineReport(fromDate?: string, toDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFineReport(fromDate, toDate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.getFineReport']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a report of all fines in pdf format
         * @param {string} fromDate The start date of the report, inclusive
         * @param {string} toDate The end date of the report, exclusive
         * @param {GetFineReportPdfFileTypeEnum} fileType The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFineReportPdf(fromDate: string, toDate: string, fileType: GetFineReportPdfFileTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFineReportPdf(fromDate, toDate, fileType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.getFineReportPdf']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handoutFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineHandoutEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handoutFines(handoutFinesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.handoutFines']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyAboutFutureFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyAboutFutureFines(handoutFinesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.notifyAboutFutureFines']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnAllFineHandoutEvents(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFineHandoutEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnAllFineHandoutEvents(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.returnAllFineHandoutEvents']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnSingleFineHandoutEvent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineHandoutEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnSingleFineHandoutEvent(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.returnSingleFineHandoutEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DebtorsApi - factory interface
 * @export
 */
export const DebtorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DebtorsApiFp(configuration)
    return {
        /**
         * 
         * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
         * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
         * @param {Array<string>} [userTypes] List of all user types fines should be calculated for (MEMBER, ORGAN, VOUCHER, LOCAL_USER, LOCAL_ADMIN, INVOICE, AUTOMATIC_INVOICE).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateFines(referenceDates: Array<string>, userTypes?: Array<string>, options?: any): AxiosPromise<Array<UserToFineResponse>> {
            return localVarFp.calculateFines(referenceDates, userTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFine(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFine(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a report of all fines
         * @param {string} [fromDate] The start date of the report, inclusive
         * @param {string} [toDate] The end date of the report, exclusive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineReport(fromDate?: string, toDate?: string, options?: any): AxiosPromise<FineReportResponse> {
            return localVarFp.getFineReport(fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a report of all fines in pdf format
         * @param {string} fromDate The start date of the report, inclusive
         * @param {string} toDate The end date of the report, exclusive
         * @param {GetFineReportPdfFileTypeEnum} fileType The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineReportPdf(fromDate: string, toDate: string, fileType: GetFineReportPdfFileTypeEnum, options?: any): AxiosPromise<string> {
            return localVarFp.getFineReportPdf(fromDate, toDate, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoutFines(handoutFinesRequest: HandoutFinesRequest, options?: any): AxiosPromise<FineHandoutEventResponse> {
            return localVarFp.handoutFines(handoutFinesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyAboutFutureFines(handoutFinesRequest: HandoutFinesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.notifyAboutFutureFines(handoutFinesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnAllFineHandoutEvents(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedFineHandoutEventResponse> {
            return localVarFp.returnAllFineHandoutEvents(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnSingleFineHandoutEvent(id: number, options?: any): AxiosPromise<FineHandoutEventResponse> {
            return localVarFp.returnSingleFineHandoutEvent(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DebtorsApi - object-oriented interface
 * @export
 * @class DebtorsApi
 * @extends {BaseAPI}
 */
export class DebtorsApi extends BaseAPI {
    /**
     * 
     * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
     * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
     * @param {Array<string>} [userTypes] List of all user types fines should be calculated for (MEMBER, ORGAN, VOUCHER, LOCAL_USER, LOCAL_ADMIN, INVOICE, AUTOMATIC_INVOICE).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public calculateFines(referenceDates: Array<string>, userTypes?: Array<string>, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).calculateFines(referenceDates, userTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a fine
     * @param {number} id The id of the fine which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public deleteFine(id: number, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).deleteFine(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a report of all fines
     * @param {string} [fromDate] The start date of the report, inclusive
     * @param {string} [toDate] The end date of the report, exclusive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public getFineReport(fromDate?: string, toDate?: string, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).getFineReport(fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a report of all fines in pdf format
     * @param {string} fromDate The start date of the report, inclusive
     * @param {string} toDate The end date of the report, exclusive
     * @param {GetFineReportPdfFileTypeEnum} fileType The file type of the report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public getFineReportPdf(fromDate: string, toDate: string, fileType: GetFineReportPdfFileTypeEnum, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).getFineReportPdf(fromDate, toDate, fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
     * @param {HandoutFinesRequest} handoutFinesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public handoutFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).handoutFines(handoutFinesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send an email to all given users about their possible future fine.
     * @param {HandoutFinesRequest} handoutFinesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public notifyAboutFutureFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).notifyAboutFutureFines(handoutFinesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all fine handout events
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public returnAllFineHandoutEvents(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).returnAllFineHandoutEvents(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all fine handout events
     * @param {number} id The id of the fine handout event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public returnSingleFineHandoutEvent(id: number, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).returnSingleFineHandoutEvent(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetFineReportPdfFileTypeEnum = {
    Pdf: 'PDF',
    Tex: 'TEX'
} as const;
export type GetFineReportPdfFileTypeEnum = typeof GetFineReportPdfFileTypeEnum[keyof typeof GetFineReportPdfFileTypeEnum];


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignEventShift: async (eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('assignEventShift', 'eventId', eventId)
            // verify required parameter 'shiftId' is not null or undefined
            assertParamExists('assignEventShift', 'shiftId', shiftId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignEventShift', 'userId', userId)
            // verify required parameter 'eventAnswerAssignmentRequest' is not null or undefined
            assertParamExists('assignEventShift', 'eventAnswerAssignmentRequest', eventAnswerAssignmentRequest)
            const localVarPath = `/events/{eventId}/shift/{shiftId}/user/{userId}/assign`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"shiftId"}}`, encodeURIComponent(String(shiftId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventAnswerAssignmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an event with its corresponding answers objects
         * @param {CreateEventRequest} createEventRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEvent: async (createEventRequest: CreateEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventRequest' is not null or undefined
            assertParamExists('createEvent', 'createEventRequest', createEventRequest)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an event shift
         * @param {CreateShiftRequest} createShiftRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEventShift: async (createShiftRequest: CreateShiftRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createShiftRequest' is not null or undefined
            assertParamExists('createEventShift', 'createShiftRequest', createShiftRequest)
            const localVarPath = `/eventshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createShiftRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEvent: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEventShift: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEventShift', 'id', id)
            const localVarPath = `/eventshifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllEventShifts: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eventshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllEvents: async (name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = beforeDate;
            }

            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = afterDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event shift
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getEventShiftCount: async (id: number, eventType?: string, afterDate?: string, beforeDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEventShiftCount', 'id', id)
            const localVarPath = `/eventshifts/{id}/counts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = afterDate;
            }

            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = beforeDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSingleEvent: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEvent: async (id: number, updateEventRequest: UpdateEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEvent', 'id', id)
            // verify required parameter 'updateEventRequest' is not null or undefined
            assertParamExists('updateEvent', 'updateEventRequest', updateEventRequest)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} updateShiftRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEventShift: async (id: number, updateShiftRequest: UpdateShiftRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEventShift', 'id', id)
            // verify required parameter 'updateShiftRequest' is not null or undefined
            assertParamExists('updateEventShift', 'updateShiftRequest', updateShiftRequest)
            const localVarPath = `/eventshifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateShiftRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEventShiftAvailability: async (eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'eventId', eventId)
            // verify required parameter 'shiftId' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'shiftId', shiftId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'userId', userId)
            // verify required parameter 'eventAnswerAvailabilityRequest' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'eventAnswerAvailabilityRequest', eventAnswerAvailabilityRequest)
            const localVarPath = `/events/{eventId}/shift/{shiftId}/user/{userId}/availability`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"shiftId"}}`, encodeURIComponent(String(shiftId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventAnswerAvailabilityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async assignEventShift(eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEventAnswerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.assignEventShift']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create an event with its corresponding answers objects
         * @param {CreateEventRequest} createEventRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createEvent(createEventRequest: CreateEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(createEventRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.createEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create an event shift
         * @param {CreateShiftRequest} createShiftRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createEventShift(createShiftRequest: CreateShiftRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventShiftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventShift(createShiftRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.createEventShift']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteEvent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.deleteEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteEventShift(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventShift(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.deleteEventShift']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getAllEventShifts(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEventShiftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEventShifts(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getAllEventShifts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getAllEvents']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event shift
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getEventShiftCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaginatedEventShiftResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventShiftCount(id, eventType, afterDate, beforeDate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getEventShiftCount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getSingleEvent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleEvent(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getSingleEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateEvent(id: number, updateEventRequest: UpdateEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(id, updateEventRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.updateEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} updateShiftRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateEventShift(id: number, updateShiftRequest: UpdateShiftRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventShiftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventShift(id, updateShiftRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.updateEventShift']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEventAnswerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.updateEventShiftAvailability']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignEventShift(eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options?: any): AxiosPromise<BaseEventAnswerResponse> {
            return localVarFp.assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an event with its corresponding answers objects
         * @param {CreateEventRequest} createEventRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEvent(createEventRequest: CreateEventRequest, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.createEvent(createEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an event shift
         * @param {CreateShiftRequest} createShiftRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEventShift(createShiftRequest: CreateShiftRequest, options?: any): AxiosPromise<EventShiftResponse> {
            return localVarFp.createEventShift(createShiftRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEvent(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEventShift(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventShift(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllEventShifts(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedEventShiftResponse> {
            return localVarFp.getAllEventShifts(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseEventResponse> {
            return localVarFp.getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event shift
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getEventShiftCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: any): AxiosPromise<Array<PaginatedEventShiftResponse>> {
            return localVarFp.getEventShiftCount(id, eventType, afterDate, beforeDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSingleEvent(id: number, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.getSingleEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEvent(id: number, updateEventRequest: UpdateEventRequest, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.updateEvent(id, updateEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} updateShiftRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEventShift(id: number, updateShiftRequest: UpdateShiftRequest, options?: any): AxiosPromise<EventShiftResponse> {
            return localVarFp.updateEventShift(id, updateShiftRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options?: any): AxiosPromise<BaseEventAnswerResponse> {
            return localVarFp.updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Change the assignment of users to shifts on an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public assignEventShift(eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an event with its corresponding answers objects
     * @param {CreateEventRequest} createEventRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEvent(createEventRequest: CreateEventRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEvent(createEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an event shift
     * @param {CreateShiftRequest} createShiftRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEventShift(createShiftRequest: CreateShiftRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEventShift(createShiftRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an event with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEvent(id: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an event shift with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEventShift(id: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEventShift(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all event shifts
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getAllEventShifts(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getAllEventShifts(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all events
     * @param {string} [name] Name of the event
     * @param {number} [createdById] ID of user that created the event
     * @param {string} [beforeDate] Get only events that start after this date
     * @param {string} [afterDate] Get only events that start before this date
     * @param {string} [type] Get only events that are this type
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the number of times a user has been selected for the given shift
     * @param {number} id The id of the event shift
     * @param {string} [eventType] Only include events of this type
     * @param {string} [afterDate] Only include events after this date
     * @param {string} [beforeDate] Only include events before this date
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventShiftCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventShiftCount(id, eventType, afterDate, beforeDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single event with its answers and shifts
     * @param {number} id The id of the event which should be returned
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getSingleEvent(id: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getSingleEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an event with its corresponding answers objects
     * @param {number} id The id of the event which should be returned
     * @param {UpdateEventRequest} updateEventRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(id: number, updateEventRequest: UpdateEventRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEvent(id, updateEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an event shift
     * @param {number} id The id of the event which should be returned
     * @param {UpdateShiftRequest} updateShiftRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEventShift(id: number, updateShiftRequest: UpdateShiftRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEventShift(id, updateShiftRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the availability of a user for a shift in an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a file with the given name.
         * @param {string} name The name of the file
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (name: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createFile', 'name', name)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload a file with the given name.
         * @param {string} name The name of the file
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(name: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(name, file, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FilesApi.createFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FilesApi.deleteFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FilesApi.getFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload a file with the given name.
         * @param {string} name The name of the file
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(name: string, file?: File, options?: any): AxiosPromise<SimpleFileResponse> {
            return localVarFp.createFile(name, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.getFile(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Upload a file with the given name.
     * @param {string} name The name of the file
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public createFile(name: string, file?: File, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).createFile(name, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFile(id: number, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(id: number, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFile(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice: async (createInvoiceRequest: CreateInvoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInvoiceRequest' is not null or undefined
            assertParamExists('createInvoice', 'createInvoiceRequest', createInvoiceRequest)
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInvoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInvoice', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete invoice user defaults.
         * @param {number} id The id of the invoice user to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInvoiceUser', 'id', id)
            const localVarPath = `/invoices/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices: async (toId?: number, invoiceId?: number, currentState?: GetAllInvoicesCurrentStateEnum, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (invoiceId !== undefined) {
                localVarQueryParameter['invoiceId'] = invoiceId;
            }

            if (currentState) {
                localVarQueryParameter['currentState'] = currentState;
            }

            if (returnEntries !== undefined) {
                localVarQueryParameter['returnEntries'] = returnEntries;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get eligible transactions for invoice creation.
         * @param {number} forId Filter on Id of the debtor
         * @param {string} fromDate Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEligibleTransactions: async (forId: number, fromDate: string, tillDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forId' is not null or undefined
            assertParamExists('getEligibleTransactions', 'forId', forId)
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('getEligibleTransactions', 'fromDate', fromDate)
            const localVarPath = `/invoices/eligible-transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (forId !== undefined) {
                localVarQueryParameter['forId'] = forId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an invoice pdf.
         * @param {number} id The id of the invoice to return
         * @param {boolean} [force] Force creation of pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePdf: async (id: number, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInvoicePdf', 'id', id)
            const localVarPath = `/invoices/{id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice: async (id: number, returnEntries?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleInvoice', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (returnEntries !== undefined) {
                localVarQueryParameter['returnEntries'] = returnEntries;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invoice user defaults.
         * @param {number} id The id of the invoice user to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoiceUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleInvoiceUser', 'id', id)
            const localVarPath = `/invoices/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update or create invoice user defaults.
         * @param {number} id The id of the user to update
         * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInvoiceUser: async (id: number, updateInvoiceUserRequest: UpdateInvoiceUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putInvoiceUser', 'id', id)
            // verify required parameter 'updateInvoiceUserRequest' is not null or undefined
            assertParamExists('putInvoiceUser', 'updateInvoiceUserRequest', updateInvoiceUserRequest)
            const localVarPath = `/invoices/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateInvoiceUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice: async (id: number, updateInvoiceRequest: UpdateInvoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateInvoice', 'id', id)
            // verify required parameter 'updateInvoiceRequest' is not null or undefined
            assertParamExists('updateInvoice', 'updateInvoiceRequest', updateInvoiceRequest)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateInvoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoice(createInvoiceRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.createInvoice']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoice(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoice(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.deleteInvoice']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete invoice user defaults.
         * @param {number} id The id of the invoice user to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoiceUser(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.deleteInvoiceUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllInvoices(toId?: number, invoiceId?: number, currentState?: GetAllInvoicesCurrentStateEnum, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllInvoices(toId, invoiceId, currentState, returnEntries, fromDate, tillDate, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.getAllInvoices']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get eligible transactions for invoice creation.
         * @param {number} forId Filter on Id of the debtor
         * @param {string} fromDate Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEligibleTransactions(forId: number, fromDate: string, tillDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEligibleTransactions(forId, fromDate, tillDate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.getEligibleTransactions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get an invoice pdf.
         * @param {number} id The id of the invoice to return
         * @param {boolean} [force] Force creation of pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePdf(id: number, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoicePdf(id, force, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.getInvoicePdf']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleInvoice(id: number, returnEntries?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleInvoice(id, returnEntries, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.getSingleInvoice']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get invoice user defaults.
         * @param {number} id The id of the invoice user to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleInvoiceUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleInvoiceUser(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.getSingleInvoiceUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update or create invoice user defaults.
         * @param {number} id The id of the user to update
         * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putInvoiceUser(id: number, updateInvoiceUserRequest: UpdateInvoiceUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putInvoiceUser(id, updateInvoiceUserRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.putInvoiceUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvoice(id: number, updateInvoiceRequest: UpdateInvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInvoice(id, updateInvoiceRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.updateInvoice']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: any): AxiosPromise<InvoiceResponse> {
            return localVarFp.createInvoice(createInvoiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvoice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete invoice user defaults.
         * @param {number} id The id of the invoice user to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceUser(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvoiceUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices(toId?: number, invoiceId?: number, currentState?: GetAllInvoicesCurrentStateEnum, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedInvoiceResponse> {
            return localVarFp.getAllInvoices(toId, invoiceId, currentState, returnEntries, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get eligible transactions for invoice creation.
         * @param {number} forId Filter on Id of the debtor
         * @param {string} fromDate Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEligibleTransactions(forId: number, fromDate: string, tillDate?: string, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.getEligibleTransactions(forId, fromDate, tillDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an invoice pdf.
         * @param {number} id The id of the invoice to return
         * @param {boolean} [force] Force creation of pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePdf(id: number, force?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.getInvoicePdf(id, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice(id: number, returnEntries?: boolean, options?: any): AxiosPromise<InvoiceResponse> {
            return localVarFp.getSingleInvoice(id, returnEntries, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get invoice user defaults.
         * @param {number} id The id of the invoice user to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoiceUser(id: number, options?: any): AxiosPromise<InvoiceUserResponse> {
            return localVarFp.getSingleInvoiceUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update or create invoice user defaults.
         * @param {number} id The id of the user to update
         * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInvoiceUser(id: number, updateInvoiceUserRequest: UpdateInvoiceUserRequest, options?: any): AxiosPromise<InvoiceUserResponse> {
            return localVarFp.putInvoiceUser(id, updateInvoiceUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(id: number, updateInvoiceRequest: UpdateInvoiceRequest, options?: any): AxiosPromise<BaseInvoiceResponse> {
            return localVarFp.updateInvoice(id, updateInvoiceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * 
     * @summary Adds an invoice to the system.
     * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).createInvoice(createInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public deleteInvoice(id: number, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).deleteInvoice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete invoice user defaults.
     * @param {number} id The id of the invoice user to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public deleteInvoiceUser(id: number, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).deleteInvoiceUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getAllInvoices(toId?: number, invoiceId?: number, currentState?: GetAllInvoicesCurrentStateEnum, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getAllInvoices(toId, invoiceId, currentState, returnEntries, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get eligible transactions for invoice creation.
     * @param {number} forId Filter on Id of the debtor
     * @param {string} fromDate Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getEligibleTransactions(forId: number, fromDate: string, tillDate?: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getEligibleTransactions(forId, fromDate, tillDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an invoice pdf.
     * @param {number} id The id of the invoice to return
     * @param {boolean} [force] Force creation of pdf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getInvoicePdf(id: number, force?: boolean, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getInvoicePdf(id, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getSingleInvoice(id: number, returnEntries?: boolean, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getSingleInvoice(id, returnEntries, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get invoice user defaults.
     * @param {number} id The id of the invoice user to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getSingleInvoiceUser(id: number, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getSingleInvoiceUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update or create invoice user defaults.
     * @param {number} id The id of the user to update
     * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public putInvoiceUser(id: number, updateInvoiceUserRequest: UpdateInvoiceUserRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).putInvoiceUser(id, updateInvoiceUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public updateInvoice(id: number, updateInvoiceRequest: UpdateInvoiceRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).updateInvoice(id, updateInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllInvoicesCurrentStateEnum = {
} as const;
export type GetAllInvoicesCurrentStateEnum = typeof GetAllInvoicesCurrentStateEnum[keyof typeof GetAllInvoicesCurrentStateEnum];


/**
 * PayoutRequestsApi - axios parameter creator
 * @export
 */
export const PayoutRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new payout request
         * @param {PayoutRequestRequest} payoutRequestRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest: async (payoutRequestRequest: PayoutRequestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payoutRequestRequest' is not null or undefined
            assertParamExists('createPayoutRequest', 'payoutRequestRequest', payoutRequestRequest)
            const localVarPath = `/payoutrequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all payout requests given the filter parameters
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests: async (requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payoutrequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requestedById !== undefined) {
                for (const [key, value] of Object.entries(requestedById)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (approvedById !== undefined) {
                for (const [key, value] of Object.entries(approvedById)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a payout request pdf
         * @param {number} id The ID of the payout request object that should be returned
         * @param {boolean} [force] Whether to force regeneration of the pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutRequestPdf: async (id: number, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPayoutRequestPdf', 'id', id)
            const localVarPath = `/payoutrequests/{id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSinglePayoutRequest', 'id', id)
            const localVarPath = `/payoutrequests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus: async (id: number, payoutRequestStatusRequest: PayoutRequestStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setPayoutRequestStatus', 'id', id)
            // verify required parameter 'payoutRequestStatusRequest' is not null or undefined
            assertParamExists('setPayoutRequestStatus', 'payoutRequestStatusRequest', payoutRequestStatusRequest)
            const localVarPath = `/payoutrequests/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutRequestStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayoutRequestsApi - functional programming interface
 * @export
 */
export const PayoutRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayoutRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new payout request
         * @param {PayoutRequestRequest} payoutRequestRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayoutRequest(payoutRequestRequest: PayoutRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayoutRequest(payoutRequestRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PayoutRequestsApi.createPayoutRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all payout requests given the filter parameters
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPayoutRequests(requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBasePayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PayoutRequestsApi.getAllPayoutRequests']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a payout request pdf
         * @param {number} id The ID of the payout request object that should be returned
         * @param {boolean} [force] Whether to force regeneration of the pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayoutRequestPdf(id: number, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PdfUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayoutRequestPdf(id, force, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PayoutRequestsApi.getPayoutRequestPdf']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSinglePayoutRequest(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSinglePayoutRequest(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PayoutRequestsApi.getSinglePayoutRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPayoutRequestStatus(id: number, payoutRequestStatusRequest: PayoutRequestStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPayoutRequestStatus(id, payoutRequestStatusRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PayoutRequestsApi.setPayoutRequestStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PayoutRequestsApi - factory interface
 * @export
 */
export const PayoutRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayoutRequestsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new payout request
         * @param {PayoutRequestRequest} payoutRequestRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest(payoutRequestRequest: PayoutRequestRequest, options?: any): AxiosPromise<PayoutRequestResponse> {
            return localVarFp.createPayoutRequest(payoutRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all payout requests given the filter parameters
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests(requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBasePayoutRequestResponse> {
            return localVarFp.getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a payout request pdf
         * @param {number} id The ID of the payout request object that should be returned
         * @param {boolean} [force] Whether to force regeneration of the pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutRequestPdf(id: number, force?: boolean, options?: any): AxiosPromise<PdfUrlResponse> {
            return localVarFp.getPayoutRequestPdf(id, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest(id: number, options?: any): AxiosPromise<PayoutRequestResponse> {
            return localVarFp.getSinglePayoutRequest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus(id: number, payoutRequestStatusRequest: PayoutRequestStatusRequest, options?: any): AxiosPromise<PayoutRequestResponse> {
            return localVarFp.setPayoutRequestStatus(id, payoutRequestStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayoutRequestsApi - object-oriented interface
 * @export
 * @class PayoutRequestsApi
 * @extends {BaseAPI}
 */
export class PayoutRequestsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new payout request
     * @param {PayoutRequestRequest} payoutRequestRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public createPayoutRequest(payoutRequestRequest: PayoutRequestRequest, options?: RawAxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).createPayoutRequest(payoutRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all payout requests given the filter parameters
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public getAllPayoutRequests(requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a payout request pdf
     * @param {number} id The ID of the payout request object that should be returned
     * @param {boolean} [force] Whether to force regeneration of the pdf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public getPayoutRequestPdf(id: number, force?: boolean, options?: RawAxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).getPayoutRequestPdf(id, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public getSinglePayoutRequest(id: number, options?: RawAxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).getSinglePayoutRequest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public setPayoutRequestStatus(id: number, payoutRequestStatusRequest: PayoutRequestStatusRequest, options?: RawAxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).setPayoutRequestStatus(id, payoutRequestStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PointofsaleApi - axios parameter creator
 * @export
 */
export const PointofsaleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale: async (createPointOfSaleRequest: CreatePointOfSaleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPointOfSaleRequest' is not null or undefined
            assertParamExists('createPointOfSale', 'createPointOfSaleRequest', createPointOfSaleRequest)
            const localVarPath = `/pointsofsale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPointOfSaleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary (Soft) delete the given point of sale. Cannot be undone.
         * @param {number} id The id of the point of sale which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePointOfSale: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePointOfSale', 'id', id)
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAllPointOfSaleContainers', 'id', id)
            const localVarPath = `/pointsofsale/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAllPointOfSaleProducts', 'id', id)
            const localVarPath = `/pointsofsale/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pointsofsale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a Point of Sale\'s associate users
         * @param {number} id The id of the Point of Sale of which to get the associate users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPointOfSaleAssociates: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPointOfSaleAssociates', 'id', id)
            const localVarPath = `/pointsofsale/{id}/associates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSinglePointOfSale', 'id', id)
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a Point of Sale transactions
         * @param {number} id The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransactions', 'id', id)
            const localVarPath = `/pointsofsale/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale: async (id: number, updatePointOfSaleRequest: UpdatePointOfSaleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePointOfSale', 'id', id)
            // verify required parameter 'updatePointOfSaleRequest' is not null or undefined
            assertParamExists('updatePointOfSale', 'updatePointOfSaleRequest', updatePointOfSaleRequest)
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePointOfSaleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PointofsaleApi - functional programming interface
 * @export
 */
export const PointofsaleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PointofsaleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPointOfSale(createPointOfSaleRequest: CreatePointOfSaleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPointOfSale(createPointOfSaleRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.createPointOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary (Soft) delete the given point of sale. Cannot be undone.
         * @param {number} id The id of the point of sale which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePointOfSale(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePointOfSale(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.deletePointOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPointOfSaleContainers(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.getAllPointOfSaleContainers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPointOfSaleProducts(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPointOfSaleProducts(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.getAllPointOfSaleProducts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPointsOfSale(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPointOfSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPointsOfSale(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.getAllPointsOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a Point of Sale\'s associate users
         * @param {number} id The id of the Point of Sale of which to get the associate users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPointOfSaleAssociates(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleAssociateUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPointOfSaleAssociates(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.getPointOfSaleAssociates']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSinglePointOfSale(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSinglePointOfSale(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.getSinglePointOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a Point of Sale transactions
         * @param {number} id The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.getTransactions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePointOfSale(id: number, updatePointOfSaleRequest: UpdatePointOfSaleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePointOfSale(id, updatePointOfSaleRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.updatePointOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PointofsaleApi - factory interface
 * @export
 */
export const PointofsaleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PointofsaleApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale(createPointOfSaleRequest: CreatePointOfSaleRequest, options?: any): AxiosPromise<PointOfSaleWithContainersResponse> {
            return localVarFp.createPointOfSale(createPointOfSaleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary (Soft) delete the given point of sale. Cannot be undone.
         * @param {number} id The id of the point of sale which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePointOfSale(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.deletePointOfSale(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getAllPointOfSaleContainers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts(id: number, options?: any): AxiosPromise<Array<ProductResponse>> {
            return localVarFp.getAllPointOfSaleProducts(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedPointOfSaleResponse> {
            return localVarFp.getAllPointsOfSale(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a Point of Sale\'s associate users
         * @param {number} id The id of the Point of Sale of which to get the associate users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPointOfSaleAssociates(id: number, options?: any): AxiosPromise<PointOfSaleAssociateUsersResponse> {
            return localVarFp.getPointOfSaleAssociates(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale(id: number, options?: any): AxiosPromise<PointOfSaleWithContainersResponse> {
            return localVarFp.getSinglePointOfSale(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a Point of Sale transactions
         * @param {number} id The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse> {
            return localVarFp.getTransactions(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale(id: number, updatePointOfSaleRequest: UpdatePointOfSaleRequest, options?: any): AxiosPromise<PointOfSaleWithContainersResponse> {
            return localVarFp.updatePointOfSale(id, updatePointOfSaleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PointofsaleApi - object-oriented interface
 * @export
 * @class PointofsaleApi
 * @extends {BaseAPI}
 */
export class PointofsaleApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public createPointOfSale(createPointOfSaleRequest: CreatePointOfSaleRequest, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).createPointOfSale(createPointOfSaleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary (Soft) delete the given point of sale. Cannot be undone.
     * @param {number} id The id of the point of sale which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public deletePointOfSale(id: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).deletePointOfSale(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getAllPointOfSaleContainers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getAllPointOfSaleProducts(id: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getAllPointOfSaleProducts(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getAllPointsOfSale(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getAllPointsOfSale(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a Point of Sale\'s associate users
     * @param {number} id The id of the Point of Sale of which to get the associate users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getPointOfSaleAssociates(id: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getPointOfSaleAssociates(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getSinglePointOfSale(id: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getSinglePointOfSale(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a Point of Sale transactions
     * @param {number} id The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getTransactions(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getTransactions(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public updatePointOfSale(id: number, updatePointOfSaleRequest: UpdatePointOfSaleRequest, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).updatePointOfSale(id, updatePointOfSaleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductCategoriesApi - axios parameter creator
 * @export
 */
export const ProductCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post a new productCategory.
         * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory: async (productCategoryRequest: ProductCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productCategoryRequest' is not null or undefined
            assertParamExists('createProductCategory', 'productCategoryRequest', productCategoryRequest)
            const localVarPath = `/productcategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing productcategories
         * @param {boolean} [onlyRoot] Whether to return only root categories
         * @param {boolean} [onlyLeaf] Whether to return only leaf categories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories: async (onlyRoot?: boolean, onlyLeaf?: boolean, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/productcategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (onlyRoot !== undefined) {
                localVarQueryParameter['onlyRoot'] = onlyRoot;
            }

            if (onlyLeaf !== undefined) {
                localVarQueryParameter['onlyLeaf'] = onlyLeaf;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleProductCategory', 'id', id)
            const localVarPath = `/productcategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory: async (id: number, productCategoryRequest: ProductCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProductCategory', 'id', id)
            // verify required parameter 'productCategoryRequest' is not null or undefined
            assertParamExists('updateProductCategory', 'productCategoryRequest', productCategoryRequest)
            const localVarPath = `/productcategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductCategoriesApi - functional programming interface
 * @export
 */
export const ProductCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post a new productCategory.
         * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductCategory(productCategoryRequest: ProductCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProductCategory(productCategoryRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductCategoriesApi.createProductCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing productcategories
         * @param {boolean} [onlyRoot] Whether to return only root categories
         * @param {boolean} [onlyLeaf] Whether to return only leaf categories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProductCategories(onlyRoot?: boolean, onlyLeaf?: boolean, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProductCategories(onlyRoot, onlyLeaf, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductCategoriesApi.getAllProductCategories']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleProductCategory(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleProductCategory(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductCategoriesApi.getSingleProductCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductCategory(id: number, productCategoryRequest: ProductCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductCategory(id, productCategoryRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductCategoriesApi.updateProductCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProductCategoriesApi - factory interface
 * @export
 */
export const ProductCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductCategoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Post a new productCategory.
         * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory(productCategoryRequest: ProductCategoryRequest, options?: any): AxiosPromise<ProductCategoryResponse> {
            return localVarFp.createProductCategory(productCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing productcategories
         * @param {boolean} [onlyRoot] Whether to return only root categories
         * @param {boolean} [onlyLeaf] Whether to return only leaf categories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories(onlyRoot?: boolean, onlyLeaf?: boolean, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductCategoryResponse> {
            return localVarFp.getAllProductCategories(onlyRoot, onlyLeaf, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory(id: number, options?: any): AxiosPromise<ProductCategoryResponse> {
            return localVarFp.getSingleProductCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory(id: number, productCategoryRequest: ProductCategoryRequest, options?: any): AxiosPromise<ProductCategoryResponse> {
            return localVarFp.updateProductCategory(id, productCategoryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductCategoriesApi - object-oriented interface
 * @export
 * @class ProductCategoriesApi
 * @extends {BaseAPI}
 */
export class ProductCategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Post a new productCategory.
     * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public createProductCategory(productCategoryRequest: ProductCategoryRequest, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).createProductCategory(productCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing productcategories
     * @param {boolean} [onlyRoot] Whether to return only root categories
     * @param {boolean} [onlyLeaf] Whether to return only leaf categories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public getAllProductCategories(onlyRoot?: boolean, onlyLeaf?: boolean, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).getAllProductCategories(onlyRoot, onlyLeaf, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public getSingleProductCategory(id: number, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).getSingleProductCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public updateProductCategory(id: number, productCategoryRequest: ProductCategoryRequest, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).updateProductCategory(id, productCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new product.
         * @param {CreateProductRequest} createProductRequest The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (createProductRequest: CreateProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductRequest' is not null or undefined
            assertParamExists('createProduct', 'createProductRequest', createProductRequest)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary (Soft) delete the given product. Cannot be undone.
         * @param {number} id The id of the product which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} updateProductRequest The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (id: number, updateProductRequest: UpdateProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduct', 'id', id)
            // verify required parameter 'updateProductRequest' is not null or undefined
            assertParamExists('updateProduct', 'updateProductRequest', updateProductRequest)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProductImage', 'id', id)
            const localVarPath = `/products/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new product.
         * @param {CreateProductRequest} createProductRequest The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(createProductRequest: CreateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(createProductRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.createProduct']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary (Soft) delete the given product. Cannot be undone.
         * @param {number} id The id of the product which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.deleteProduct']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProducts(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProducts(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.getAllProducts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleProduct(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleProduct(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.getSingleProduct']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} updateProductRequest The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(id: number, updateProductRequest: UpdateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(id, updateProductRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.updateProduct']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductImage(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductImage(id, file, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.updateProductImage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new product.
         * @param {CreateProductRequest} createProductRequest The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(createProductRequest: CreateProductRequest, options?: any): AxiosPromise<ProductResponse> {
            return localVarFp.createProduct(createProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary (Soft) delete the given product. Cannot be undone.
         * @param {number} id The id of the product which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse> {
            return localVarFp.getAllProducts(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct(id: number, options?: any): AxiosPromise<ProductResponse> {
            return localVarFp.getSingleProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} updateProductRequest The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: number, updateProductRequest: UpdateProductRequest, options?: any): AxiosPromise<ProductResponse> {
            return localVarFp.updateProduct(id, updateProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage(id: number, file?: File, options?: any): AxiosPromise<void> {
            return localVarFp.updateProductImage(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new product.
     * @param {CreateProductRequest} createProductRequest The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProduct(createProductRequest: CreateProductRequest, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).createProduct(createProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary (Soft) delete the given product. Cannot be undone.
     * @param {number} id The id of the product which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProduct(id: number, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).deleteProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getAllProducts(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getAllProducts(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getSingleProduct(id: number, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getSingleProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} updateProductRequest The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(id: number, updateProductRequest: UpdateProductRequest, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).updateProduct(id, updateProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProductImage(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).updateProductImage(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RbacApi - axios parameter creator
 * @export
 */
export const RbacApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new permissions to an existing role
         * @param {number} id The ID of the role which should get the new permissions
         * @param {Array<CreatePermissionParams>} createPermissionParams The permissions that need to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissions: async (id: number, createPermissionParams: Array<CreatePermissionParams>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addPermissions', 'id', id)
            // verify required parameter 'createPermissionParams' is not null or undefined
            assertParamExists('addPermissions', 'createPermissionParams', createPermissionParams)
            const localVarPath = `/rbac/roles/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPermissionParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new role
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (updateRoleRequest: UpdateRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateRoleRequest' is not null or undefined
            assertParamExists('createRole', 'updateRoleRequest', updateRoleRequest)
            const localVarPath = `/rbac/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a permission from an existing role
         * @param {number} id The ID of the role
         * @param {string} entity The entity of the permission
         * @param {string} action The action of the permission
         * @param {string} relation The relation of the permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission: async (id: number, entity: string, action: string, relation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePermission', 'id', id)
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('deletePermission', 'entity', entity)
            // verify required parameter 'action' is not null or undefined
            assertParamExists('deletePermission', 'action', action)
            // verify required parameter 'relation' is not null or undefined
            assertParamExists('deletePermission', 'relation', relation)
            const localVarPath = `/rbac/roles/{id}/permissions/{entity}/{action}/{relation}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)))
                .replace(`{${"action"}}`, encodeURIComponent(String(action)))
                .replace(`{${"relation"}}`, encodeURIComponent(String(relation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing role
         * @param {number} id The ID of the role which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRole', 'id', id)
            const localVarPath = `/rbac/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rbac/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users linked to a specific role
         * @param {number} id The ID of the role that the users are linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleUsers: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoleUsers', 'id', id)
            const localVarPath = `/rbac/roles/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single existing role with its permissions
         * @param {number} id The ID of the role that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRole: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleRole', 'id', id)
            const localVarPath = `/rbac/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing role
         * @param {number} id The ID of the role which should be updated
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (id: number, updateRoleRequest: UpdateRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRole', 'id', id)
            // verify required parameter 'updateRoleRequest' is not null or undefined
            assertParamExists('updateRole', 'updateRoleRequest', updateRoleRequest)
            const localVarPath = `/rbac/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RbacApi - functional programming interface
 * @export
 */
export const RbacApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RbacApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new permissions to an existing role
         * @param {number} id The ID of the role which should get the new permissions
         * @param {Array<CreatePermissionParams>} createPermissionParams The permissions that need to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPermissions(id: number, createPermissionParams: Array<CreatePermissionParams>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPermissions(id, createPermissionParams, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacApi.addPermissions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new role
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(updateRoleRequest: UpdateRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(updateRoleRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacApi.createRole']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a permission from an existing role
         * @param {number} id The ID of the role
         * @param {string} entity The entity of the permission
         * @param {string} action The action of the permission
         * @param {string} relation The relation of the permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermission(id: number, entity: string, action: string, relation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermission(id, entity, action, relation, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacApi.deletePermission']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an existing role
         * @param {number} id The ID of the role which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacApi.deleteRole']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRoles(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacApi.getAllRoles']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users linked to a specific role
         * @param {number} id The ID of the role that the users are linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleUsers(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleUsers(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacApi.getRoleUsers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single existing role with its permissions
         * @param {number} id The ID of the role that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleRole(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithPermissionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleRole(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacApi.getSingleRole']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing role
         * @param {number} id The ID of the role which should be updated
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(id: number, updateRoleRequest: UpdateRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(id, updateRoleRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacApi.updateRole']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RbacApi - factory interface
 * @export
 */
export const RbacApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RbacApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new permissions to an existing role
         * @param {number} id The ID of the role which should get the new permissions
         * @param {Array<CreatePermissionParams>} createPermissionParams The permissions that need to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissions(id: number, createPermissionParams: Array<CreatePermissionParams>, options?: any): AxiosPromise<Array<PermissionResponse>> {
            return localVarFp.addPermissions(id, createPermissionParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new role
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(updateRoleRequest: UpdateRoleRequest, options?: any): AxiosPromise<RoleResponse> {
            return localVarFp.createRole(updateRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a permission from an existing role
         * @param {number} id The ID of the role
         * @param {string} entity The entity of the permission
         * @param {string} action The action of the permission
         * @param {string} relation The relation of the permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission(id: number, entity: string, action: string, relation: string, options?: any): AxiosPromise<string> {
            return localVarFp.deletePermission(id, entity, action, relation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing role
         * @param {number} id The ID of the role which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options?: any): AxiosPromise<Array<RoleResponse>> {
            return localVarFp.getAllRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users linked to a specific role
         * @param {number} id The ID of the role that the users are linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleUsers(id: number, options?: any): AxiosPromise<PaginatedUserResponse> {
            return localVarFp.getRoleUsers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single existing role with its permissions
         * @param {number} id The ID of the role that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRole(id: number, options?: any): AxiosPromise<RoleWithPermissionsResponse> {
            return localVarFp.getSingleRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing role
         * @param {number} id The ID of the role which should be updated
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(id: number, updateRoleRequest: UpdateRoleRequest, options?: any): AxiosPromise<RoleResponse> {
            return localVarFp.updateRole(id, updateRoleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RbacApi - object-oriented interface
 * @export
 * @class RbacApi
 * @extends {BaseAPI}
 */
export class RbacApi extends BaseAPI {
    /**
     * 
     * @summary Add new permissions to an existing role
     * @param {number} id The ID of the role which should get the new permissions
     * @param {Array<CreatePermissionParams>} createPermissionParams The permissions that need to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    public addPermissions(id: number, createPermissionParams: Array<CreatePermissionParams>, options?: RawAxiosRequestConfig) {
        return RbacApiFp(this.configuration).addPermissions(id, createPermissionParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new role
     * @param {UpdateRoleRequest} updateRoleRequest The role which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    public createRole(updateRoleRequest: UpdateRoleRequest, options?: RawAxiosRequestConfig) {
        return RbacApiFp(this.configuration).createRole(updateRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a permission from an existing role
     * @param {number} id The ID of the role
     * @param {string} entity The entity of the permission
     * @param {string} action The action of the permission
     * @param {string} relation The relation of the permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    public deletePermission(id: number, entity: string, action: string, relation: string, options?: RawAxiosRequestConfig) {
        return RbacApiFp(this.configuration).deletePermission(id, entity, action, relation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing role
     * @param {number} id The ID of the role which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    public deleteRole(id: number, options?: RawAxiosRequestConfig) {
        return RbacApiFp(this.configuration).deleteRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    public getAllRoles(options?: RawAxiosRequestConfig) {
        return RbacApiFp(this.configuration).getAllRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users linked to a specific role
     * @param {number} id The ID of the role that the users are linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    public getRoleUsers(id: number, options?: RawAxiosRequestConfig) {
        return RbacApiFp(this.configuration).getRoleUsers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single existing role with its permissions
     * @param {number} id The ID of the role that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    public getSingleRole(id: number, options?: RawAxiosRequestConfig) {
        return RbacApiFp(this.configuration).getSingleRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing role
     * @param {number} id The ID of the role which should be updated
     * @param {UpdateRoleRequest} updateRoleRequest The role which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    public updateRole(id: number, updateRoleRequest: UpdateRoleRequest, options?: RawAxiosRequestConfig) {
        return RbacApiFp(this.configuration).updateRole(id, updateRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RootApi - axios parameter creator
 * @export
 */
export const RootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current status of the backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RootApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the current status of the backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RootApi.ping']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RootApi - factory interface
 * @export
 */
export const RootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RootApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the current status of the backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<ServerStatusResponse> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export class RootApi extends BaseAPI {
    /**
     * 
     * @summary Get the current status of the backend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return RootApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SellerPayoutsApi - axios parameter creator
 * @export
 */
export const SellerPayoutsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new seller payout
         * @param {CreateSellerPayoutRequest} createSellerPayoutRequest New seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSellerPayout: async (createSellerPayoutRequest: CreateSellerPayoutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSellerPayoutRequest' is not null or undefined
            assertParamExists('createSellerPayout', 'createSellerPayoutRequest', createSellerPayoutRequest)
            const localVarPath = `/seller-payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSellerPayoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSellerPayout: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSellerPayout', 'id', id)
            const localVarPath = `/seller-payouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all seller payouts
         * @param {number} [requestedById] Requested by user ID
         * @param {string} [fromDate] Lower bound on seller payout creation date (inclusive)
         * @param {string} [tillDate] Upper bound on seller payout creation date (exclusive)
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSellerPayouts: async (requestedById?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/seller-payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requestedById !== undefined) {
                localVarQueryParameter['requestedById'] = requestedById;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single seller payout\'s sales report
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellerPayoutReport: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSellerPayoutReport', 'id', id)
            const localVarPath = `/seller-payouts/{id}/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single seller payout\'s sales report as PDF
         * @param {number} id ID of the seller payout that should be returned
         * @param {boolean} [force] Force the generation of the PDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellerPayoutReportPdf: async (id: number, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSellerPayoutReportPdf', 'id', id)
            const localVarPath = `/seller-payouts/{id}/report/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single seller payout
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSellerPayout: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleSellerPayout', 'id', id)
            const localVarPath = `/seller-payouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {UpdateSellerPayoutRequest} updateSellerPayoutRequest Updated seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSellerPayout: async (id: number, updateSellerPayoutRequest: UpdateSellerPayoutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSellerPayout', 'id', id)
            // verify required parameter 'updateSellerPayoutRequest' is not null or undefined
            assertParamExists('updateSellerPayout', 'updateSellerPayoutRequest', updateSellerPayoutRequest)
            const localVarPath = `/seller-payouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSellerPayoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SellerPayoutsApi - functional programming interface
 * @export
 */
export const SellerPayoutsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SellerPayoutsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new seller payout
         * @param {CreateSellerPayoutRequest} createSellerPayoutRequest New seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSellerPayout(createSellerPayoutRequest: CreateSellerPayoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SellerPayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSellerPayout(createSellerPayoutRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SellerPayoutsApi.createSellerPayout']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSellerPayout(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSellerPayout(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SellerPayoutsApi.deleteSellerPayout']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Return all seller payouts
         * @param {number} [requestedById] Requested by user ID
         * @param {string} [fromDate] Lower bound on seller payout creation date (inclusive)
         * @param {string} [tillDate] Upper bound on seller payout creation date (exclusive)
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSellerPayouts(requestedById?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSellerPayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSellerPayouts(requestedById, fromDate, tillDate, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SellerPayoutsApi.getAllSellerPayouts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single seller payout\'s sales report
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSellerPayoutReport(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSellerPayoutReport(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SellerPayoutsApi.getSellerPayoutReport']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single seller payout\'s sales report as PDF
         * @param {number} id ID of the seller payout that should be returned
         * @param {boolean} [force] Force the generation of the PDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSellerPayoutReportPdf(id: number, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PdfUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSellerPayoutReportPdf(id, force, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SellerPayoutsApi.getSellerPayoutReportPdf']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single seller payout
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleSellerPayout(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SellerPayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleSellerPayout(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SellerPayoutsApi.getSingleSellerPayout']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {UpdateSellerPayoutRequest} updateSellerPayoutRequest Updated seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSellerPayout(id: number, updateSellerPayoutRequest: UpdateSellerPayoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SellerPayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSellerPayout(id, updateSellerPayoutRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SellerPayoutsApi.updateSellerPayout']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SellerPayoutsApi - factory interface
 * @export
 */
export const SellerPayoutsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SellerPayoutsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new seller payout
         * @param {CreateSellerPayoutRequest} createSellerPayoutRequest New seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSellerPayout(createSellerPayoutRequest: CreateSellerPayoutRequest, options?: any): AxiosPromise<SellerPayoutResponse> {
            return localVarFp.createSellerPayout(createSellerPayoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSellerPayout(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteSellerPayout(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all seller payouts
         * @param {number} [requestedById] Requested by user ID
         * @param {string} [fromDate] Lower bound on seller payout creation date (inclusive)
         * @param {string} [tillDate] Upper bound on seller payout creation date (exclusive)
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSellerPayouts(requestedById?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedSellerPayoutResponse> {
            return localVarFp.getAllSellerPayouts(requestedById, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single seller payout\'s sales report
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellerPayoutReport(id: number, options?: any): AxiosPromise<ReportResponse> {
            return localVarFp.getSellerPayoutReport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single seller payout\'s sales report as PDF
         * @param {number} id ID of the seller payout that should be returned
         * @param {boolean} [force] Force the generation of the PDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellerPayoutReportPdf(id: number, force?: boolean, options?: any): AxiosPromise<PdfUrlResponse> {
            return localVarFp.getSellerPayoutReportPdf(id, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single seller payout
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSellerPayout(id: number, options?: any): AxiosPromise<SellerPayoutResponse> {
            return localVarFp.getSingleSellerPayout(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {UpdateSellerPayoutRequest} updateSellerPayoutRequest Updated seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSellerPayout(id: number, updateSellerPayoutRequest: UpdateSellerPayoutRequest, options?: any): AxiosPromise<SellerPayoutResponse> {
            return localVarFp.updateSellerPayout(id, updateSellerPayoutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SellerPayoutsApi - object-oriented interface
 * @export
 * @class SellerPayoutsApi
 * @extends {BaseAPI}
 */
export class SellerPayoutsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new seller payout
     * @param {CreateSellerPayoutRequest} createSellerPayoutRequest New seller payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    public createSellerPayout(createSellerPayoutRequest: CreateSellerPayoutRequest, options?: RawAxiosRequestConfig) {
        return SellerPayoutsApiFp(this.configuration).createSellerPayout(createSellerPayoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing seller payout
     * @param {number} id ID of the seller payout that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    public deleteSellerPayout(id: number, options?: RawAxiosRequestConfig) {
        return SellerPayoutsApiFp(this.configuration).deleteSellerPayout(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all seller payouts
     * @param {number} [requestedById] Requested by user ID
     * @param {string} [fromDate] Lower bound on seller payout creation date (inclusive)
     * @param {string} [tillDate] Upper bound on seller payout creation date (exclusive)
     * @param {number} [take] Number of write-offs to return
     * @param {number} [skip] Number of write-offs to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    public getAllSellerPayouts(requestedById?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return SellerPayoutsApiFp(this.configuration).getAllSellerPayouts(requestedById, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single seller payout\'s sales report
     * @param {number} id ID of the seller payout that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    public getSellerPayoutReport(id: number, options?: RawAxiosRequestConfig) {
        return SellerPayoutsApiFp(this.configuration).getSellerPayoutReport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single seller payout\'s sales report as PDF
     * @param {number} id ID of the seller payout that should be returned
     * @param {boolean} [force] Force the generation of the PDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    public getSellerPayoutReportPdf(id: number, force?: boolean, options?: RawAxiosRequestConfig) {
        return SellerPayoutsApiFp(this.configuration).getSellerPayoutReportPdf(id, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single seller payout
     * @param {number} id ID of the seller payout that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    public getSingleSellerPayout(id: number, options?: RawAxiosRequestConfig) {
        return SellerPayoutsApiFp(this.configuration).getSingleSellerPayout(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing seller payout
     * @param {number} id ID of the seller payout that should be updated
     * @param {UpdateSellerPayoutRequest} updateSellerPayoutRequest Updated seller payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    public updateSellerPayout(id: number, updateSellerPayoutRequest: UpdateSellerPayoutRequest, options?: RawAxiosRequestConfig) {
        return SellerPayoutsApiFp(this.configuration).updateSellerPayout(id, updateSellerPayoutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServerSettingsApi - axios parameter creator
 * @export
 */
export const ServerSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Enable/disable maintenance mode
         * @param {UpdateMaintenanceModeRequest} updateMaintenanceModeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaintenanceMode: async (updateMaintenanceModeRequest: UpdateMaintenanceModeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateMaintenanceModeRequest' is not null or undefined
            assertParamExists('setMaintenanceMode', 'updateMaintenanceModeRequest', updateMaintenanceModeRequest)
            const localVarPath = `/server-settings/maintenance-mode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMaintenanceModeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerSettingsApi - functional programming interface
 * @export
 */
export const ServerSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Enable/disable maintenance mode
         * @param {UpdateMaintenanceModeRequest} updateMaintenanceModeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMaintenanceMode(updateMaintenanceModeRequest: UpdateMaintenanceModeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMaintenanceMode(updateMaintenanceModeRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerSettingsApi.setMaintenanceMode']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServerSettingsApi - factory interface
 * @export
 */
export const ServerSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerSettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Enable/disable maintenance mode
         * @param {UpdateMaintenanceModeRequest} updateMaintenanceModeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaintenanceMode(updateMaintenanceModeRequest: UpdateMaintenanceModeRequest, options?: any): AxiosPromise<string> {
            return localVarFp.setMaintenanceMode(updateMaintenanceModeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerSettingsApi - object-oriented interface
 * @export
 * @class ServerSettingsApi
 * @extends {BaseAPI}
 */
export class ServerSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Enable/disable maintenance mode
     * @param {UpdateMaintenanceModeRequest} updateMaintenanceModeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSettingsApi
     */
    public setMaintenanceMode(updateMaintenanceModeRequest: UpdateMaintenanceModeRequest, options?: RawAxiosRequestConfig) {
        return ServerSettingsApiFp(this.configuration).setMaintenanceMode(updateMaintenanceModeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Start the stripe deposit flow
         * @param {StripeRequest} stripeRequest The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: async (stripeRequest: StripeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stripeRequest' is not null or undefined
            assertParamExists('deposit', 'stripeRequest', stripeRequest)
            const localVarPath = `/stripe/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stripeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Stripe public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripePublicKey: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Start the stripe deposit flow
         * @param {StripeRequest} stripeRequest The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deposit(stripeRequest: StripeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deposit(stripeRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StripeApi.deposit']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Stripe public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStripePublicKey(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStripePublicKey(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StripeApi.getStripePublicKey']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * 
         * @summary Start the stripe deposit flow
         * @param {StripeRequest} stripeRequest The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(stripeRequest: StripeRequest, options?: any): AxiosPromise<StripePaymentIntentResponse> {
            return localVarFp.deposit(stripeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Stripe public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripePublicKey(options?: any): AxiosPromise<string> {
            return localVarFp.getStripePublicKey(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * 
     * @summary Start the stripe deposit flow
     * @param {StripeRequest} stripeRequest The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public deposit(stripeRequest: StripeRequest, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).deposit(stripeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Stripe public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public getStripePublicKey(options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).getStripePublicKey(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SyncApi - axios parameter creator
 * @export
 */
export const SyncApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs a dry-run synchronization of users using the specified services. This endpoint always performs a dry-run and does not apply any actual database changes.
         * @summary Get dry-run sync results for users
         * @param {GetUserSyncResultsServiceEnum} [service] Array of sync services to use (ldap, gewisdb). If not provided, all available services will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSyncResults: async (service?: GetUserSyncResultsServiceEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sync/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (service) {
                localVarQueryParameter['service'] = service;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SyncApi - functional programming interface
 * @export
 */
export const SyncApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SyncApiAxiosParamCreator(configuration)
    return {
        /**
         * Performs a dry-run synchronization of users using the specified services. This endpoint always performs a dry-run and does not apply any actual database changes.
         * @summary Get dry-run sync results for users
         * @param {GetUserSyncResultsServiceEnum} [service] Array of sync services to use (ldap, gewisdb). If not provided, all available services will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSyncResults(service?: GetUserSyncResultsServiceEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSyncResults(service, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SyncApi.getUserSyncResults']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SyncApi - factory interface
 * @export
 */
export const SyncApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SyncApiFp(configuration)
    return {
        /**
         * Performs a dry-run synchronization of users using the specified services. This endpoint always performs a dry-run and does not apply any actual database changes.
         * @summary Get dry-run sync results for users
         * @param {GetUserSyncResultsServiceEnum} [service] Array of sync services to use (ldap, gewisdb). If not provided, all available services will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSyncResults(service?: GetUserSyncResultsServiceEnum, options?: any): AxiosPromise<object> {
            return localVarFp.getUserSyncResults(service, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SyncApi - object-oriented interface
 * @export
 * @class SyncApi
 * @extends {BaseAPI}
 */
export class SyncApi extends BaseAPI {
    /**
     * Performs a dry-run synchronization of users using the specified services. This endpoint always performs a dry-run and does not apply any actual database changes.
     * @summary Get dry-run sync results for users
     * @param {GetUserSyncResultsServiceEnum} [service] Array of sync services to use (ldap, gewisdb). If not provided, all available services will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncApi
     */
    public getUserSyncResults(service?: GetUserSyncResultsServiceEnum, options?: RawAxiosRequestConfig) {
        return SyncApiFp(this.configuration).getUserSyncResults(service, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetUserSyncResultsServiceEnum = {
} as const;
export type GetUserSyncResultsServiceEnum = typeof GetUserSyncResultsServiceEnum[keyof typeof GetUserSyncResultsServiceEnum];


/**
 * TestOperationsOfTheTestControllerApi - axios parameter creator
 * @export
 */
export const TestOperationsOfTheTestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test/helloworld`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestOperationsOfTheTestControllerApi - functional programming interface
 * @export
 */
export const TestOperationsOfTheTestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestOperationsOfTheTestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helloworld(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helloworld(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TestOperationsOfTheTestControllerApi.helloworld']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TestOperationsOfTheTestControllerApi - factory interface
 * @export
 */
export const TestOperationsOfTheTestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestOperationsOfTheTestControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld(options?: any): AxiosPromise<void> {
            return localVarFp.helloworld(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestOperationsOfTheTestControllerApi - object-oriented interface
 * @export
 * @class TestOperationsOfTheTestControllerApi
 * @extends {BaseAPI}
 */
export class TestOperationsOfTheTestControllerApi extends BaseAPI {
    /**
     * 
     * @summary Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestOperationsOfTheTestControllerApi
     */
    public helloworld(options?: RawAxiosRequestConfig) {
        return TestOperationsOfTheTestControllerApiFp(this.configuration).helloworld(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionSummariesApi - axios parameter creator
 * @export
 */
export const TransactionSummariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a summary of all purchases within a container
         * @param {number} id The ID of the container
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSingleContainerSummary: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleContainerSummary', 'id', id)
            const localVarPath = `/transactions/summary/container/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionSummariesApi - functional programming interface
 * @export
 */
export const TransactionSummariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionSummariesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a summary of all purchases within a container
         * @param {number} id The ID of the container
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getSingleContainerSummary(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContainerSummaryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleContainerSummary(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionSummariesApi.getSingleContainerSummary']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TransactionSummariesApi - factory interface
 * @export
 */
export const TransactionSummariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionSummariesApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a summary of all purchases within a container
         * @param {number} id The ID of the container
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSingleContainerSummary(id: number, options?: any): AxiosPromise<Array<ContainerSummaryResponse>> {
            return localVarFp.getSingleContainerSummary(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionSummariesApi - object-oriented interface
 * @export
 * @class TransactionSummariesApi
 * @extends {BaseAPI}
 */
export class TransactionSummariesApi extends BaseAPI {
    /**
     * 
     * @summary Returns a summary of all purchases within a container
     * @param {number} id The ID of the container
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TransactionSummariesApi
     */
    public getSingleContainerSummary(id: number, options?: RawAxiosRequestConfig) {
        return TransactionSummariesApiFp(this.configuration).getSingleContainerSummary(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new transaction
         * @param {TransactionRequest} transactionRequest The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (transactionRequest: TransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionRequest' is not null or undefined
            assertParamExists('createTransaction', 'transactionRequest', transactionRequest)
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransaction', 'id', id)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions
         * @param {number} [excludeById] Created by user to exclude from transactions
         * @param {number} [excludeFromId] From user to exclude from transactions
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions: async (fromId?: number, createdById?: number, toId?: number, excludeById?: number, excludeFromId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (excludeById !== undefined) {
                localVarQueryParameter['excludeById'] = excludeById;
            }

            if (excludeFromId !== undefined) {
                localVarQueryParameter['excludeFromId'] = excludeFromId;
            }

            if (pointOfSaleId !== undefined) {
                localVarQueryParameter['pointOfSaleId'] = pointOfSaleId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (productRevision !== undefined) {
                localVarQueryParameter['productRevision'] = productRevision;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleTransaction', 'id', id)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transactionRequest The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: async (id: number, transactionRequest: TransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransaction', 'id', id)
            // verify required parameter 'transactionRequest' is not null or undefined
            assertParamExists('updateTransaction', 'transactionRequest', transactionRequest)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transactionRequest The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction: async (transactionRequest: TransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionRequest' is not null or undefined
            assertParamExists('validateTransaction', 'transactionRequest', transactionRequest)
            const localVarPath = `/transactions/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new transaction
         * @param {TransactionRequest} transactionRequest The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransaction(transactionRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.createTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransaction(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransaction(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.deleteTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions
         * @param {number} [excludeById] Created by user to exclude from transactions
         * @param {number} [excludeFromId] From user to exclude from transactions
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions(fromId?: number, createdById?: number, toId?: number, excludeById?: number, excludeFromId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTransactions(fromId, createdById, toId, excludeById, excludeFromId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.getAllTransactions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleTransaction(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleTransaction(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.getSingleTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transactionRequest The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction(id: number, transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction(id, transactionRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.updateTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transactionRequest The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateTransaction(transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateTransaction(transactionRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.validateTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new transaction
         * @param {TransactionRequest} transactionRequest The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(transactionRequest: TransactionRequest, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.createTransaction(transactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions
         * @param {number} [excludeById] Created by user to exclude from transactions
         * @param {number} [excludeFromId] From user to exclude from transactions
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(fromId?: number, createdById?: number, toId?: number, excludeById?: number, excludeFromId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse> {
            return localVarFp.getAllTransactions(fromId, createdById, toId, excludeById, excludeFromId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction(id: number, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.getSingleTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transactionRequest The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id: number, transactionRequest: TransactionRequest, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.updateTransaction(id, transactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transactionRequest The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction(transactionRequest: TransactionRequest, options?: any): AxiosPromise<boolean> {
            return localVarFp.validateTransaction(transactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new transaction
     * @param {TransactionRequest} transactionRequest The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransaction(transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createTransaction(transactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransaction(id: number, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).deleteTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions
     * @param {number} [excludeById] Created by user to exclude from transactions
     * @param {number} [excludeFromId] From user to exclude from transactions
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getAllTransactions(fromId?: number, createdById?: number, toId?: number, excludeById?: number, excludeFromId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getAllTransactions(fromId, createdById, toId, excludeById, excludeFromId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getSingleTransaction(id: number, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getSingleTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transactionRequest The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransaction(id: number, transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).updateTransaction(id, transactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transactionRequest The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public validateTransaction(transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).validateTransaction(transactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post a new transfer.
         * @param {TransferRequest} transferRequest The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: async (transferRequest: TransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferRequest' is not null or undefined
            assertParamExists('createTransfer', 'transferRequest', transferRequest)
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleTransfer', 'id', id)
            const localVarPath = `/transfers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post a new transfer.
         * @param {TransferRequest} transferRequest The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransfer(transferRequest: TransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(transferRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransfersApi.createTransfer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransfers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransferResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTransfers(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransfersApi.getAllTransfers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleTransfer(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleTransfer(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransfersApi.getSingleTransfer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         * 
         * @summary Post a new transfer.
         * @param {TransferRequest} transferRequest The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(transferRequest: TransferRequest, options?: any): AxiosPromise<TransferResponse> {
            return localVarFp.createTransfer(transferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers(take?: number, skip?: number, options?: any): AxiosPromise<Array<TransferResponse>> {
            return localVarFp.getAllTransfers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer(id: number, options?: any): AxiosPromise<TransferResponse> {
            return localVarFp.getSingleTransfer(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI {
    /**
     * 
     * @summary Post a new transfer.
     * @param {TransferRequest} transferRequest The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public createTransfer(transferRequest: TransferRequest, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).createTransfer(transferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getAllTransfers(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getAllTransfers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getSingleTransfer(id: number, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getSingleTransfer(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos: async (acceptTosRequest: AcceptTosRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptTosRequest' is not null or undefined
            assertParamExists('acceptTos', 'acceptTosRequest', acceptTosRequest)
            const localVarPath = `/users/acceptTos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptTosRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a role to a user
         * @param {number} id The id of the user
         * @param {AddRoleRequest} addRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRole: async (id: number, addRoleRequest: AddRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addUserRole', 'id', id)
            // verify required parameter 'addRoleRequest' is not null or undefined
            assertParamExists('addUserRole', 'addRoleRequest', addRoleRequest)
            const localVarPath = `/users/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authenticateAs', 'id', id)
            const localVarPath = `/users/{id}/authenticate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserRequest} createUserRequest The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserKey', 'id', id)
            const localVarPath = `/users/{id}/authenticator/key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserNfc', 'id', id)
            const localVarPath = `/users/{id}/authenticator/nfc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a role from a user
         * @param {number} id The id of the user
         * @param {number} roleId The id of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRole: async (id: number, roleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserRole', 'id', id)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteUserRole', 'roleId', roleId)
            const localVarPath = `/users/{id}/roles/{roleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user using the nfc code
         * @param {string} nfcCode The nfc code of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserNfc: async (nfcCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nfcCode' is not null or undefined
            assertParamExists('findUserNfc', 'nfcCode', nfcCode)
            const localVarPath = `/users/nfc/{nfcCode}`
                .replace(`{${"nfcCode"}}`, encodeURIComponent(String(nfcCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (ofAge !== undefined) {
                localVarQueryParameter['ofAge'] = ofAge;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType: async (userType: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userType' is not null or undefined
            assertParamExists('getAllUsersOfUserType', 'userType', userType)
            const localVarPath = `/users/usertype/{userType}`
                .replace(`{${"userType"}}`, encodeURIComponent(String(userType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIndividualUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganMembers', 'id', id)
            const localVarPath = `/users/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserAuthenticatable', 'id', id)
            const localVarPath = `/users/{id}/authenticate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserRoles', 'id', id)
            const localVarPath = `/users/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersContainers', 'id', id)
            const localVarPath = `/users/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all financial mutations of a user (from or to).
         * @param {number} id The id of the user to get the mutations from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations: async (id: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersFinancialMutations', 'id', id)
            const localVarPath = `/users/{id}/financialmutations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersPointsOfSale', 'id', id)
            const localVarPath = `/users/{id}/pointsofsale`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersProcessingDeposits', 'id', id)
            const localVarPath = `/users/{id}/deposits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersProducts', 'id', id)
            const localVarPath = `/users/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get purchase report pdf for the given user
         * @param {number} id The id of the user to get the purchase report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {GetUsersPurchaseReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPurchaseReportPdf: async (id: number, fromDate: string, tillDate: string, fileType?: GetUsersPurchaseReportPdfFileTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersPurchaseReportPdf', 'id', id)
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('getUsersPurchaseReportPdf', 'fromDate', fromDate)
            // verify required parameter 'tillDate' is not null or undefined
            assertParamExists('getUsersPurchaseReportPdf', 'tillDate', tillDate)
            const localVarPath = `/users/{id}/transactions/purchases/report/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get purchases report for the given user
         * @param {number} id The id of the user to get the purchases report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPurchasesReport: async (id: number, fromDate: string, tillDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersPurchasesReport', 'id', id)
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('getUsersPurchasesReport', 'fromDate', fromDate)
            // verify required parameter 'tillDate' is not null or undefined
            assertParamExists('getUsersPurchasesReport', 'tillDate', tillDate)
            const localVarPath = `/users/{id}/transactions/purchases/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSalesReport: async (id: number, fromDate: string, tillDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersSalesReport', 'id', id)
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('getUsersSalesReport', 'fromDate', fromDate)
            // verify required parameter 'tillDate' is not null or undefined
            assertParamExists('getUsersSalesReport', 'tillDate', tillDate)
            const localVarPath = `/users/{id}/transactions/sales/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {string} [description] Description of the report
         * @param {GetUsersSalesReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSalesReportPdf: async (id: number, fromDate: string, tillDate: string, description?: string, fileType?: GetUsersSalesReportPdfFileTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersSalesReportPdf', 'id', id)
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('getUsersSalesReportPdf', 'fromDate', fromDate)
            // verify required parameter 'tillDate' is not null or undefined
            assertParamExists('getUsersSalesReportPdf', 'tillDate', tillDate)
            const localVarPath = `/users/{id}/transactions/sales/report/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transactions from a user.
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions: async (id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersTransactions', 'id', id)
            const localVarPath = `/users/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (productRevision !== undefined) {
                localVarQueryParameter['productRevision'] = productRevision;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUsersTransactionsReport: async (id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersTransactionsReport', 'id', id)
            const localVarPath = `/users/{id}/transactions/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (exclusiveToId !== undefined) {
                localVarQueryParameter['exclusiveToId'] = exclusiveToId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transfers to or from an user.
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers: async (id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersTransfers', 'id', id)
            const localVarPath = `/users/{id}/transfers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (id2 !== undefined) {
                localVarQueryParameter['id'] = id2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} updateUserRequest The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: number, updateUserRequest: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('updateUser', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserKey', 'id', id)
            const localVarPath = `/users/{id}/authenticator/key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} updateLocalRequest    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword: async (id: number, updateLocalRequest: UpdateLocalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserLocalPassword', 'id', id)
            // verify required parameter 'updateLocalRequest' is not null or undefined
            assertParamExists('updateUserLocalPassword', 'updateLocalRequest', updateLocalRequest)
            const localVarPath = `/users/{id}/authenticator/local`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLocalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc: async (id: number, updateNfcRequest: UpdateNfcRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserNfc', 'id', id)
            // verify required parameter 'updateNfcRequest' is not null or undefined
            assertParamExists('updateUserNfc', 'updateNfcRequest', updateNfcRequest)
            const localVarPath = `/users/{id}/authenticator/nfc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNfcRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin: async (id: number, updatePinRequest: UpdatePinRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserPin', 'id', id)
            // verify required parameter 'updatePinRequest' is not null or undefined
            assertParamExists('updateUserPin', 'updatePinRequest', updatePinRequest)
            const localVarPath = `/users/{id}/authenticator/pin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {WaiveFinesRequest} [waiveFinesRequest] Optional body, see https://github.com/GEWIS/sudosos-backend/pull/344
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waiveUserFines: async (id: number, waiveFinesRequest?: WaiveFinesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('waiveUserFines', 'id', id)
            const localVarPath = `/users/{id}/fines/waive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(waiveFinesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptTos(acceptTosRequest: AcceptTosRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptTos(acceptTosRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.acceptTos']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Adds a role to a user
         * @param {number} id The id of the user
         * @param {AddRoleRequest} addRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserRole(id: number, addRoleRequest: AddRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserRole(id, addRoleRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.addUserRole']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateAs(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateAs(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.authenticateAs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserRequest} createUserRequest The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.createUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.deleteUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserKey(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserKey(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.deleteUserKey']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserNfc(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserNfc(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.deleteUserNfc']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a role from a user
         * @param {number} id The id of the user
         * @param {number} roleId The id of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserRole(id: number, roleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserRole(id, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.deleteUserRole']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user using the nfc code
         * @param {string} nfcCode The nfc code of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserNfc(nfcCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserNfc(nfcCode, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.findUserNfc']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(take, skip, search, active, ofAge, id, type, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getAllUsers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsersOfUserType(userType, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getAllUsersOfUserType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndividualUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndividualUser(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getIndividualUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganMembers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganMembers(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getOrganMembers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAuthenticatable(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAuthenticatable(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUserAuthenticatable']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoles(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleWithPermissionsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoles(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUserRoles']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersContainers(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersContainers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all financial mutations of a user (from or to).
         * @param {number} id The id of the user to get the mutations from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersFinancialMutations(id: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFinancialMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersFinancialMutations(id, fromDate, tillDate, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersFinancialMutations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPointOfSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersPointsOfSale(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersPointsOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersProcessingDeposits(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersProcessingDeposits(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersProcessingDeposits']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersProducts(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersProducts(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersProducts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get purchase report pdf for the given user
         * @param {number} id The id of the user to get the purchase report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {GetUsersPurchaseReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersPurchaseReportPdf(id: number, fromDate: string, tillDate: string, fileType?: GetUsersPurchaseReportPdfFileTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersPurchaseReportPdf(id, fromDate, tillDate, fileType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersPurchaseReportPdf']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get purchases report for the given user
         * @param {number} id The id of the user to get the purchases report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersPurchasesReport(id: number, fromDate: string, tillDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersPurchasesReport(id, fromDate, tillDate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersPurchasesReport']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersSalesReport(id: number, fromDate: string, tillDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersSalesReport(id, fromDate, tillDate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersSalesReport']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {string} [description] Description of the report
         * @param {GetUsersSalesReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersSalesReportPdf(id: number, fromDate: string, tillDate: string, description?: string, fileType?: GetUsersSalesReportPdfFileTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersSalesReportPdf(id, fromDate, tillDate, description, fileType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersSalesReportPdf']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get transactions from a user.
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersTransactions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionReportResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersTransactionsReport']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get transfers to or from an user.
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTransfers(id, take, skip, fromId, toId, id2, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersTransfers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} updateUserRequest The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: number, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, updateUserRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.updateUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserKey(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserKey(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.updateUserKey']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} updateLocalRequest    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserLocalPassword(id: number, updateLocalRequest: UpdateLocalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserLocalPassword(id, updateLocalRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.updateUserLocalPassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserNfc(id: number, updateNfcRequest: UpdateNfcRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserNfc(id, updateNfcRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.updateUserNfc']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPin(id: number, updatePinRequest: UpdatePinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPin(id, updatePinRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.updateUserPin']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {WaiveFinesRequest} [waiveFinesRequest] Optional body, see https://github.com/GEWIS/sudosos-backend/pull/344
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waiveUserFines(id: number, waiveFinesRequest?: WaiveFinesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.waiveUserFines(id, waiveFinesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.waiveUserFines']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos(acceptTosRequest: AcceptTosRequest, options?: any): AxiosPromise<void> {
            return localVarFp.acceptTos(acceptTosRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a role to a user
         * @param {number} id The id of the user
         * @param {AddRoleRequest} addRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRole(id: number, addRoleRequest: AddRoleRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addUserRole(id, addRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs(id: number, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.authenticateAs(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserRequest} createUserRequest The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserNfc(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a role from a user
         * @param {number} id The id of the user
         * @param {number} roleId The id of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRole(id: number, roleId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserRole(id, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user using the nfc code
         * @param {string} nfcCode The nfc code of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserNfc(nfcCode: string, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.findUserNfc(nfcCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options?: any): AxiosPromise<PaginatedUserResponse> {
            return localVarFp.getAllUsers(take, skip, search, active, ofAge, id, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedUserResponse> {
            return localVarFp.getAllUsersOfUserType(userType, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser(id: number, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getIndividualUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedUserResponse> {
            return localVarFp.getOrganMembers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable(id: number, options?: any): AxiosPromise<Array<UserResponse>> {
            return localVarFp.getUserAuthenticatable(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(id: number, options?: any): AxiosPromise<Array<RoleWithPermissionsResponse>> {
            return localVarFp.getUserRoles(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getUsersContainers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all financial mutations of a user (from or to).
         * @param {number} id The id of the user to get the mutations from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations(id: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedFinancialMutationResponse> {
            return localVarFp.getUsersFinancialMutations(id, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedPointOfSaleResponse> {
            return localVarFp.getUsersPointsOfSale(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits(id: number, options?: any): AxiosPromise<Array<RoleResponse>> {
            return localVarFp.getUsersProcessingDeposits(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse> {
            return localVarFp.getUsersProducts(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get purchase report pdf for the given user
         * @param {number} id The id of the user to get the purchase report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {GetUsersPurchaseReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPurchaseReportPdf(id: number, fromDate: string, tillDate: string, fileType?: GetUsersPurchaseReportPdfFileTypeEnum, options?: any): AxiosPromise<string> {
            return localVarFp.getUsersPurchaseReportPdf(id, fromDate, tillDate, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get purchases report for the given user
         * @param {number} id The id of the user to get the purchases report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPurchasesReport(id: number, fromDate: string, tillDate: string, options?: any): AxiosPromise<ReportResponse> {
            return localVarFp.getUsersPurchasesReport(id, fromDate, tillDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSalesReport(id: number, fromDate: string, tillDate: string, options?: any): AxiosPromise<ReportResponse> {
            return localVarFp.getUsersSalesReport(id, fromDate, tillDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {string} [description] Description of the report
         * @param {GetUsersSalesReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSalesReportPdf(id: number, fromDate: string, tillDate: string, description?: string, fileType?: GetUsersSalesReportPdfFileTypeEnum, options?: any): AxiosPromise<string> {
            return localVarFp.getUsersSalesReportPdf(id, fromDate, tillDate, description, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transactions from a user.
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse> {
            return localVarFp.getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: any): AxiosPromise<Array<TransactionReportResponse>> {
            return localVarFp.getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transfers to or from an user.
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: any): AxiosPromise<PaginatedTransferResponse> {
            return localVarFp.getUsersTransfers(id, take, skip, fromId, toId, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} updateUserRequest The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, updateUserRequest: UpdateUserRequest, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.updateUser(id, updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey(id: number, options?: any): AxiosPromise<UpdateKeyResponse> {
            return localVarFp.updateUserKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} updateLocalRequest    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword(id: number, updateLocalRequest: UpdateLocalRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserLocalPassword(id, updateLocalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc(id: number, updateNfcRequest: UpdateNfcRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserNfc(id, updateNfcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin(id: number, updatePinRequest: UpdatePinRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPin(id, updatePinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {WaiveFinesRequest} [waiveFinesRequest] Optional body, see https://github.com/GEWIS/sudosos-backend/pull/344
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waiveUserFines(id: number, waiveFinesRequest?: WaiveFinesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.waiveUserFines(id, waiveFinesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public acceptTos(acceptTosRequest: AcceptTosRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).acceptTos(acceptTosRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a role to a user
     * @param {number} id The id of the user
     * @param {AddRoleRequest} addRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUserRole(id: number, addRoleRequest: AddRoleRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).addUserRole(id, addRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public authenticateAs(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).authenticateAs(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user
     * @param {CreateUserRequest} createUserRequest The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserKey(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserNfc(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserNfc(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a role from a user
     * @param {number} id The id of the user
     * @param {number} roleId The id of the role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserRole(id: number, roleId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserRole(id, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user using the nfc code
     * @param {string} nfcCode The nfc code of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUserNfc(nfcCode: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUserNfc(nfcCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getAllUsers(take, skip, search, active, ofAge, id, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getAllUsersOfUserType(userType, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getIndividualUser(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getIndividualUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an organs members
     * @param {number} id The id of the user
     * @param {number} [take] How many members the endpoint should return
     * @param {number} [skip] How many members should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOrganMembers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getOrganMembers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserAuthenticatable(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserAuthenticatable(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserRoles(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserRoles(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersContainers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all financial mutations of a user (from or to).
     * @param {number} id The id of the user to get the mutations from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersFinancialMutations(id: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersFinancialMutations(id, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersPointsOfSale(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersProcessingDeposits(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersProcessingDeposits(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersProducts(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersProducts(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get purchase report pdf for the given user
     * @param {number} id The id of the user to get the purchase report for
     * @param {string} fromDate Start date for selected purchases (inclusive)
     * @param {string} tillDate End date for selected purchases (exclusive)
     * @param {GetUsersPurchaseReportPdfFileTypeEnum} [fileType] The file type of the report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersPurchaseReportPdf(id: number, fromDate: string, tillDate: string, fileType?: GetUsersPurchaseReportPdfFileTypeEnum, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersPurchaseReportPdf(id, fromDate, tillDate, fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get purchases report for the given user
     * @param {number} id The id of the user to get the purchases report for
     * @param {string} fromDate Start date for selected purchases (inclusive)
     * @param {string} tillDate End date for selected purchases (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersPurchasesReport(id: number, fromDate: string, tillDate: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersPurchasesReport(id, fromDate, tillDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get sales report for the given user
     * @param {number} id The id of the user to get the sales report for
     * @param {string} fromDate Start date for selected sales (inclusive)
     * @param {string} tillDate End date for selected sales (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersSalesReport(id: number, fromDate: string, tillDate: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersSalesReport(id, fromDate, tillDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get sales report for the given user
     * @param {number} id The id of the user to get the sales report for
     * @param {string} fromDate Start date for selected sales (inclusive)
     * @param {string} tillDate End date for selected sales (exclusive)
     * @param {string} [description] Description of the report
     * @param {GetUsersSalesReportPdfFileTypeEnum} [fileType] The file type of the report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersSalesReportPdf(id: number, fromDate: string, tillDate: string, description?: string, fileType?: GetUsersSalesReportPdfFileTypeEnum, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersSalesReportPdf(id, fromDate, tillDate, description, fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transactions from a user.
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transfers to or from an user.
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTransfers(id, take, skip, fromId, toId, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} updateUserRequest The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: number, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(id, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserKey(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} updateLocalRequest    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserLocalPassword(id: number, updateLocalRequest: UpdateLocalRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserLocalPassword(id, updateLocalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserNfc(id: number, updateNfcRequest: UpdateNfcRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserNfc(id, updateNfcRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPin(id: number, updatePinRequest: UpdatePinRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPin(id, updatePinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Waive all given user\'s fines
     * @param {number} id The id of the user
     * @param {WaiveFinesRequest} [waiveFinesRequest] Optional body, see https://github.com/GEWIS/sudosos-backend/pull/344
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public waiveUserFines(id: number, waiveFinesRequest?: WaiveFinesRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).waiveUserFines(id, waiveFinesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllUsersTypeEnum = {
    Member: 'MEMBER',
    Organ: 'ORGAN',
    Voucher: 'VOUCHER',
    LocalUser: 'LOCAL_USER',
    LocalAdmin: 'LOCAL_ADMIN',
    Invoice: 'INVOICE',
    AutomaticInvoice: 'AUTOMATIC_INVOICE'
} as const;
export type GetAllUsersTypeEnum = typeof GetAllUsersTypeEnum[keyof typeof GetAllUsersTypeEnum];
/**
 * @export
 */
export const GetUsersPurchaseReportPdfFileTypeEnum = {
    Pdf: 'PDF',
    Tex: 'TEX'
} as const;
export type GetUsersPurchaseReportPdfFileTypeEnum = typeof GetUsersPurchaseReportPdfFileTypeEnum[keyof typeof GetUsersPurchaseReportPdfFileTypeEnum];
/**
 * @export
 */
export const GetUsersSalesReportPdfFileTypeEnum = {
    Pdf: 'PDF',
    Tex: 'TEX'
} as const;
export type GetUsersSalesReportPdfFileTypeEnum = typeof GetUsersSalesReportPdfFileTypeEnum[keyof typeof GetUsersSalesReportPdfFileTypeEnum];


/**
 * VatGroupsApi - axios parameter creator
 * @export
 */
export const VatGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new VAT group
         * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup: async (vatGroupRequest: VatGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vatGroupRequest' is not null or undefined
            assertParamExists('createVatGroup', 'vatGroupRequest', vatGroupRequest)
            const localVarPath = `/vatgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vatGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups: async (vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vatgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vatGroupId !== undefined) {
                localVarQueryParameter['vatGroupId'] = vatGroupId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (percentage !== undefined) {
                localVarQueryParameter['percentage'] = percentage;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleVatGroup', 'id', id)
            const localVarPath = `/vatgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts: async (year: number, period: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            assertParamExists('getVatDeclarationAmounts', 'year', year)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getVatDeclarationAmounts', 'period', period)
            const localVarPath = `/vatgroups/declaration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup: async (id: number, updateVatGroupRequest: UpdateVatGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVatGroup', 'id', id)
            // verify required parameter 'updateVatGroupRequest' is not null or undefined
            assertParamExists('updateVatGroup', 'updateVatGroupRequest', updateVatGroupRequest)
            const localVarPath = `/vatgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVatGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VatGroupsApi - functional programming interface
 * @export
 */
export const VatGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VatGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new VAT group
         * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVatGroup(vatGroupRequest: VatGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVatGroup(vatGroupRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VatGroupsApi.createVatGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVatGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VatGroupsApi.getAllVatGroups']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleVatGroup(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleVatGroup(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VatGroupsApi.getSingleVatGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVatDeclarationAmounts(year: number, period: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVatGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVatDeclarationAmounts(year, period, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VatGroupsApi.getVatDeclarationAmounts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVatGroup(id: number, updateVatGroupRequest: UpdateVatGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVatGroup(id, updateVatGroupRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VatGroupsApi.updateVatGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * VatGroupsApi - factory interface
 * @export
 */
export const VatGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VatGroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new VAT group
         * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup(vatGroupRequest: VatGroupRequest, options?: any): AxiosPromise<VatGroupResponse> {
            return localVarFp.createVatGroup(vatGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedVatGroupResponse> {
            return localVarFp.getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup(id: number, options?: any): AxiosPromise<VatGroupResponse> {
            return localVarFp.getSingleVatGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts(year: number, period: string, options?: any): AxiosPromise<PaginatedVatGroupResponse> {
            return localVarFp.getVatDeclarationAmounts(year, period, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup(id: number, updateVatGroupRequest: UpdateVatGroupRequest, options?: any): AxiosPromise<VatGroupResponse> {
            return localVarFp.updateVatGroup(id, updateVatGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VatGroupsApi - object-oriented interface
 * @export
 * @class VatGroupsApi
 * @extends {BaseAPI}
 */
export class VatGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new VAT group
     * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public createVatGroup(vatGroupRequest: VatGroupRequest, options?: RawAxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).createVatGroup(vatGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public getSingleVatGroup(id: number, options?: RawAxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).getSingleVatGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public getVatDeclarationAmounts(year: number, period: string, options?: RawAxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).getVatDeclarationAmounts(year, period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public updateVatGroup(id: number, updateVatGroupRequest: UpdateVatGroupRequest, options?: RawAxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).updateVatGroup(id, updateVatGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VouchergroupsApi - axios parameter creator
 * @export
 */
export const VouchergroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new voucher group
         * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVouchergroup: async (voucherGroupRequest: VoucherGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voucherGroupRequest' is not null or undefined
            assertParamExists('createVouchergroup', 'voucherGroupRequest', voucherGroupRequest)
            const localVarPath = `/vouchergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voucherGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVouchergroups: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vouchergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchergroupId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVouchergroupId', 'id', id)
            const localVarPath = `/vouchergroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherGroup: async (id: number, voucherGroupRequest: VoucherGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVoucherGroup', 'id', id)
            // verify required parameter 'voucherGroupRequest' is not null or undefined
            assertParamExists('updateVoucherGroup', 'voucherGroupRequest', voucherGroupRequest)
            const localVarPath = `/vouchergroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voucherGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VouchergroupsApi - functional programming interface
 * @export
 */
export const VouchergroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VouchergroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new voucher group
         * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVouchergroup(voucherGroupRequest: VoucherGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVouchergroup(voucherGroupRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VouchergroupsApi.createVouchergroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVouchergroups(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVouchergroups(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VouchergroupsApi.getAllVouchergroups']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVouchergroupId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVouchergroupId(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VouchergroupsApi.getVouchergroupId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVoucherGroup(id: number, voucherGroupRequest: VoucherGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoucherGroup(id, voucherGroupRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VouchergroupsApi.updateVoucherGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * VouchergroupsApi - factory interface
 * @export
 */
export const VouchergroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VouchergroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new voucher group
         * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVouchergroup(voucherGroupRequest: VoucherGroupRequest, options?: any): AxiosPromise<VoucherGroupResponse> {
            return localVarFp.createVouchergroup(voucherGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVouchergroups(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedVoucherGroupResponse> {
            return localVarFp.getAllVouchergroups(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchergroupId(id: number, options?: any): AxiosPromise<VoucherGroupResponse> {
            return localVarFp.getVouchergroupId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherGroup(id: number, voucherGroupRequest: VoucherGroupRequest, options?: any): AxiosPromise<VoucherGroupResponse> {
            return localVarFp.updateVoucherGroup(id, voucherGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VouchergroupsApi - object-oriented interface
 * @export
 * @class VouchergroupsApi
 * @extends {BaseAPI}
 */
export class VouchergroupsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new voucher group
     * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public createVouchergroup(voucherGroupRequest: VoucherGroupRequest, options?: RawAxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).createVouchergroup(voucherGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing voucher groups
     * @param {number} [take] How many voucher groups the endpoint should return
     * @param {number} [skip] How many voucher groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public getAllVouchergroups(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).getAllVouchergroups(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested voucher group
     * @param {number} id The id of the voucher group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public getVouchergroupId(id: number, options?: RawAxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).getVouchergroupId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the requested voucher group
     * @param {number} id The id of the voucher group which should be updated
     * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public updateVoucherGroup(id: number, voucherGroupRequest: VoucherGroupRequest, options?: RawAxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).updateVoucherGroup(id, voucherGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WriteoffsApi - axios parameter creator
 * @export
 */
export const WriteoffsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new write-off in the system. Creating a write-off will also close and delete the user\'s account.
         * @param {WriteOffRequest} writeOffRequest New write off
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWriteOff: async (writeOffRequest: WriteOffRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'writeOffRequest' is not null or undefined
            assertParamExists('createWriteOff', 'writeOffRequest', writeOffRequest)
            const localVarPath = `/writeoffs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(writeOffRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all write-offs in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [amount] Filter on the amount of the write-off
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {string} [fromDate] Start date for selected write-offs (inclusive)
         * @param {string} [tillDate] End date for selected write-offs (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWriteOffs: async (toId?: number, amount?: number, take?: number, skip?: number, fromDate?: string, tillDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/writeoffs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single write-off
         * @param {number} id The ID of the write-off object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWriteOff: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleWriteOff', 'id', id)
            const localVarPath = `/writeoffs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a write-off pdf
         * @param {number} id The ID of the write-off object that should be returned
         * @param {boolean} [force] Whether to force regeneration of the pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWriteOffPdf: async (id: number, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWriteOffPdf', 'id', id)
            const localVarPath = `/writeoffs/{id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WriteoffsApi - functional programming interface
 * @export
 */
export const WriteoffsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WriteoffsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new write-off in the system. Creating a write-off will also close and delete the user\'s account.
         * @param {WriteOffRequest} writeOffRequest New write off
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWriteOff(writeOffRequest: WriteOffRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WriteOffResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWriteOff(writeOffRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WriteoffsApi.createWriteOff']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all write-offs in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [amount] Filter on the amount of the write-off
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {string} [fromDate] Start date for selected write-offs (inclusive)
         * @param {string} [tillDate] End date for selected write-offs (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWriteOffs(toId?: number, amount?: number, take?: number, skip?: number, fromDate?: string, tillDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWriteOffResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWriteOffs(toId, amount, take, skip, fromDate, tillDate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WriteoffsApi.getAllWriteOffs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single write-off
         * @param {number} id The ID of the write-off object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleWriteOff(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WriteOffResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleWriteOff(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WriteoffsApi.getSingleWriteOff']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a write-off pdf
         * @param {number} id The ID of the write-off object that should be returned
         * @param {boolean} [force] Whether to force regeneration of the pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWriteOffPdf(id: number, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PdfUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWriteOffPdf(id, force, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WriteoffsApi.getWriteOffPdf']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * WriteoffsApi - factory interface
 * @export
 */
export const WriteoffsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WriteoffsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new write-off in the system. Creating a write-off will also close and delete the user\'s account.
         * @param {WriteOffRequest} writeOffRequest New write off
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWriteOff(writeOffRequest: WriteOffRequest, options?: any): AxiosPromise<WriteOffResponse> {
            return localVarFp.createWriteOff(writeOffRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all write-offs in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [amount] Filter on the amount of the write-off
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {string} [fromDate] Start date for selected write-offs (inclusive)
         * @param {string} [tillDate] End date for selected write-offs (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWriteOffs(toId?: number, amount?: number, take?: number, skip?: number, fromDate?: string, tillDate?: string, options?: any): AxiosPromise<PaginatedWriteOffResponse> {
            return localVarFp.getAllWriteOffs(toId, amount, take, skip, fromDate, tillDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single write-off
         * @param {number} id The ID of the write-off object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWriteOff(id: number, options?: any): AxiosPromise<WriteOffResponse> {
            return localVarFp.getSingleWriteOff(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a write-off pdf
         * @param {number} id The ID of the write-off object that should be returned
         * @param {boolean} [force] Whether to force regeneration of the pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWriteOffPdf(id: number, force?: boolean, options?: any): AxiosPromise<PdfUrlResponse> {
            return localVarFp.getWriteOffPdf(id, force, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WriteoffsApi - object-oriented interface
 * @export
 * @class WriteoffsApi
 * @extends {BaseAPI}
 */
export class WriteoffsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new write-off in the system. Creating a write-off will also close and delete the user\'s account.
     * @param {WriteOffRequest} writeOffRequest New write off
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteoffsApi
     */
    public createWriteOff(writeOffRequest: WriteOffRequest, options?: RawAxiosRequestConfig) {
        return WriteoffsApiFp(this.configuration).createWriteOff(writeOffRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all write-offs in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [amount] Filter on the amount of the write-off
     * @param {number} [take] Number of write-offs to return
     * @param {number} [skip] Number of write-offs to skip
     * @param {string} [fromDate] Start date for selected write-offs (inclusive)
     * @param {string} [tillDate] End date for selected write-offs (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteoffsApi
     */
    public getAllWriteOffs(toId?: number, amount?: number, take?: number, skip?: number, fromDate?: string, tillDate?: string, options?: RawAxiosRequestConfig) {
        return WriteoffsApiFp(this.configuration).getAllWriteOffs(toId, amount, take, skip, fromDate, tillDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single write-off
     * @param {number} id The ID of the write-off object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteoffsApi
     */
    public getSingleWriteOff(id: number, options?: RawAxiosRequestConfig) {
        return WriteoffsApiFp(this.configuration).getSingleWriteOff(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a write-off pdf
     * @param {number} id The ID of the write-off object that should be returned
     * @param {boolean} [force] Whether to force regeneration of the pdf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteoffsApi
     */
    public getWriteOffPdf(id: number, force?: boolean, options?: RawAxiosRequestConfig) {
        return WriteoffsApiFp(this.configuration).getWriteOffPdf(id, force, options).then((request) => request(this.axios, this.basePath));
    }
}



