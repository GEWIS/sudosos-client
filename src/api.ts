/* tslint:disable */
/* eslint-disable */
/**
 * sudosos-back-end
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AcceptTosRequest
 */
export interface AcceptTosRequest {
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof AcceptTosRequest
     */
    'extensiveDataProcessing': boolean;
}
/**
 * 
 * @export
 * @interface ActionResponse
 */
export interface ActionResponse {
    /**
     * The name of the action performed on the entity.
     * @type {string}
     * @memberof ActionResponse
     */
    'action'?: string;
    /**
     * 
     * @type {Array<RelationResponse>}
     * @memberof ActionResponse
     */
    'relations'?: Array<RelationResponse>;
}
/**
 * 
 * @export
 * @interface AssignedRole
 */
export interface AssignedRole {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof AssignedRole
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof AssignedRole
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof AssignedRole
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof AssignedRole
     */
    'user': User;
    /**
     * The name of the role
     * @type {string}
     * @memberof AssignedRole
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface AssignedRoleAllOf
 */
export interface AssignedRoleAllOf {
    /**
     * 
     * @type {User}
     * @memberof AssignedRoleAllOf
     */
    'user': User;
    /**
     * The name of the role
     * @type {string}
     * @memberof AssignedRoleAllOf
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface AuthenticationEanRequest
 */
export interface AuthenticationEanRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationEanRequest
     */
    'eanCode': string;
}
/**
 * 
 * @export
 * @interface AuthenticationKeyRequest
 */
export interface AuthenticationKeyRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationKeyRequest
     */
    'userId': number;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationKeyRequest
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface AuthenticationLDAPRequest
 */
export interface AuthenticationLDAPRequest {
    /**
     * The AD account name to authenticate
     * @type {string}
     * @memberof AuthenticationLDAPRequest
     */
    'accountName': string;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationLDAPRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationLocalRequest
 */
export interface AuthenticationLocalRequest {
    /**
     * The users mail to authenticate
     * @type {string}
     * @memberof AuthenticationLocalRequest
     */
    'accountMail': string;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationLocalRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationMethod
 */
export interface AuthenticationMethod {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof AuthenticationMethod
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof AuthenticationMethod
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof AuthenticationMethod
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof AuthenticationMethod
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface AuthenticationMethodAllOf
 */
export interface AuthenticationMethodAllOf {
    /**
     * 
     * @type {User}
     * @memberof AuthenticationMethodAllOf
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface AuthenticationMockRequest
 */
export interface AuthenticationMockRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationMockRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationMockRequest
     */
    'nonce': string;
}
/**
 * 
 * @export
 * @interface AuthenticationNfcRequest
 */
export interface AuthenticationNfcRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationNfcRequest
     */
    'nfcCode': string;
}
/**
 * 
 * @export
 * @interface AuthenticationPinRequest
 */
export interface AuthenticationPinRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationPinRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationPinRequest
     */
    'pin': string;
}
/**
 * 
 * @export
 * @interface AuthenticationResetTokenRequest
 */
export interface AuthenticationResetTokenRequest {
    /**
     * The mail of the user
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'accountMail': string;
    /**
     * The reset token passcode
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'token': string;
    /**
     * The new password to set
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     * 
     * @type {UserResponse}
     * @memberof AuthenticationResponse
     */
    'user': UserResponse;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthenticationResponse
     */
    'roles': Array<string>;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof AuthenticationResponse
     */
    'organs': Array<UserResponse>;
    /**
     * The JWT token that can be used as Bearer token for authentication.
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'token': string;
    /**
     * Whether the related user has accepted the Terms of Service  or is not required to.
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'acceptedToS': string;
}
/**
 * 
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Balance
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Balance
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Balance
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof Balance
     */
    'user': User;
    /**
     * 
     * @type {Dinero}
     * @memberof Balance
     */
    'amount': Dinero;
    /**
     * 
     * @type {Transaction}
     * @memberof Balance
     */
    'lastTransaction'?: Transaction;
    /**
     * 
     * @type {Transfer}
     * @memberof Balance
     */
    'lastTransfer'?: Transfer;
}
/**
 * 
 * @export
 * @interface BalanceAllOf
 */
export interface BalanceAllOf {
    /**
     * 
     * @type {User}
     * @memberof BalanceAllOf
     */
    'user': User;
    /**
     * 
     * @type {Dinero}
     * @memberof BalanceAllOf
     */
    'amount': Dinero;
    /**
     * 
     * @type {Transaction}
     * @memberof BalanceAllOf
     */
    'lastTransaction'?: Transaction;
    /**
     * 
     * @type {Transfer}
     * @memberof BalanceAllOf
     */
    'lastTransfer'?: Transfer;
}
/**
 * 
 * @export
 * @interface BalanceResponse
 */
export interface BalanceResponse {
    /**
     * ID of the user this balance belongs to
     * @type {number}
     * @memberof BalanceResponse
     */
    'id': number;
    /**
     * Date at which this user had this balance
     * @type {string}
     * @memberof BalanceResponse
     */
    'date': string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BalanceResponse
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BalanceResponse
     */
    'fine'?: DineroObjectResponse;
    /**
     * Timestamp of the first fine
     * @type {string}
     * @memberof BalanceResponse
     */
    'fineSince'?: string;
    /**
     * The ID of the last transaction that was present when the balance was cached
     * @type {number}
     * @memberof BalanceResponse
     */
    'lastTransactionId'?: number;
    /**
     * The ID of the last transfer that was present when the balance was cached
     * @type {number}
     * @memberof BalanceResponse
     */
    'lastTransferId'?: number;
}
/**
 * 
 * @export
 * @interface Banner
 */
export interface Banner {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Banner
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Banner
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Banner
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Banner
     */
    'id': number;
    /**
     * Name/label of the banner.
     * @type {string}
     * @memberof Banner
     */
    'name'?: string;
    /**
     * How long the banner should be shown (in seconds).
     * @type {number}
     * @memberof Banner
     */
    'duration'?: number;
    /**
     * Whether the banner is active. Overrides start and end date.
     * @type {boolean}
     * @memberof Banner
     */
    'active'?: boolean;
    /**
     * The starting date from which the banner should be shown.
     * @type {string}
     * @memberof Banner
     */
    'startDate'?: string;
    /**
     * The end date from which the banner should no longer be shown.
     * @type {string}
     * @memberof Banner
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface BannerAllOf
 */
export interface BannerAllOf {
    /**
     * Name/label of the banner.
     * @type {string}
     * @memberof BannerAllOf
     */
    'name'?: string;
    /**
     * How long the banner should be shown (in seconds).
     * @type {number}
     * @memberof BannerAllOf
     */
    'duration'?: number;
    /**
     * Whether the banner is active. Overrides start and end date.
     * @type {boolean}
     * @memberof BannerAllOf
     */
    'active'?: boolean;
    /**
     * The starting date from which the banner should be shown.
     * @type {string}
     * @memberof BannerAllOf
     */
    'startDate'?: string;
    /**
     * The end date from which the banner should no longer be shown.
     * @type {string}
     * @memberof BannerAllOf
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface BannerImage
 */
export interface BannerImage {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BannerImage
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BannerImage
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BannerImage
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof BannerImage
     */
    'id': number;
    /**
     * The filename when the file is downloaded
     * @type {string}
     * @memberof BannerImage
     */
    'downloadName': string;
    /**
     * The location of the file, including filename in storage
     * @type {string}
     * @memberof BannerImage
     */
    'location': string;
    /**
     * 
     * @type {User}
     * @memberof BannerImage
     */
    'createdBy': User;
}
/**
 * 
 * @export
 * @interface BannerRequest
 */
export interface BannerRequest {
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerRequest
     */
    'name'?: string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerRequest
     */
    'duration'?: number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerRequest
     */
    'active'?: boolean;
    /**
     * The starting date from which the advertisement should be shown
     * @type {string}
     * @memberof BannerRequest
     */
    'startDate'?: string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerRequest
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface BannerResponse
 */
export interface BannerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BannerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BannerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BannerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BannerResponse
     */
    'version'?: number;
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerResponse
     */
    'name': string;
    /**
     * Location of the image
     * @type {string}
     * @memberof BannerResponse
     */
    'image'?: string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerResponse
     */
    'duration': number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerResponse
     */
    'active': boolean;
    /**
     * The starting date from which the banner should be shown
     * @type {string}
     * @memberof BannerResponse
     */
    'startDate': string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerResponse
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface BannerResponseAllOf
 */
export interface BannerResponseAllOf {
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerResponseAllOf
     */
    'name': string;
    /**
     * Location of the image
     * @type {string}
     * @memberof BannerResponseAllOf
     */
    'image'?: string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerResponseAllOf
     */
    'duration': number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerResponseAllOf
     */
    'active': boolean;
    /**
     * The starting date from which the banner should be shown
     * @type {string}
     * @memberof BannerResponseAllOf
     */
    'startDate': string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerResponseAllOf
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface BaseContainerResponse
 */
export interface BaseContainerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof BaseContainerResponse
     */
    'public': boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'revision'?: number;
}
/**
 * 
 * @export
 * @interface BaseContainerResponseAllOf
 */
export interface BaseContainerResponseAllOf {
    /**
     * The name of the container.
     * @type {string}
     * @memberof BaseContainerResponseAllOf
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof BaseContainerResponseAllOf
     */
    'public': boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof BaseContainerResponseAllOf
     */
    'revision'?: number;
}
/**
 * 
 * @export
 * @interface BaseEntity
 */
export interface BaseEntity {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BaseEntity
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BaseEntity
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BaseEntity
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof BaseEntity
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface BaseEntityAllOf
 */
export interface BaseEntityAllOf {
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof BaseEntityAllOf
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface BaseEntityWithoutId
 */
export interface BaseEntityWithoutId {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BaseEntityWithoutId
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BaseEntityWithoutId
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BaseEntityWithoutId
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface BaseEventAnswerResponse
 */
export interface BaseEventAnswerResponse {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseEventAnswerResponse
     */
    'user': BaseUserResponse;
    /**
     * Filled in availability per slot.
     * @type {string}
     * @memberof BaseEventAnswerResponse
     */
    'availability'?: string;
    /**
     * Whether this user is selected for the shift in the event
     * @type {boolean}
     * @memberof BaseEventAnswerResponse
     */
    'selected': boolean;
}
/**
 * 
 * @export
 * @interface BaseEventResponse
 */
export interface BaseEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseEventResponse
     */
    'version'?: number;
    /**
     * Name of the borrel.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseEventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'endDate': string;
    /**
     * The tpye of event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface BaseEventResponseAllOf
 */
export interface BaseEventResponseAllOf {
    /**
     * Name of the borrel.
     * @type {string}
     * @memberof BaseEventResponseAllOf
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseEventResponseAllOf
     */
    'createdBy': BaseUserResponse;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof BaseEventResponseAllOf
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof BaseEventResponseAllOf
     */
    'endDate': string;
    /**
     * The tpye of event.
     * @type {string}
     * @memberof BaseEventResponseAllOf
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface BaseEventShiftResponse
 */
export interface BaseEventShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseEventShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseEventShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BaseEventShiftResponseAllOf
 */
export interface BaseEventShiftResponseAllOf {
    /**
     * Name of the shift.
     * @type {string}
     * @memberof BaseEventShiftResponseAllOf
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BaseFile
 */
export interface BaseFile {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BaseFile
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BaseFile
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BaseFile
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof BaseFile
     */
    'id': number;
    /**
     * The filename when the file is downloaded
     * @type {string}
     * @memberof BaseFile
     */
    'downloadName': string;
    /**
     * The location of the file, including filename in storage
     * @type {string}
     * @memberof BaseFile
     */
    'location': string;
    /**
     * 
     * @type {User}
     * @memberof BaseFile
     */
    'createdBy': User;
}
/**
 * 
 * @export
 * @interface BaseFileAllOf
 */
export interface BaseFileAllOf {
    /**
     * The filename when the file is downloaded
     * @type {string}
     * @memberof BaseFileAllOf
     */
    'downloadName': string;
    /**
     * The location of the file, including filename in storage
     * @type {string}
     * @memberof BaseFileAllOf
     */
    'location': string;
    /**
     * 
     * @type {User}
     * @memberof BaseFileAllOf
     */
    'createdBy': User;
}
/**
 * 
 * @export
 * @interface BaseFineHandoutEventResponse
 */
export interface BaseFineHandoutEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseFineHandoutEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseFineHandoutEventResponse
     */
    'version'?: number;
    /**
     * Reference date of fines
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'referenceDate': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseFineHandoutEventResponse
     */
    'createdBy': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface BaseFineHandoutEventResponseAllOf
 */
export interface BaseFineHandoutEventResponseAllOf {
    /**
     * Reference date of fines
     * @type {string}
     * @memberof BaseFineHandoutEventResponseAllOf
     */
    'referenceDate': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseFineHandoutEventResponseAllOf
     */
    'createdBy': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface BaseInvoiceResponse
 */
export interface BaseInvoiceResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseInvoiceResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseInvoiceResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseInvoiceResponse
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'description': string;
    /**
     * 
     * @type {InvoiceStatusResponse}
     * @memberof BaseInvoiceResponse
     */
    'currentState': InvoiceStatusResponse;
    /**
     * 
     * @type {TransferResponse}
     * @memberof BaseInvoiceResponse
     */
    'transfer'?: TransferResponse;
}
/**
 * 
 * @export
 * @interface BaseInvoiceResponseAllOf
 */
export interface BaseInvoiceResponseAllOf {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseInvoiceResponseAllOf
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof BaseInvoiceResponseAllOf
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponseAllOf
     */
    'description': string;
    /**
     * 
     * @type {InvoiceStatusResponse}
     * @memberof BaseInvoiceResponseAllOf
     */
    'currentState': InvoiceStatusResponse;
    /**
     * 
     * @type {TransferResponse}
     * @memberof BaseInvoiceResponseAllOf
     */
    'transfer'?: TransferResponse;
}
/**
 * 
 * @export
 * @interface BasePayoutRequestResponse
 */
export interface BasePayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BasePayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BasePayoutRequestResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BasePayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BasePayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BasePayoutRequestResponse
     */
    'amount': DineroObjectResponse;
    /**
     * The current status of the payout request
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface BasePayoutRequestResponseAllOf
 */
export interface BasePayoutRequestResponseAllOf {
    /**
     * The current status of the payout request
     * @type {string}
     * @memberof BasePayoutRequestResponseAllOf
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface BasePointOfSaleResponse
 */
export interface BasePointOfSaleResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BasePointOfSaleResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BasePointOfSaleResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BasePointOfSaleResponseAllOf
 */
export interface BasePointOfSaleResponseAllOf {
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof BasePointOfSaleResponseAllOf
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BaseProductResponse
 */
export interface BaseProductResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseProductResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseProductResponse
     */
    'version'?: number;
    /**
     * The name of the product.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BaseProductResponse
     */
    'priceInclVat': DineroObjectResponse;
    /**
     * 
     * @type {BaseVatGroupResponse}
     * @memberof BaseProductResponse
     */
    'vat': BaseVatGroupResponse;
}
/**
 * 
 * @export
 * @interface BaseProductResponseAllOf
 */
export interface BaseProductResponseAllOf {
    /**
     * The name of the product.
     * @type {string}
     * @memberof BaseProductResponseAllOf
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BaseProductResponseAllOf
     */
    'priceInclVat': DineroObjectResponse;
    /**
     * 
     * @type {BaseVatGroupResponse}
     * @memberof BaseProductResponseAllOf
     */
    'vat': BaseVatGroupResponse;
}
/**
 * 
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseResponse
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface BaseTransactionResponse
 */
export interface BaseTransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseTransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseTransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseTransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseTransactionResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseTransactionResponse
     */
    'from': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseTransactionResponse
     */
    'createdBy'?: BaseUserResponse;
    /**
     * 
     * @type {BasePointOfSaleResponse}
     * @memberof BaseTransactionResponse
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     * 
     * @type {Dinero}
     * @memberof BaseTransactionResponse
     */
    'value': Dinero;
}
/**
 * 
 * @export
 * @interface BaseTransactionResponseAllOf
 */
export interface BaseTransactionResponseAllOf {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseTransactionResponseAllOf
     */
    'from': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseTransactionResponseAllOf
     */
    'createdBy'?: BaseUserResponse;
    /**
     * 
     * @type {BasePointOfSaleResponse}
     * @memberof BaseTransactionResponseAllOf
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     * 
     * @type {Dinero}
     * @memberof BaseTransactionResponseAllOf
     */
    'value': Dinero;
}
/**
 * 
 * @export
 * @interface BaseUserResponse
 */
export interface BaseUserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseUserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseUserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof BaseUserResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof BaseUserResponse
     */
    'nickname'?: string;
}
/**
 * 
 * @export
 * @interface BaseUserResponseAllOf
 */
export interface BaseUserResponseAllOf {
    /**
     * The name of the user.
     * @type {string}
     * @memberof BaseUserResponseAllOf
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof BaseUserResponseAllOf
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof BaseUserResponseAllOf
     */
    'nickname'?: string;
}
/**
 * 
 * @export
 * @interface BaseVatGroupResponse
 */
export interface BaseVatGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseVatGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseVatGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'version'?: number;
    /**
     * Percentage of VAT
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'percentage': number;
    /**
     * Whether VAT should be hidden
     * @type {boolean}
     * @memberof BaseVatGroupResponse
     */
    'hidden': boolean;
}
/**
 * 
 * @export
 * @interface BaseVatGroupResponseAllOf
 */
export interface BaseVatGroupResponseAllOf {
    /**
     * Percentage of VAT
     * @type {number}
     * @memberof BaseVatGroupResponseAllOf
     */
    'percentage': number;
    /**
     * Whether VAT should be hidden
     * @type {boolean}
     * @memberof BaseVatGroupResponseAllOf
     */
    'hidden': boolean;
}
/**
 * 
 * @export
 * @interface BoilerPayoutRequestResponse
 */
export interface BoilerPayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BoilerPayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BoilerPayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BoilerPayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BoilerPayoutRequestResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'amount': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface BoilerPayoutRequestResponseAllOf
 */
export interface BoilerPayoutRequestResponseAllOf {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponseAllOf
     */
    'requestedBy': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponseAllOf
     */
    'approvedBy'?: BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BoilerPayoutRequestResponseAllOf
     */
    'amount': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface Container
 */
export interface Container {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Container
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Container
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Container
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Container
     */
    'id': number;
    /**
     * The current revision of the container. Can be null if no revision exists.
     * @type {number}
     * @memberof Container
     */
    'currentRevision'?: number;
    /**
     * 
     * @type {User}
     * @memberof Container
     */
    'owner': User;
    /**
     * Whether the container can be added to pointOfSales by everyone.
     * @type {boolean}
     * @memberof Container
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerAllOf
 */
export interface ContainerAllOf {
    /**
     * The current revision of the container. Can be null if no revision exists.
     * @type {number}
     * @memberof ContainerAllOf
     */
    'currentRevision'?: number;
    /**
     * 
     * @type {User}
     * @memberof ContainerAllOf
     */
    'owner': User;
    /**
     * Whether the container can be added to pointOfSales by everyone.
     * @type {boolean}
     * @memberof ContainerAllOf
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerResponse
 */
export interface ContainerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ContainerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ContainerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ContainerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ContainerResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof ContainerResponse
     */
    'public': boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof ContainerResponse
     */
    'revision'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof ContainerResponse
     */
    'owner': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface ContainerResponseAllOf
 */
export interface ContainerResponseAllOf {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof ContainerResponseAllOf
     */
    'owner': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface ContainerRevision
 */
export interface ContainerRevision {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof ContainerRevision
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof ContainerRevision
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof ContainerRevision
     */
    'version'?: number;
    /**
     * 
     * @type {Container}
     * @memberof ContainerRevision
     */
    'container': Container;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof ContainerRevision
     */
    'revision': number;
    /**
     * 
     * @type {Array<ProductRevision>}
     * @memberof ContainerRevision
     */
    'products': Array<ProductRevision>;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerRevision
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ContainerRevisionAllOf
 */
export interface ContainerRevisionAllOf {
    /**
     * 
     * @type {Container}
     * @memberof ContainerRevisionAllOf
     */
    'container': Container;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof ContainerRevisionAllOf
     */
    'revision': number;
    /**
     * 
     * @type {Array<ProductRevision>}
     * @memberof ContainerRevisionAllOf
     */
    'products': Array<ProductRevision>;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerRevisionAllOf
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ContainerWithProductsResponse
 */
export interface ContainerWithProductsResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof ContainerWithProductsResponse
     */
    'public': boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'revision'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof ContainerWithProductsResponse
     */
    'owner': BaseUserResponse;
    /**
     * 
     * @type {Array<ProductResponse>}
     * @memberof ContainerWithProductsResponse
     */
    'products': Array<ProductResponse>;
}
/**
 * 
 * @export
 * @interface ContainerWithProductsResponseAllOf
 */
export interface ContainerWithProductsResponseAllOf {
    /**
     * 
     * @type {Array<ProductResponse>}
     * @memberof ContainerWithProductsResponseAllOf
     */
    'products': Array<ProductResponse>;
}
/**
 * 
 * @export
 * @interface CreateContainerRequest
 */
export interface CreateContainerRequest {
    /**
     * Name of the container
     * @type {string}
     * @memberof CreateContainerRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateContainerRequest
     */
    'products': Array<number>;
    /**
     * Whether the container is public or not
     * @type {boolean}
     * @memberof CreateContainerRequest
     */
    'public': boolean;
    /**
     * Id of the user who will own the container, if undefined it will    default to the token ID.
     * @type {number}
     * @memberof CreateContainerRequest
     */
    'ownerId'?: number;
}
/**
 * 
 * @export
 * @interface CreateEventRequest
 */
export interface CreateEventRequest {
    /**
     * Name of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'name': string;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'endDate': string;
    /**
     * The type of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateEventRequest
     */
    'shiftIds': Array<number>;
}
/**
 * 
 * @export
 * @interface CreateInvoiceRequest
 */
export interface CreateInvoiceRequest {
    /**
     * The recipient of the Invoice.
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'forId': number;
    /**
     * The creator of the Invoice, defaults to the ID of the requester.
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'byId'?: number;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'addressee': string;
    /**
     * The description of the invoice.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'description': string;
    /**
     * 
     * @type {Array<InvoiceEntryRequest>}
     * @memberof CreateInvoiceRequest
     */
    'customEntries'?: Array<InvoiceEntryRequest>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateInvoiceRequest
     */
    'transactionIDs'?: Array<number>;
    /**
     * For creating an Invoice for all transactions from a specific date.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'fromDate'?: string;
    /**
     * If the invoice is an credit Invoice  If an invoice is a credit invoice the relevant subtransactions are defined as all the sub transactions which have `subTransaction.toId == forId`.
     * @type {boolean}
     * @memberof CreateInvoiceRequest
     */
    'isCreditInvoice': boolean;
}
/**
 * 
 * @export
 * @interface CreatePointOfSaleRequest
 */
export interface CreatePointOfSaleRequest {
    /**
     * Name of the POS
     * @type {string}
     * @memberof CreatePointOfSaleRequest
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof CreatePointOfSaleRequest
     */
    'useAuthentication': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreatePointOfSaleRequest
     */
    'containers'?: Array<number>;
    /**
     * ID of the user who will own the POS, if undefined it will    default to the token ID.
     * @type {number}
     * @memberof CreatePointOfSaleRequest
     */
    'ownerId'?: number;
}
/**
 * 
 * @export
 * @interface CreateProductRequest
 */
export interface CreateProductRequest {
    /**
     * Name of the product
     * @type {string}
     * @memberof CreateProductRequest
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof CreateProductRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * VAT group ID of the product
     * @type {number}
     * @memberof CreateProductRequest
     */
    'vat': number;
    /**
     * Category of the product
     * @type {number}
     * @memberof CreateProductRequest
     */
    'category': number;
    /**
     * Alcohol percentage of the product in 2 decimals
     * @type {number}
     * @memberof CreateProductRequest
     */
    'alcoholPercentage': number;
    /**
     * ID of the owner
     * @type {number}
     * @memberof CreateProductRequest
     */
    'ownerId': number;
}
/**
 * 
 * @export
 * @interface CreateShiftRequest
 */
export interface CreateShiftRequest {
    /**
     * Name of the event
     * @type {string}
     * @memberof CreateShiftRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateShiftRequest
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'canGoIntoDebt': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'ofAge': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof CreateUserRequest
     */
    'type': number;
}
/**
 * 
 * @export
 * @interface Dinero
 */
export interface Dinero {
    /**
     * The amount of money as integer in the given precision.
     * @type {number}
     * @memberof Dinero
     */
    'amount': number;
    /**
     * The precision of the amount, in decimal places.
     * @type {number}
     * @memberof Dinero
     */
    'precision': number;
    /**
     * The ISO 4217 currency code.
     * @type {string}
     * @memberof Dinero
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface DineroObject
 */
export interface DineroObject {
    /**
     * amount
     * @type {number}
     * @memberof DineroObject
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObject
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObject
     */
    'precision': number;
}
/**
 * 
 * @export
 * @interface DineroObjectRequest
 */
export interface DineroObjectRequest {
    /**
     * amount
     * @type {number}
     * @memberof DineroObjectRequest
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObjectRequest
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObjectRequest
     */
    'precision': number;
}
/**
 * 
 * @export
 * @interface DineroObjectResponse
 */
export interface DineroObjectResponse {
    /**
     * amount
     * @type {number}
     * @memberof DineroObjectResponse
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObjectResponse
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObjectResponse
     */
    'precision': number;
}
/**
 * 
 * @export
 * @interface EanAuthenticator
 */
export interface EanAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof EanAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof EanAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof EanAuthenticator
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof EanAuthenticator
     */
    'user': User;
    /**
     * The EAN code
     * @type {string}
     * @memberof EanAuthenticator
     */
    'eanCode': string;
}
/**
 * 
 * @export
 * @interface EanAuthenticatorAllOf
 */
export interface EanAuthenticatorAllOf {
    /**
     * The EAN code
     * @type {string}
     * @memberof EanAuthenticatorAllOf
     */
    'eanCode': string;
}
/**
 * 
 * @export
 * @interface EntityResponse
 */
export interface EntityResponse {
    /**
     * The name of the entity for which the permissions are.
     * @type {string}
     * @memberof EntityResponse
     */
    'entity'?: string;
    /**
     * 
     * @type {Array<ActionResponse>}
     * @memberof EntityResponse
     */
    'actions'?: Array<ActionResponse>;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Event
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Event
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Event
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Event
     */
    'id': number;
    /**
     * Name of the event.
     * @type {string}
     * @memberof Event
     */
    'name'?: string;
    /**
     * 
     * @type {User}
     * @memberof Event
     */
    'createdBy'?: User;
    /**
     * The starting date from which the banner should be shown.
     * @type {string}
     * @memberof Event
     */
    'startDate'?: string;
    /**
     * The end date from which the banner should no longer be shown.
     * @type {string}
     * @memberof Event
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface EventAllOf
 */
export interface EventAllOf {
    /**
     * Name of the event.
     * @type {string}
     * @memberof EventAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {User}
     * @memberof EventAllOf
     */
    'createdBy'?: User;
    /**
     * The starting date from which the banner should be shown.
     * @type {string}
     * @memberof EventAllOf
     */
    'startDate'?: string;
    /**
     * The end date from which the banner should no longer be shown.
     * @type {string}
     * @memberof EventAllOf
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface EventAnswerAssignmentRequest
 */
export interface EventAnswerAssignmentRequest {
    /**
     * Whether this user is selected for the given shift at the given event
     * @type {boolean}
     * @memberof EventAnswerAssignmentRequest
     */
    'selected': boolean;
}
/**
 * 
 * @export
 * @interface EventAnswerAvailabilityRequest
 */
export interface EventAnswerAvailabilityRequest {
    /**
     * New availability of the given user for the given event (YES, NO, LATER, NA)
     * @type {string}
     * @memberof EventAnswerAvailabilityRequest
     */
    'availability': string;
}
/**
 * 
 * @export
 * @interface EventInShiftResponse
 */
export interface EventInShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventInShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventInShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventInShiftResponse
     */
    'roles': Array<string>;
    /**
     * 
     * @type {Array<BaseEventAnswerResponse>}
     * @memberof EventInShiftResponse
     */
    'answers'?: Array<BaseEventAnswerResponse>;
}
/**
 * 
 * @export
 * @interface EventInShiftResponseAllOf
 */
export interface EventInShiftResponseAllOf {
    /**
     * 
     * @type {Array<BaseEventAnswerResponse>}
     * @memberof EventInShiftResponseAllOf
     */
    'answers'?: Array<BaseEventAnswerResponse>;
}
/**
 * 
 * @export
 * @interface EventPlanningSelectedCount
 */
export interface EventPlanningSelectedCount {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'nickname'?: string;
    /**
     * Number of times this user was selected for this shift
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface EventPlanningSelectedCountAllOf
 */
export interface EventPlanningSelectedCountAllOf {
    /**
     * Number of times this user was selected for this shift
     * @type {number}
     * @memberof EventPlanningSelectedCountAllOf
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventResponse
     */
    'version'?: number;
    /**
     * Name of the borrel.
     * @type {string}
     * @memberof EventResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof EventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof EventResponse
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof EventResponse
     */
    'endDate': string;
    /**
     * The tpye of event.
     * @type {string}
     * @memberof EventResponse
     */
    'type': string;
    /**
     * 
     * @type {Array<EventInShiftResponse>}
     * @memberof EventResponse
     */
    'shifts': Array<EventInShiftResponse>;
}
/**
 * 
 * @export
 * @interface EventResponseAllOf
 */
export interface EventResponseAllOf {
    /**
     * 
     * @type {Array<EventInShiftResponse>}
     * @memberof EventResponseAllOf
     */
    'shifts': Array<EventInShiftResponse>;
}
/**
 * 
 * @export
 * @interface EventShift
 */
export interface EventShift {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof EventShift
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof EventShift
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof EventShift
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof EventShift
     */
    'id': number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof EventShift
     */
    'name'?: string;
    /**
     * Indicator whether the shift is a regular shift.
     * @type {boolean}
     * @memberof EventShift
     */
    'default'?: boolean;
}
/**
 * 
 * @export
 * @interface EventShiftAllOf
 */
export interface EventShiftAllOf {
    /**
     * Name of the shift.
     * @type {string}
     * @memberof EventShiftAllOf
     */
    'name'?: string;
    /**
     * Indicator whether the shift is a regular shift.
     * @type {boolean}
     * @memberof EventShiftAllOf
     */
    'default'?: boolean;
}
/**
 * 
 * @export
 * @interface EventShiftAnswer
 */
export interface EventShiftAnswer {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof EventShiftAnswer
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof EventShiftAnswer
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof EventShiftAnswer
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof EventShiftAnswer
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof EventShiftAnswer
     */
    'user'?: User;
    /**
     * Filled in availability per slot.
     * @type {string}
     * @memberof EventShiftAnswer
     */
    'availability'?: EventShiftAnswerAvailabilityEnum;
    /**
     * Indicator whether the person has the related shift during the related borrel.
     * @type {boolean}
     * @memberof EventShiftAnswer
     */
    'selected'?: boolean;
    /**
     * 
     * @type {EventShift}
     * @memberof EventShiftAnswer
     */
    'shift'?: EventShift;
    /**
     * 
     * @type {Event}
     * @memberof EventShiftAnswer
     */
    'event'?: Event;
}

export const EventShiftAnswerAvailabilityEnum = {
    Undefined: 'undefined'
} as const;

export type EventShiftAnswerAvailabilityEnum = typeof EventShiftAnswerAvailabilityEnum[keyof typeof EventShiftAnswerAvailabilityEnum];

/**
 * 
 * @export
 * @interface EventShiftAnswerAllOf
 */
export interface EventShiftAnswerAllOf {
    /**
     * 
     * @type {User}
     * @memberof EventShiftAnswerAllOf
     */
    'user'?: User;
    /**
     * Filled in availability per slot.
     * @type {string}
     * @memberof EventShiftAnswerAllOf
     */
    'availability'?: EventShiftAnswerAllOfAvailabilityEnum;
    /**
     * Indicator whether the person has the related shift during the related borrel.
     * @type {boolean}
     * @memberof EventShiftAnswerAllOf
     */
    'selected'?: boolean;
    /**
     * 
     * @type {EventShift}
     * @memberof EventShiftAnswerAllOf
     */
    'shift'?: EventShift;
    /**
     * 
     * @type {Event}
     * @memberof EventShiftAnswerAllOf
     */
    'event'?: Event;
}

export const EventShiftAnswerAllOfAvailabilityEnum = {
    Undefined: 'undefined'
} as const;

export type EventShiftAnswerAllOfAvailabilityEnum = typeof EventShiftAnswerAllOfAvailabilityEnum[keyof typeof EventShiftAnswerAllOfAvailabilityEnum];

/**
 * 
 * @export
 * @interface EventShiftResponse
 */
export interface EventShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventShiftResponse
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface EventShiftResponseAllOf
 */
export interface EventShiftResponseAllOf {
    /**
     * 
     * @type {Array<string>}
     * @memberof EventShiftResponseAllOf
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface FinancialMutationResponse
 */
export interface FinancialMutationResponse {
    /**
     * Type of mutation (\'transfer\' or \'transaction\') (Optional)
     * @type {string}
     * @memberof FinancialMutationResponse
     */
    'type': string;
    /**
     * Details of mutation, this can be either of type TransferResponse or BaseTransactionResponse
     * @type {object}
     * @memberof FinancialMutationResponse
     */
    'mutation'?: object;
}
/**
 * 
 * @export
 * @interface FineHandoutEventResponse
 */
export interface FineHandoutEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof FineHandoutEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof FineHandoutEventResponse
     */
    'version'?: number;
    /**
     * Reference date of fines
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'referenceDate': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof FineHandoutEventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * 
     * @type {Array<FineResponse>}
     * @memberof FineHandoutEventResponse
     */
    'fines': Array<FineResponse>;
}
/**
 * 
 * @export
 * @interface FineHandoutEventResponseAllOf
 */
export interface FineHandoutEventResponseAllOf {
    /**
     * 
     * @type {Array<FineResponse>}
     * @memberof FineHandoutEventResponseAllOf
     */
    'fines': Array<FineResponse>;
}
/**
 * 
 * @export
 * @interface FineResponse
 */
export interface FineResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof FineResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof FineResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof FineResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof FineResponse
     */
    'version'?: number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof FineResponse
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof FineResponse
     */
    'user': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface FineResponseAllOf
 */
export interface FineResponseAllOf {
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof FineResponseAllOf
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof FineResponseAllOf
     */
    'user': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface GEWISAuthenticationPinRequest
 */
export interface GEWISAuthenticationPinRequest {
    /**
     * 
     * @type {number}
     * @memberof GEWISAuthenticationPinRequest
     */
    'gewisId': number;
    /**
     * 
     * @type {string}
     * @memberof GEWISAuthenticationPinRequest
     */
    'pin': string;
}
/**
 * 
 * @export
 * @interface GewisUser
 */
export interface GewisUser {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof GewisUser
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof GewisUser
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof GewisUser
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof GewisUser
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof GewisUser
     */
    'user': User;
    /**
     * The id of the member.
     * @type {number}
     * @memberof GewisUser
     */
    'gewisId': number;
}
/**
 * 
 * @export
 * @interface GewisUserAllOf
 */
export interface GewisUserAllOf {
    /**
     * 
     * @type {User}
     * @memberof GewisUserAllOf
     */
    'user': User;
    /**
     * The id of the member.
     * @type {number}
     * @memberof GewisUserAllOf
     */
    'gewisId': number;
}
/**
 * 
 * @export
 * @interface GewisUserResponse
 */
export interface GewisUserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof GewisUserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof GewisUserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'nickname'?: string;
    /**
     * Whether the user activated
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'active': boolean;
    /**
     * Whether the user is deleted
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'deleted': boolean;
    /**
     * The type of user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'type': string;
    /**
     * If local user, the e-mail of the user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'email'?: string;
    /**
     * Whether this user has accepted the TOS
     * @type {string}
     * @memberof GewisUserResponse
     */
    'acceptedToS'?: string;
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'extensiveDataProcessing'?: boolean;
    /**
     * Whether someone is old enough to drink beer
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'ofAge'?: boolean;
    /**
     * Whether this user can get a negative balance
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'canGoIntoDebt': boolean;
    /**
     * The m-Number of the user
     * @type {number}
     * @memberof GewisUserResponse
     */
    'gewisId'?: number;
}
/**
 * 
 * @export
 * @interface GewisUserResponseAllOf
 */
export interface GewisUserResponseAllOf {
    /**
     * The m-Number of the user
     * @type {number}
     * @memberof GewisUserResponseAllOf
     */
    'gewisId'?: number;
}
/**
 * 
 * @export
 * @interface GewiswebAuthenticationRequest
 */
export interface GewiswebAuthenticationRequest {
    /**
     * The gewisweb JWT token.
     * @type {string}
     * @memberof GewiswebAuthenticationRequest
     */
    'token': string;
    /**
     * The nonce used in the newly signed JWT token.
     * @type {string}
     * @memberof GewiswebAuthenticationRequest
     */
    'nonce': string;
}
/**
 * 
 * @export
 * @interface HandoutFinesRequest
 */
export interface HandoutFinesRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof HandoutFinesRequest
     */
    'userIds': Array<number>;
    /**
     * Reference date to calculate the balance and thus the height of the fine for.
     * @type {string}
     * @memberof HandoutFinesRequest
     */
    'referenceDate': string;
}
/**
 * 
 * @export
 * @interface HashBasedAuthenticationMethod
 */
export interface HashBasedAuthenticationMethod {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof HashBasedAuthenticationMethod
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof HashBasedAuthenticationMethod
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof HashBasedAuthenticationMethod
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof HashBasedAuthenticationMethod
     */
    'user': User;
    /**
     * The hash of the authentication
     * @type {string}
     * @memberof HashBasedAuthenticationMethod
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface HashBasedAuthenticationMethodAllOf
 */
export interface HashBasedAuthenticationMethodAllOf {
    /**
     * The hash of the authentication
     * @type {string}
     * @memberof HashBasedAuthenticationMethodAllOf
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Invoice
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Invoice
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Invoice
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Invoice
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof Invoice
     */
    'to': User;
    /**
     * 
     * @type {Transfer}
     * @memberof Invoice
     */
    'transfer': Transfer;
    /**
     * 
     * @type {Array<InvoiceEntry>}
     * @memberof Invoice
     */
    'invoiceEntries': Array<InvoiceEntry>;
    /**
     * 
     * @type {Array<InvoiceStatus>}
     * @memberof Invoice
     */
    'invoiceStatus': Array<InvoiceStatus>;
    /**
     * Name of the addressed
     * @type {string}
     * @memberof Invoice
     */
    'addressee': string;
    /**
     * The description of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface InvoiceAllOf
 */
export interface InvoiceAllOf {
    /**
     * 
     * @type {User}
     * @memberof InvoiceAllOf
     */
    'to': User;
    /**
     * 
     * @type {Transfer}
     * @memberof InvoiceAllOf
     */
    'transfer': Transfer;
    /**
     * 
     * @type {Array<InvoiceEntry>}
     * @memberof InvoiceAllOf
     */
    'invoiceEntries': Array<InvoiceEntry>;
    /**
     * 
     * @type {Array<InvoiceStatus>}
     * @memberof InvoiceAllOf
     */
    'invoiceStatus': Array<InvoiceStatus>;
    /**
     * Name of the addressed
     * @type {string}
     * @memberof InvoiceAllOf
     */
    'addressee': string;
    /**
     * The description of the invoice
     * @type {string}
     * @memberof InvoiceAllOf
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface InvoiceEntry
 */
export interface InvoiceEntry {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof InvoiceEntry
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof InvoiceEntry
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof InvoiceEntry
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof InvoiceEntry
     */
    'id': number;
    /**
     * 
     * @type {Invoice}
     * @memberof InvoiceEntry
     */
    'invoice': Invoice;
    /**
     * 
     * @type {Dinero}
     * @memberof InvoiceEntry
     */
    'priceInclVat': Dinero;
    /**
     * The amount of items in the invoice entry.
     * @type {number}
     * @memberof InvoiceEntry
     */
    'amount': number;
    /**
     * The description of the invoice entry item.
     * @type {string}
     * @memberof InvoiceEntry
     */
    'description': string;
    /**
     * The percentage of vat applied to this item.
     * @type {number}
     * @memberof InvoiceEntry
     */
    'vatPercentage': number;
}
/**
 * 
 * @export
 * @interface InvoiceEntryAllOf
 */
export interface InvoiceEntryAllOf {
    /**
     * 
     * @type {Invoice}
     * @memberof InvoiceEntryAllOf
     */
    'invoice': Invoice;
    /**
     * 
     * @type {Dinero}
     * @memberof InvoiceEntryAllOf
     */
    'priceInclVat': Dinero;
    /**
     * The amount of items in the invoice entry.
     * @type {number}
     * @memberof InvoiceEntryAllOf
     */
    'amount': number;
    /**
     * The description of the invoice entry item.
     * @type {string}
     * @memberof InvoiceEntryAllOf
     */
    'description': string;
    /**
     * The percentage of vat applied to this item.
     * @type {number}
     * @memberof InvoiceEntryAllOf
     */
    'vatPercentage': number;
}
/**
 * 
 * @export
 * @interface InvoiceEntryRequest
 */
export interface InvoiceEntryRequest {
    /**
     * The description of the entry
     * @type {string}
     * @memberof InvoiceEntryRequest
     */
    'description': string;
    /**
     * Amount of item sold.
     * @type {number}
     * @memberof InvoiceEntryRequest
     */
    'amount': number;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof InvoiceEntryRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * The percentage of VAT applied to this item
     * @type {number}
     * @memberof InvoiceEntryRequest
     */
    'vatPercentage': number;
}
/**
 * 
 * @export
 * @interface InvoiceEntryResponse
 */
export interface InvoiceEntryResponse {
    /**
     * The description of the entry
     * @type {string}
     * @memberof InvoiceEntryResponse
     */
    'description': string;
    /**
     * Amount of products sold.
     * @type {number}
     * @memberof InvoiceEntryResponse
     */
    'amount': number;
    /**
     * 
     * @type {DineroObject}
     * @memberof InvoiceEntryResponse
     */
    'priceInclVat': DineroObject;
    /**
     * The percentage of VAT applied to this entry
     * @type {number}
     * @memberof InvoiceEntryResponse
     */
    'vatPercentage': number;
}
/**
 * 
 * @export
 * @interface InvoiceResponse
 */
export interface InvoiceResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof InvoiceResponse
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'description': string;
    /**
     * 
     * @type {InvoiceStatusResponse}
     * @memberof InvoiceResponse
     */
    'currentState': InvoiceStatusResponse;
    /**
     * 
     * @type {TransferResponse}
     * @memberof InvoiceResponse
     */
    'transfer'?: TransferResponse;
    /**
     * 
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponse
     */
    'invoiceEntries': Array<InvoiceEntryResponse>;
}
/**
 * 
 * @export
 * @interface InvoiceResponseAllOf
 */
export interface InvoiceResponseAllOf {
    /**
     * 
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponseAllOf
     */
    'invoiceEntries': Array<InvoiceEntryResponse>;
}
/**
 * 
 * @export
 * @interface InvoiceResponseTypes
 */
export interface InvoiceResponseTypes {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof InvoiceResponseTypes
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof InvoiceResponseTypes
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof InvoiceResponseTypes
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'description': string;
    /**
     * 
     * @type {InvoiceStatusResponse}
     * @memberof InvoiceResponseTypes
     */
    'currentState': InvoiceStatusResponse;
    /**
     * 
     * @type {TransferResponse}
     * @memberof InvoiceResponseTypes
     */
    'transfer'?: TransferResponse;
    /**
     * 
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponseTypes
     */
    'invoiceEntries'?: Array<InvoiceEntryResponse>;
}
/**
 * 
 * @export
 * @interface InvoiceResponseTypesAllOf
 */
export interface InvoiceResponseTypesAllOf {
    /**
     * 
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponseTypesAllOf
     */
    'invoiceEntries'?: Array<InvoiceEntryResponse>;
}
/**
 * 
 * @export
 * @interface InvoiceStatus
 */
export interface InvoiceStatus {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof InvoiceStatus
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof InvoiceStatus
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof InvoiceStatus
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof InvoiceStatus
     */
    'id': number;
    /**
     * 
     * @type {Invoice}
     * @memberof InvoiceStatus
     */
    'invoice': Invoice;
    /**
     * 
     * @type {User}
     * @memberof InvoiceStatus
     */
    'changedBy': User;
    /**
     * The state of the Invoice
     * @type {string}
     * @memberof InvoiceStatus
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface InvoiceStatusAllOf
 */
export interface InvoiceStatusAllOf {
    /**
     * 
     * @type {Invoice}
     * @memberof InvoiceStatusAllOf
     */
    'invoice': Invoice;
    /**
     * 
     * @type {User}
     * @memberof InvoiceStatusAllOf
     */
    'changedBy': User;
    /**
     * The state of the Invoice
     * @type {string}
     * @memberof InvoiceStatusAllOf
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface InvoiceStatusResponse
 */
export interface InvoiceStatusResponse {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof InvoiceStatusResponse
     */
    'changedBy': BaseUserResponse;
    /**
     * The state of the invoice, can be either CREATED, SENT, PAID or DELETED.
     * @type {string}
     * @memberof InvoiceStatusResponse
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface InvoiceUser
 */
export interface InvoiceUser {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof InvoiceUser
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof InvoiceUser
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof InvoiceUser
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof InvoiceUser
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof InvoiceUser
     */
    'user': User;
    /**
     * Whether the user gets automatic invoices
     * @type {boolean}
     * @memberof InvoiceUser
     */
    'automatic'?: boolean;
}
/**
 * 
 * @export
 * @interface InvoiceUserAllOf
 */
export interface InvoiceUserAllOf {
    /**
     * 
     * @type {User}
     * @memberof InvoiceUserAllOf
     */
    'user': User;
    /**
     * Whether the user gets automatic invoices
     * @type {boolean}
     * @memberof InvoiceUserAllOf
     */
    'automatic'?: boolean;
}
/**
 * 
 * @export
 * @interface KeyAuthenticator
 */
export interface KeyAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof KeyAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof KeyAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof KeyAuthenticator
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof KeyAuthenticator
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface LDAPAuthenticator
 */
export interface LDAPAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof LDAPAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof LDAPAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof LDAPAuthenticator
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof LDAPAuthenticator
     */
    'user': User;
    /**
     * The associated AD account name
     * @type {string}
     * @memberof LDAPAuthenticator
     */
    'accountName': string;
}
/**
 * 
 * @export
 * @interface LDAPAuthenticatorAllOf
 */
export interface LDAPAuthenticatorAllOf {
    /**
     * The associated AD account name
     * @type {string}
     * @memberof LDAPAuthenticatorAllOf
     */
    'accountName': string;
}
/**
 * 
 * @export
 * @interface LocalAuthenticator
 */
export interface LocalAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof LocalAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof LocalAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof LocalAuthenticator
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof LocalAuthenticator
     */
    'user': User;
    /**
     * The Password code of this user (hashed)
     * @type {string}
     * @memberof LocalAuthenticator
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface LocalAuthenticatorAllOf
 */
export interface LocalAuthenticatorAllOf {
    /**
     * The Password code of this user (hashed)
     * @type {string}
     * @memberof LocalAuthenticatorAllOf
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface LocalUser
 */
export interface LocalUser {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof LocalUser
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof LocalUser
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof LocalUser
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof LocalUser
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof LocalUser
     */
    'user': User;
    /**
     * The hashed password of the user.
     * @type {string}
     * @memberof LocalUser
     */
    'passwordHash': string;
}
/**
 * 
 * @export
 * @interface LocalUserAllOf
 */
export interface LocalUserAllOf {
    /**
     * 
     * @type {User}
     * @memberof LocalUserAllOf
     */
    'user': User;
    /**
     * The hashed password of the user.
     * @type {string}
     * @memberof LocalUserAllOf
     */
    'passwordHash': string;
}
/**
 * 
 * @export
 * @interface MemberAuthenticator
 */
export interface MemberAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof MemberAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof MemberAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof MemberAuthenticator
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof MemberAuthenticator
     */
    'user': User;
    /**
     * 
     * @type {User}
     * @memberof MemberAuthenticator
     */
    'authenticateAs': User;
}
/**
 * 
 * @export
 * @interface MemberAuthenticatorAllOf
 */
export interface MemberAuthenticatorAllOf {
    /**
     * 
     * @type {User}
     * @memberof MemberAuthenticatorAllOf
     */
    'authenticateAs': User;
}
/**
 * 
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * The message response text.
     * @type {string}
     * @memberof MessageResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface NfcAuthenticator
 */
export interface NfcAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof NfcAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof NfcAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof NfcAuthenticator
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof NfcAuthenticator
     */
    'user': User;
    /**
     * The UID of the NFC chip
     * @type {string}
     * @memberof NfcAuthenticator
     */
    'nfcCode': string;
}
/**
 * 
 * @export
 * @interface NfcAuthenticatorAllOf
 */
export interface NfcAuthenticatorAllOf {
    /**
     * The UID of the NFC chip
     * @type {string}
     * @memberof NfcAuthenticatorAllOf
     */
    'nfcCode': string;
}
/**
 * 
 * @export
 * @interface PaginatedBalanceResponse
 */
export interface PaginatedBalanceResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBalanceResponse
     */
    '_pagination'?: PaginationResult;
    /**
     * 
     * @type {Array<BalanceResponse>}
     * @memberof PaginatedBalanceResponse
     */
    'records'?: Array<BalanceResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedBannerResponse
 */
export interface PaginatedBannerResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBannerResponse
     */
    '_pagination'?: PaginationResult;
    /**
     * 
     * @type {Array<BannerResponse>}
     * @memberof PaginatedBannerResponse
     */
    'records'?: Array<BannerResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedBaseEventResponse
 */
export interface PaginatedBaseEventResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBaseEventResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<BaseEventResponse>}
     * @memberof PaginatedBaseEventResponse
     */
    'records': Array<BaseEventResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedBasePayoutRequestResponse
 */
export interface PaginatedBasePayoutRequestResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBasePayoutRequestResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<BasePayoutRequestResponse>}
     * @memberof PaginatedBasePayoutRequestResponse
     */
    'records': Array<BasePayoutRequestResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedBaseTransactionResponse
 */
export interface PaginatedBaseTransactionResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBaseTransactionResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<BaseTransactionResponse>}
     * @memberof PaginatedBaseTransactionResponse
     */
    'records': Array<BaseTransactionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedContainerResponse
 */
export interface PaginatedContainerResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedContainerResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<ContainerResponse>}
     * @memberof PaginatedContainerResponse
     */
    'records': Array<ContainerResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedContainerWithProductResponse
 */
export interface PaginatedContainerWithProductResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedContainerWithProductResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PaginatedContainerWithProductResponse
     */
    'records': Array<ContainerWithProductsResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedEventShiftResponse
 */
export interface PaginatedEventShiftResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedEventShiftResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<EventShiftResponse>}
     * @memberof PaginatedEventShiftResponse
     */
    'records': Array<EventShiftResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedFinancialMutationResponse
 */
export interface PaginatedFinancialMutationResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedFinancialMutationResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<FinancialMutationResponse>}
     * @memberof PaginatedFinancialMutationResponse
     */
    'records': Array<FinancialMutationResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedFineHandoutEventResponse
 */
export interface PaginatedFineHandoutEventResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedFineHandoutEventResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<BaseFineHandoutEventResponse>}
     * @memberof PaginatedFineHandoutEventResponse
     */
    'records': Array<BaseFineHandoutEventResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedInvoiceResponse
 */
export interface PaginatedInvoiceResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedInvoiceResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<InvoiceResponseTypes>}
     * @memberof PaginatedInvoiceResponse
     */
    'records': Array<InvoiceResponseTypes>;
}
/**
 * 
 * @export
 * @interface PaginatedPointOfSaleResponse
 */
export interface PaginatedPointOfSaleResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedPointOfSaleResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<PointOfSaleResponse>}
     * @memberof PaginatedPointOfSaleResponse
     */
    'records': Array<PointOfSaleResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedProductCategoryResponse
 */
export interface PaginatedProductCategoryResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedProductCategoryResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<ProductCategoryResponse>}
     * @memberof PaginatedProductCategoryResponse
     */
    'records': Array<ProductCategoryResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedProductResponse
 */
export interface PaginatedProductResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedProductResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<ProductResponse>}
     * @memberof PaginatedProductResponse
     */
    'records': Array<ProductResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedTransferResponse
 */
export interface PaginatedTransferResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedTransferResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<TransferResponse>}
     * @memberof PaginatedTransferResponse
     */
    'records': Array<TransferResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedUserResponse
 */
export interface PaginatedUserResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedUserResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof PaginatedUserResponse
     */
    'records': Array<UserResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedVatGroupResponse
 */
export interface PaginatedVatGroupResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedVatGroupResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<VatGroup>}
     * @memberof PaginatedVatGroupResponse
     */
    'records': Array<VatGroup>;
}
/**
 * 
 * @export
 * @interface PaginatedVoucherGroupResponse
 */
export interface PaginatedVoucherGroupResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedVoucherGroupResponse
     */
    '_pagination': PaginationResult;
    /**
     * 
     * @type {Array<VoucherGroupResponse>}
     * @memberof PaginatedVoucherGroupResponse
     */
    'records': Array<VoucherGroupResponse>;
}
/**
 * 
 * @export
 * @interface PaginationResult
 */
export interface PaginationResult {
    /**
     * Number of records queried
     * @type {number}
     * @memberof PaginationResult
     */
    'take': number;
    /**
     * Number of skipped records
     * @type {number}
     * @memberof PaginationResult
     */
    'skip': number;
    /**
     * Total number of resulting records
     * @type {number}
     * @memberof PaginationResult
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface PayoutRequestRequest
 */
export interface PayoutRequestRequest {
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof PayoutRequestRequest
     */
    'amount': DineroObjectRequest;
    /**
     * The bank account number to transfer the money to
     * @type {string}
     * @memberof PayoutRequestRequest
     */
    'bankAccountNumber': string;
    /**
     * The name of the owner of the bank account
     * @type {string}
     * @memberof PayoutRequestRequest
     */
    'bankAccountName': string;
}
/**
 * 
 * @export
 * @interface PayoutRequestResponse
 */
export interface PayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PayoutRequestResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof PayoutRequestResponse
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {Array<PayoutRequestStatusResponse>}
     * @memberof PayoutRequestResponse
     */
    'status': Array<PayoutRequestStatusResponse>;
    /**
     * Bank account number
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'bankAccountNumber': string;
    /**
     * Name of the account owner
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'bankAccountName': string;
}
/**
 * 
 * @export
 * @interface PayoutRequestResponseAllOf
 */
export interface PayoutRequestResponseAllOf {
    /**
     * 
     * @type {Array<PayoutRequestStatusResponse>}
     * @memberof PayoutRequestResponseAllOf
     */
    'status': Array<PayoutRequestStatusResponse>;
    /**
     * Bank account number
     * @type {string}
     * @memberof PayoutRequestResponseAllOf
     */
    'bankAccountNumber': string;
    /**
     * Name of the account owner
     * @type {string}
     * @memberof PayoutRequestResponseAllOf
     */
    'bankAccountName': string;
}
/**
 * 
 * @export
 * @interface PayoutRequestStatusRequest
 */
export interface PayoutRequestStatusRequest {
    /**
     * PayoutRequestState to change to, should be one of CREATED, APPROVED, DENIED, CANCELLED
     * @type {string}
     * @memberof PayoutRequestStatusRequest
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface PayoutRequestStatusResponse
 */
export interface PayoutRequestStatusResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PayoutRequestStatusResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PayoutRequestStatusResponse
     */
    'version'?: number;
    /**
     * The state of this status change
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface PayoutRequestStatusResponseAllOf
 */
export interface PayoutRequestStatusResponseAllOf {
    /**
     * The state of this status change
     * @type {string}
     * @memberof PayoutRequestStatusResponseAllOf
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface PinAuthenticator
 */
export interface PinAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof PinAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof PinAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof PinAuthenticator
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof PinAuthenticator
     */
    'user': User;
    /**
     * The PIN code of this user (hashed)
     * @type {string}
     * @memberof PinAuthenticator
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface PinAuthenticatorAllOf
 */
export interface PinAuthenticatorAllOf {
    /**
     * The PIN code of this user (hashed)
     * @type {string}
     * @memberof PinAuthenticatorAllOf
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface PointOfSale
 */
export interface PointOfSale {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof PointOfSale
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof PointOfSale
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof PointOfSale
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof PointOfSale
     */
    'id': number;
    /**
     * The current revision of the pointOfSale. Can be null if no revision exists.
     * @type {number}
     * @memberof PointOfSale
     */
    'currentRevision'?: number;
    /**
     * 
     * @type {User}
     * @memberof PointOfSale
     */
    'owner': User;
}
/**
 * 
 * @export
 * @interface PointOfSaleAllOf
 */
export interface PointOfSaleAllOf {
    /**
     * The current revision of the pointOfSale. Can be null if no revision exists.
     * @type {number}
     * @memberof PointOfSaleAllOf
     */
    'currentRevision'?: number;
    /**
     * 
     * @type {User}
     * @memberof PointOfSaleAllOf
     */
    'owner': User;
}
/**
 * 
 * @export
 * @interface PointOfSaleResponse
 */
export interface PointOfSaleResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PointOfSaleResponse
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleResponse
     */
    'useAuthentication': boolean;
}
/**
 * 
 * @export
 * @interface PointOfSaleResponseAllOf
 */
export interface PointOfSaleResponseAllOf {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PointOfSaleResponseAllOf
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleResponseAllOf
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleResponseAllOf
     */
    'useAuthentication': boolean;
}
/**
 * 
 * @export
 * @interface PointOfSaleRevision
 */
export interface PointOfSaleRevision {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof PointOfSaleRevision
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof PointOfSaleRevision
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof PointOfSaleRevision
     */
    'version'?: number;
    /**
     * 
     * @type {PointOfSale}
     * @memberof PointOfSaleRevision
     */
    'pointOfSale': PointOfSale;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof PointOfSaleRevision
     */
    'revision': number;
    /**
     * 
     * @type {Array<ContainerRevision>}
     * @memberof PointOfSaleRevision
     */
    'containers': Array<ContainerRevision>;
    /**
     * The name of the pointOfSale.
     * @type {string}
     * @memberof PointOfSaleRevision
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleRevision
     */
    'useAuthentication': boolean;
}
/**
 * 
 * @export
 * @interface PointOfSaleRevisionAllOf
 */
export interface PointOfSaleRevisionAllOf {
    /**
     * 
     * @type {PointOfSale}
     * @memberof PointOfSaleRevisionAllOf
     */
    'pointOfSale': PointOfSale;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof PointOfSaleRevisionAllOf
     */
    'revision': number;
    /**
     * 
     * @type {Array<ContainerRevision>}
     * @memberof PointOfSaleRevisionAllOf
     */
    'containers': Array<ContainerRevision>;
    /**
     * The name of the pointOfSale.
     * @type {string}
     * @memberof PointOfSaleRevisionAllOf
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleRevisionAllOf
     */
    'useAuthentication': boolean;
}
/**
 * 
 * @export
 * @interface PointOfSaleWithContainersResponse
 */
export interface PointOfSaleWithContainersResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PointOfSaleWithContainersResponse
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleWithContainersResponse
     */
    'useAuthentication': boolean;
    /**
     * 
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PointOfSaleWithContainersResponse
     */
    'containers': Array<ContainerWithProductsResponse>;
}
/**
 * 
 * @export
 * @interface PointOfSaleWithContainersResponseAllOf
 */
export interface PointOfSaleWithContainersResponseAllOf {
    /**
     * 
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PointOfSaleWithContainersResponseAllOf
     */
    'containers': Array<ContainerWithProductsResponse>;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Product
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Product
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Product
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Product
     */
    'id': number;
    /**
     * The current revision of the product. Can be null if no revision exists.
     * @type {number}
     * @memberof Product
     */
    'currentRevision'?: number;
    /**
     * 
     * @type {User}
     * @memberof Product
     */
    'owner': User;
    /**
     * 
     * @type {ProductImage}
     * @memberof Product
     */
    'image'?: ProductImage;
}
/**
 * 
 * @export
 * @interface ProductAllOf
 */
export interface ProductAllOf {
    /**
     * The current revision of the product. Can be null if no revision exists.
     * @type {number}
     * @memberof ProductAllOf
     */
    'currentRevision'?: number;
    /**
     * 
     * @type {User}
     * @memberof ProductAllOf
     */
    'owner': User;
    /**
     * 
     * @type {ProductImage}
     * @memberof ProductAllOf
     */
    'image'?: ProductImage;
}
/**
 * 
 * @export
 * @interface ProductCategory
 */
export interface ProductCategory {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof ProductCategory
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof ProductCategory
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof ProductCategory
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof ProductCategory
     */
    'id': number;
    /**
     * The unique name of the productCategory.
     * @type {string}
     * @memberof ProductCategory
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProductCategoryAllOf
 */
export interface ProductCategoryAllOf {
    /**
     * The unique name of the productCategory.
     * @type {string}
     * @memberof ProductCategoryAllOf
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProductCategoryRequest
 */
export interface ProductCategoryRequest {
    /**
     * Name/label of the productCategory
     * @type {string}
     * @memberof ProductCategoryRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ProductCategoryResponse
 */
export interface ProductCategoryResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ProductCategoryResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ProductCategoryResponse
     */
    'version'?: number;
    /**
     * The name of the productCategory.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProductCategoryResponseAllOf
 */
export interface ProductCategoryResponseAllOf {
    /**
     * The name of the productCategory.
     * @type {string}
     * @memberof ProductCategoryResponseAllOf
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProductImage
 */
export interface ProductImage {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof ProductImage
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof ProductImage
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof ProductImage
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof ProductImage
     */
    'id': number;
    /**
     * The filename when the file is downloaded
     * @type {string}
     * @memberof ProductImage
     */
    'downloadName': string;
    /**
     * The location of the file, including filename in storage
     * @type {string}
     * @memberof ProductImage
     */
    'location': string;
    /**
     * 
     * @type {User}
     * @memberof ProductImage
     */
    'createdBy': User;
}
/**
 * 
 * @export
 * @interface ProductOrdering
 */
export interface ProductOrdering {
    /**
     * 
     * @type {PointOfSale}
     * @memberof ProductOrdering
     */
    'pos': PointOfSale;
    /**
     * 
     * @type {Product}
     * @memberof ProductOrdering
     */
    'product': Product;
    /**
     * The order number of the product in the pointOfSale.
     * @type {number}
     * @memberof ProductOrdering
     */
    'order': number;
}
/**
 * 
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ProductResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ProductResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ProductResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ProductResponse
     */
    'version'?: number;
    /**
     * The name of the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ProductResponse
     */
    'priceInclVat': DineroObjectResponse;
    /**
     * 
     * @type {BaseVatGroupResponse}
     * @memberof ProductResponse
     */
    'vat': BaseVatGroupResponse;
    /**
     * The product revision ID
     * @type {number}
     * @memberof ProductResponse
     */
    'revision': number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof ProductResponse
     */
    'owner': BaseUserResponse;
    /**
     * 
     * @type {ProductCategoryResponse}
     * @memberof ProductResponse
     */
    'category': ProductCategoryResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ProductResponse
     */
    'priceExclVat': DineroObjectResponse;
    /**
     * The URL to the picture representing this product.
     * @type {string}
     * @memberof ProductResponse
     */
    'image'?: string;
    /**
     * The percentage of alcohol in this product.
     * @type {number}
     * @memberof ProductResponse
     */
    'alcoholPercentage': number;
}
/**
 * 
 * @export
 * @interface ProductResponseAllOf
 */
export interface ProductResponseAllOf {
    /**
     * The product revision ID
     * @type {number}
     * @memberof ProductResponseAllOf
     */
    'revision': number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof ProductResponseAllOf
     */
    'owner': BaseUserResponse;
    /**
     * 
     * @type {ProductCategoryResponse}
     * @memberof ProductResponseAllOf
     */
    'category': ProductCategoryResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ProductResponseAllOf
     */
    'priceExclVat': DineroObjectResponse;
    /**
     * The URL to the picture representing this product.
     * @type {string}
     * @memberof ProductResponseAllOf
     */
    'image'?: string;
    /**
     * The percentage of alcohol in this product.
     * @type {number}
     * @memberof ProductResponseAllOf
     */
    'alcoholPercentage': number;
}
/**
 * 
 * @export
 * @interface ProductRevision
 */
export interface ProductRevision {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof ProductRevision
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof ProductRevision
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof ProductRevision
     */
    'version'?: number;
    /**
     * 
     * @type {Product}
     * @memberof ProductRevision
     */
    'product': Product;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof ProductRevision
     */
    'revision': number;
    /**
     * The unique name of the product.
     * @type {string}
     * @memberof ProductRevision
     */
    'name': string;
    /**
     * 
     * @type {Dinero}
     * @memberof ProductRevision
     */
    'price': Dinero;
}
/**
 * 
 * @export
 * @interface ProductRevisionAllOf
 */
export interface ProductRevisionAllOf {
    /**
     * 
     * @type {Product}
     * @memberof ProductRevisionAllOf
     */
    'product': Product;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof ProductRevisionAllOf
     */
    'revision': number;
    /**
     * The unique name of the product.
     * @type {string}
     * @memberof ProductRevisionAllOf
     */
    'name': string;
    /**
     * 
     * @type {Dinero}
     * @memberof ProductRevisionAllOf
     */
    'price': Dinero;
}
/**
 * 
 * @export
 * @interface RelationResponse
 */
export interface RelationResponse {
    /**
     * The the ownership relation towards the entity.
     * @type {string}
     * @memberof RelationResponse
     */
    'relation'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RelationResponse
     */
    'attributes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ResetLocalRequest
 */
export interface ResetLocalRequest {
    /**
     * The mail of the user
     * @type {string}
     * @memberof ResetLocalRequest
     */
    'accountMail': string;
}
/**
 * 
 * @export
 * @interface ResetToken
 */
export interface ResetToken {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof ResetToken
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof ResetToken
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof ResetToken
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof ResetToken
     */
    'user': User;
    /**
     * The hash of the authentication
     * @type {string}
     * @memberof ResetToken
     */
    'hash': string;
    /**
     * The end date from which the token is expired
     * @type {string}
     * @memberof ResetToken
     */
    'expires': string;
}
/**
 * 
 * @export
 * @interface ResetTokenAllOf
 */
export interface ResetTokenAllOf {
    /**
     * The end date from which the token is expired
     * @type {string}
     * @memberof ResetTokenAllOf
     */
    'expires': string;
}
/**
 * 
 * @export
 * @interface RevisionRequest
 */
export interface RevisionRequest {
    /**
     * revision id
     * @type {number}
     * @memberof RevisionRequest
     */
    'id'?: number;
    /**
     * revision number
     * @type {number}
     * @memberof RevisionRequest
     */
    'revision'?: number;
}
/**
 * 
 * @export
 * @interface RoleResponse
 */
export interface RoleResponse {
    /**
     * The name of the role.
     * @type {string}
     * @memberof RoleResponse
     */
    'role': string;
    /**
     * 
     * @type {Array<EntityResponse>}
     * @memberof RoleResponse
     */
    'entities'?: Array<EntityResponse>;
}
/**
 * 
 * @export
 * @interface SimpleFileRequest
 */
export interface SimpleFileRequest {
    /**
     * Name of the file
     * @type {string}
     * @memberof SimpleFileRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface SimpleFileResponse
 */
export interface SimpleFileResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SimpleFileResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SimpleFileResponse
     */
    'version'?: number;
    /**
     * The filename of the file
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'downloadName': string;
    /**
     * The location of the file in storage
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'location': string;
    /**
     * 
     * @type {UserResponse}
     * @memberof SimpleFileResponse
     */
    'createdBy': UserResponse;
}
/**
 * 
 * @export
 * @interface SimpleFileResponseAllOf
 */
export interface SimpleFileResponseAllOf {
    /**
     * The filename of the file
     * @type {string}
     * @memberof SimpleFileResponseAllOf
     */
    'downloadName': string;
    /**
     * The location of the file in storage
     * @type {string}
     * @memberof SimpleFileResponseAllOf
     */
    'location': string;
    /**
     * 
     * @type {UserResponse}
     * @memberof SimpleFileResponseAllOf
     */
    'createdBy': UserResponse;
}
/**
 * 
 * @export
 * @interface StripeDepositResponse
 */
export interface StripeDepositResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripeDepositResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripeDepositResponse
     */
    'version'?: number;
    /**
     * The ID of the payment intent in Stripe
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'stripeId': string;
    /**
     * 
     * @type {Array<StripeDepositStatusResponse>}
     * @memberof StripeDepositResponse
     */
    'depositStatus': Array<StripeDepositStatusResponse>;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof StripeDepositResponse
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof StripeDepositResponse
     */
    'to': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface StripeDepositResponseAllOf
 */
export interface StripeDepositResponseAllOf {
    /**
     * The ID of the payment intent in Stripe
     * @type {string}
     * @memberof StripeDepositResponseAllOf
     */
    'stripeId': string;
    /**
     * 
     * @type {Array<StripeDepositStatusResponse>}
     * @memberof StripeDepositResponseAllOf
     */
    'depositStatus': Array<StripeDepositStatusResponse>;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof StripeDepositResponseAllOf
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof StripeDepositResponseAllOf
     */
    'to': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface StripeDepositStatusResponse
 */
export interface StripeDepositStatusResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripeDepositStatusResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripeDepositStatusResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripeDepositStatusResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripeDepositStatusResponse
     */
    'version'?: number;
    /**
     * State of the Stripe deposit. It can be 1 (\'CREATED\'), 2 (\'PROCESSING\'), 3 (\'SUCCEEDED\'), or 4 (\'FAILED\')
     * @type {number}
     * @memberof StripeDepositStatusResponse
     */
    'state': number;
}
/**
 * 
 * @export
 * @interface StripeDepositStatusResponseAllOf
 */
export interface StripeDepositStatusResponseAllOf {
    /**
     * State of the Stripe deposit. It can be 1 (\'CREATED\'), 2 (\'PROCESSING\'), 3 (\'SUCCEEDED\'), or 4 (\'FAILED\')
     * @type {number}
     * @memberof StripeDepositStatusResponseAllOf
     */
    'state': number;
}
/**
 * 
 * @export
 * @interface StripePaymentIntentResponse
 */
export interface StripePaymentIntentResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripePaymentIntentResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripePaymentIntentResponse
     */
    'version'?: number;
    /**
     * ID of the intent in Stripe.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'stripeId': string;
    /**
     * The client secret of the created Payment Intent.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'clientSecret': string;
}
/**
 * 
 * @export
 * @interface StripePaymentIntentResponseAllOf
 */
export interface StripePaymentIntentResponseAllOf {
    /**
     * ID of the intent in Stripe.
     * @type {string}
     * @memberof StripePaymentIntentResponseAllOf
     */
    'stripeId': string;
    /**
     * The client secret of the created Payment Intent.
     * @type {string}
     * @memberof StripePaymentIntentResponseAllOf
     */
    'clientSecret': string;
}
/**
 * 
 * @export
 * @interface StripeRequest
 */
export interface StripeRequest {
    /**
     * 
     * @type {Dinero}
     * @memberof StripeRequest
     */
    'amount'?: Dinero;
}
/**
 * 
 * @export
 * @interface SubTransaction
 */
export interface SubTransaction {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof SubTransaction
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof SubTransaction
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof SubTransaction
     */
    'version'?: number;
    /**
     * 
     * @type {User}
     * @memberof SubTransaction
     */
    'to': User;
    /**
     * 
     * @type {Container}
     * @memberof SubTransaction
     */
    'container': Container;
    /**
     * 
     * @type {Transaction}
     * @memberof SubTransaction
     */
    'transaction': Transaction;
    /**
     * 
     * @type {Array<SubTransactionRow>}
     * @memberof SubTransaction
     */
    'subTransactionsRows': Array<SubTransactionRow>;
}
/**
 * 
 * @export
 * @interface SubTransactionAllOf
 */
export interface SubTransactionAllOf {
    /**
     * 
     * @type {User}
     * @memberof SubTransactionAllOf
     */
    'to': User;
    /**
     * 
     * @type {Container}
     * @memberof SubTransactionAllOf
     */
    'container': Container;
    /**
     * 
     * @type {Transaction}
     * @memberof SubTransactionAllOf
     */
    'transaction': Transaction;
    /**
     * 
     * @type {Array<SubTransactionRow>}
     * @memberof SubTransactionAllOf
     */
    'subTransactionsRows': Array<SubTransactionRow>;
}
/**
 * 
 * @export
 * @interface SubTransactionRequest
 */
export interface SubTransactionRequest {
    /**
     * to user id
     * @type {number}
     * @memberof SubTransactionRequest
     */
    'to': number;
    /**
     * 
     * @type {RevisionRequest}
     * @memberof SubTransactionRequest
     */
    'container': RevisionRequest;
    /**
     * 
     * @type {Array<SubTransactionRowRequest>}
     * @memberof SubTransactionRequest
     */
    'subTransactionRows': Array<SubTransactionRowRequest>;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof SubTransactionRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface SubTransactionResponse
 */
export interface SubTransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SubTransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SubTransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SubTransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SubTransactionResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof SubTransactionResponse
     */
    'to': BaseUserResponse;
    /**
     * 
     * @type {BaseContainerResponse}
     * @memberof SubTransactionResponse
     */
    'container': BaseContainerResponse;
    /**
     * 
     * @type {Array<SubTransactionRowResponse>}
     * @memberof SubTransactionResponse
     */
    'subTransactionRows': Array<SubTransactionRowResponse>;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof SubTransactionResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface SubTransactionResponseAllOf
 */
export interface SubTransactionResponseAllOf {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof SubTransactionResponseAllOf
     */
    'to': BaseUserResponse;
    /**
     * 
     * @type {BaseContainerResponse}
     * @memberof SubTransactionResponseAllOf
     */
    'container': BaseContainerResponse;
    /**
     * 
     * @type {Array<SubTransactionRowResponse>}
     * @memberof SubTransactionResponseAllOf
     */
    'subTransactionRows': Array<SubTransactionRowResponse>;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof SubTransactionResponseAllOf
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface SubTransactionRow
 */
export interface SubTransactionRow {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof SubTransactionRow
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof SubTransactionRow
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof SubTransactionRow
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof SubTransactionRow
     */
    'id': number;
    /**
     * 
     * @type {Product}
     * @memberof SubTransactionRow
     */
    'product': Product;
    /**
     * The amount that has been bought.
     * @type {number}
     * @memberof SubTransactionRow
     */
    'amount': number;
    /**
     * 
     * @type {SubTransaction}
     * @memberof SubTransactionRow
     */
    'subTransaction'?: SubTransaction;
}
/**
 * 
 * @export
 * @interface SubTransactionRowAllOf
 */
export interface SubTransactionRowAllOf {
    /**
     * 
     * @type {Product}
     * @memberof SubTransactionRowAllOf
     */
    'product': Product;
    /**
     * The amount that has been bought.
     * @type {number}
     * @memberof SubTransactionRowAllOf
     */
    'amount': number;
    /**
     * 
     * @type {SubTransaction}
     * @memberof SubTransactionRowAllOf
     */
    'subTransaction'?: SubTransaction;
}
/**
 * 
 * @export
 * @interface SubTransactionRowRequest
 */
export interface SubTransactionRowRequest {
    /**
     * 
     * @type {RevisionRequest}
     * @memberof SubTransactionRowRequest
     */
    'product'?: RevisionRequest;
    /**
     * amount of this product in subtransaction
     * @type {number}
     * @memberof SubTransactionRowRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof SubTransactionRowRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface SubTransactionRowResponse
 */
export interface SubTransactionRowResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SubTransactionRowResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SubTransactionRowResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseProductResponse}
     * @memberof SubTransactionRowResponse
     */
    'product': BaseProductResponse;
    /**
     * The amount that has been bought
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'amount': number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof SubTransactionRowResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface SubTransactionRowResponseAllOf
 */
export interface SubTransactionRowResponseAllOf {
    /**
     * 
     * @type {BaseProductResponse}
     * @memberof SubTransactionRowResponseAllOf
     */
    'product': BaseProductResponse;
    /**
     * The amount that has been bought
     * @type {number}
     * @memberof SubTransactionRowResponseAllOf
     */
    'amount': number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof SubTransactionRowResponseAllOf
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Transaction
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Transaction
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Transaction
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Transaction
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof Transaction
     */
    'from': User;
    /**
     * 
     * @type {User}
     * @memberof Transaction
     */
    'createdBy': User;
    /**
     * 
     * @type {Array<SubTransaction>}
     * @memberof Transaction
     */
    'subTransactions': Array<SubTransaction>;
    /**
     * 
     * @type {PointOfSaleRevision}
     * @memberof Transaction
     */
    'pointOfSale': PointOfSaleRevision;
}
/**
 * 
 * @export
 * @interface TransactionAllOf
 */
export interface TransactionAllOf {
    /**
     * 
     * @type {User}
     * @memberof TransactionAllOf
     */
    'from': User;
    /**
     * 
     * @type {User}
     * @memberof TransactionAllOf
     */
    'createdBy': User;
    /**
     * 
     * @type {Array<SubTransaction>}
     * @memberof TransactionAllOf
     */
    'subTransactions': Array<SubTransaction>;
    /**
     * 
     * @type {PointOfSaleRevision}
     * @memberof TransactionAllOf
     */
    'pointOfSale': PointOfSaleRevision;
}
/**
 * 
 * @export
 * @interface TransactionFilterParameters
 */
export interface TransactionFilterParameters {
    /**
     * 
     * @type {Array<number>}
     * @memberof TransactionFilterParameters
     */
    'transactionId'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'fromId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'createdById'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'toId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionFilterParameters
     */
    'exclusiveToId'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'pointOfSaleId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'pointOfSaleRevision'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'containerId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'containerRevision'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'productId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'productRevision'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionFilterParameters
     */
    'fromDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionFilterParameters
     */
    'tillDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'invoiceId'?: number;
}
/**
 * 
 * @export
 * @interface TransactionReportCategoryEntryResponse
 */
export interface TransactionReportCategoryEntryResponse {
    /**
     * 
     * @type {ProductCategoryResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'category': ProductCategoryResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionReportDataResponse
 */
export interface TransactionReportDataResponse {
    /**
     * 
     * @type {Array<TransactionReportEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'entries': Array<TransactionReportEntryResponse>;
    /**
     * 
     * @type {Array<TransactionReportCategoryEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'categories': Array<TransactionReportCategoryEntryResponse>;
    /**
     * 
     * @type {Array<TransactionReportVatEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'vat': Array<TransactionReportVatEntryResponse>;
}
/**
 * 
 * @export
 * @interface TransactionReportEntryResponse
 */
export interface TransactionReportEntryResponse {
    /**
     * The amount of times this product is in the report
     * @type {number}
     * @memberof TransactionReportEntryResponse
     */
    'count': number;
    /**
     * 
     * @type {BaseProductResponse}
     * @memberof TransactionReportEntryResponse
     */
    'product': BaseProductResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionReportResponse
 */
export interface TransactionReportResponse {
    /**
     * 
     * @type {TransactionFilterParameters}
     * @memberof TransactionReportResponse
     */
    'parameters': TransactionFilterParameters;
    /**
     * 
     * @type {TransactionReportDataResponse}
     * @memberof TransactionReportResponse
     */
    'data': TransactionReportDataResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportResponse
     */
    'totalInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionReportVatEntryResponse
 */
export interface TransactionReportVatEntryResponse {
    /**
     * 
     * @type {BaseVatGroupResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'vat': BaseVatGroupResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionRequest
 */
export interface TransactionRequest {
    /**
     * from user id
     * @type {number}
     * @memberof TransactionRequest
     */
    'from': number;
    /**
     * createdBy user id
     * @type {number}
     * @memberof TransactionRequest
     */
    'createdBy'?: number;
    /**
     * 
     * @type {Array<SubTransactionRequest>}
     * @memberof TransactionRequest
     */
    'subTransactions': Array<SubTransactionRequest>;
    /**
     * 
     * @type {RevisionRequest}
     * @memberof TransactionRequest
     */
    'pointOfSale': RevisionRequest;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof TransactionRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof TransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof TransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof TransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof TransactionResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransactionResponse
     */
    'from': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransactionResponse
     */
    'createdBy'?: BaseUserResponse;
    /**
     * 
     * @type {Array<SubTransactionResponse>}
     * @memberof TransactionResponse
     */
    'subTransactions': Array<SubTransactionResponse>;
    /**
     * 
     * @type {BasePointOfSaleResponse}
     * @memberof TransactionResponse
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionResponseAllOf
 */
export interface TransactionResponseAllOf {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransactionResponseAllOf
     */
    'from': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransactionResponseAllOf
     */
    'createdBy'?: BaseUserResponse;
    /**
     * 
     * @type {Array<SubTransactionResponse>}
     * @memberof TransactionResponseAllOf
     */
    'subTransactions': Array<SubTransactionResponse>;
    /**
     * 
     * @type {BasePointOfSaleResponse}
     * @memberof TransactionResponseAllOf
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionResponseAllOf
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Transfer
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Transfer
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Transfer
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Transfer
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof Transfer
     */
    'from'?: User;
    /**
     * 
     * @type {User}
     * @memberof Transfer
     */
    'to'?: User;
    /**
     * 
     * @type {Dinero}
     * @memberof Transfer
     */
    'amount': Dinero;
    /**
     * The type of transfer.
     * @type {number}
     * @memberof Transfer
     */
    'type': number;
    /**
     * If the transfer is of type \'custom\', this contains a description of the transfer.
     * @type {string}
     * @memberof Transfer
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface TransferAllOf
 */
export interface TransferAllOf {
    /**
     * 
     * @type {User}
     * @memberof TransferAllOf
     */
    'from'?: User;
    /**
     * 
     * @type {User}
     * @memberof TransferAllOf
     */
    'to'?: User;
    /**
     * 
     * @type {Dinero}
     * @memberof TransferAllOf
     */
    'amount': Dinero;
    /**
     * The type of transfer.
     * @type {number}
     * @memberof TransferAllOf
     */
    'type': number;
    /**
     * If the transfer is of type \'custom\', this contains a description of the transfer.
     * @type {string}
     * @memberof TransferAllOf
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface TransferRequest
 */
export interface TransferRequest {
    /**
     * Description of the transfer
     * @type {string}
     * @memberof TransferRequest
     */
    'description'?: string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof TransferRequest
     */
    'amount'?: DineroObjectRequest;
    /**
     * Type of transfer
     * @type {number}
     * @memberof TransferRequest
     */
    'type'?: number;
    /**
     * from which user the money is being transferred
     * @type {number}
     * @memberof TransferRequest
     */
    'fromId'?: number;
    /**
     * to which user the money is being transferred.
     * @type {number}
     * @memberof TransferRequest
     */
    'toId'?: number;
}
/**
 * 
 * @export
 * @interface TransferResponse
 */
export interface TransferResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof TransferResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof TransferResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof TransferResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof TransferResponse
     */
    'version'?: number;
    /**
     * Description of the transfer
     * @type {string}
     * @memberof TransferResponse
     */
    'description': string;
    /**
     * 
     * @type {Dinero}
     * @memberof TransferResponse
     */
    'amount': Dinero;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransferResponse
     */
    'from'?: BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransferResponse
     */
    'to'?: BaseUserResponse;
    /**
     * 
     * @type {BaseInvoiceResponse}
     * @memberof TransferResponse
     */
    'invoice'?: BaseInvoiceResponse;
    /**
     * 
     * @type {StripeDepositResponse}
     * @memberof TransferResponse
     */
    'deposit'?: StripeDepositResponse;
    /**
     * 
     * @type {BasePayoutRequestResponse}
     * @memberof TransferResponse
     */
    'payoutRequest'?: BasePayoutRequestResponse;
    /**
     * 
     * @type {FineResponse}
     * @memberof TransferResponse
     */
    'fine'?: FineResponse;
    /**
     * 
     * @type {UserFineGroupResponse}
     * @memberof TransferResponse
     */
    'waivedFines'?: UserFineGroupResponse;
}
/**
 * 
 * @export
 * @interface TransferResponseAllOf
 */
export interface TransferResponseAllOf {
    /**
     * Description of the transfer
     * @type {string}
     * @memberof TransferResponseAllOf
     */
    'description': string;
    /**
     * 
     * @type {Dinero}
     * @memberof TransferResponseAllOf
     */
    'amount': Dinero;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransferResponseAllOf
     */
    'from'?: BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransferResponseAllOf
     */
    'to'?: BaseUserResponse;
    /**
     * 
     * @type {BaseInvoiceResponse}
     * @memberof TransferResponseAllOf
     */
    'invoice'?: BaseInvoiceResponse;
    /**
     * 
     * @type {StripeDepositResponse}
     * @memberof TransferResponseAllOf
     */
    'deposit'?: StripeDepositResponse;
    /**
     * 
     * @type {BasePayoutRequestResponse}
     * @memberof TransferResponseAllOf
     */
    'payoutRequest'?: BasePayoutRequestResponse;
    /**
     * 
     * @type {FineResponse}
     * @memberof TransferResponseAllOf
     */
    'fine'?: FineResponse;
    /**
     * 
     * @type {UserFineGroupResponse}
     * @memberof TransferResponseAllOf
     */
    'waivedFines'?: UserFineGroupResponse;
}
/**
 * 
 * @export
 * @interface UpdateContainerRequest
 */
export interface UpdateContainerRequest {
    /**
     * Name of the container
     * @type {string}
     * @memberof UpdateContainerRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateContainerRequest
     */
    'products': Array<number>;
    /**
     * Whether the container is public or not
     * @type {boolean}
     * @memberof UpdateContainerRequest
     */
    'public': boolean;
}
/**
 * 
 * @export
 * @interface UpdateEventRequest
 */
export interface UpdateEventRequest {
    /**
     * Name of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'name'?: string;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'startDate'?: string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'endDate'?: string;
    /**
     * The type of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateEventRequest
     */
    'shiftIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UpdateInvoiceRequest
 */
export interface UpdateInvoiceRequest {
    /**
     * The user who updates the Invoice, defaults to the ID of the requester.
     * @type {number}
     * @memberof UpdateInvoiceRequest
     */
    'byId'?: number;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'addressee': string;
    /**
     * The description of the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'description': string;
    /**
     * The state to set of the invoice,    can be either CREATED, SENT, PAID or DELETED.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface UpdateKeyResponse
 */
export interface UpdateKeyResponse {
    /**
     * The key to return
     * @type {string}
     * @memberof UpdateKeyResponse
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface UpdateLocalRequest
 */
export interface UpdateLocalRequest {
    /**
     * The password to set
     * @type {string}
     * @memberof UpdateLocalRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UpdateNfcRequest
 */
export interface UpdateNfcRequest {
    /**
     * The NFC code to set
     * @type {string}
     * @memberof UpdateNfcRequest
     */
    'nfcCode': string;
}
/**
 * 
 * @export
 * @interface UpdatePinRequest
 */
export interface UpdatePinRequest {
    /**
     * The PIN code to set
     * @type {string}
     * @memberof UpdatePinRequest
     */
    'pin': string;
}
/**
 * 
 * @export
 * @interface UpdatePointOfSaleRequest
 */
export interface UpdatePointOfSaleRequest {
    /**
     * Name of the POS
     * @type {string}
     * @memberof UpdatePointOfSaleRequest
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof UpdatePointOfSaleRequest
     */
    'useAuthentication': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdatePointOfSaleRequest
     */
    'containers'?: Array<number>;
    /**
     * ID of the POS to update.
     * @type {number}
     * @memberof UpdatePointOfSaleRequest
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface UpdateProductRequest
 */
export interface UpdateProductRequest {
    /**
     * Name of the product
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof UpdateProductRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * VAT group ID of the product
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'vat': number;
    /**
     * Category of the product
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'category': number;
    /**
     * Alcohol percentage of the product in 2 decimals
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'alcoholPercentage': number;
}
/**
 * 
 * @export
 * @interface UpdateShiftRequest
 */
export interface UpdateShiftRequest {
    /**
     * Name of the event
     * @type {string}
     * @memberof UpdateShiftRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateShiftRequest
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'canGoIntoDebt'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'ofAge'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateVatGroupRequest
 */
export interface UpdateVatGroupRequest {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof UpdateVatGroupRequest
     */
    'name': string;
    /**
     * Whether this group should be hidden in the financial overviews when its value is zero
     * @type {boolean}
     * @memberof UpdateVatGroupRequest
     */
    'deleted': boolean;
    /**
     * Whether this group should be hidden from transactions
     * @type {boolean}
     * @memberof UpdateVatGroupRequest
     */
    'hidden': boolean;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof User
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * First name of the user.
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * Last name of the user.
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * Nickname of the user.
     * @type {string}
     * @memberof User
     */
    'nickname'?: string;
    /**
     * Whether the user has accepted the TOS. Defaults to false.
     * @type {boolean}
     * @memberof User
     */
    'active'?: boolean;
    /**
     * Whether the user can have a negative balance. Defaults to false
     * @type {boolean}
     * @memberof User
     */
    'canGoIntoDebt'?: boolean;
    /**
     * Whether the user is 18+ or not.
     * @type {boolean}
     * @memberof User
     */
    'ofAge'?: boolean;
    /**
     * The email of the user.
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * Whether the user was deleted. Defaults to false.
     * @type {boolean}
     * @memberof User
     */
    'deleted'?: boolean;
    /**
     * The type of user.
     * @type {string}
     * @memberof User
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface UserAllOf
 */
export interface UserAllOf {
    /**
     * First name of the user.
     * @type {string}
     * @memberof UserAllOf
     */
    'firstName': string;
    /**
     * Last name of the user.
     * @type {string}
     * @memberof UserAllOf
     */
    'lastName'?: string;
    /**
     * Nickname of the user.
     * @type {string}
     * @memberof UserAllOf
     */
    'nickname'?: string;
    /**
     * Whether the user has accepted the TOS. Defaults to false.
     * @type {boolean}
     * @memberof UserAllOf
     */
    'active'?: boolean;
    /**
     * Whether the user can have a negative balance. Defaults to false
     * @type {boolean}
     * @memberof UserAllOf
     */
    'canGoIntoDebt'?: boolean;
    /**
     * Whether the user is 18+ or not.
     * @type {boolean}
     * @memberof UserAllOf
     */
    'ofAge'?: boolean;
    /**
     * The email of the user.
     * @type {string}
     * @memberof UserAllOf
     */
    'email'?: string;
    /**
     * Whether the user was deleted. Defaults to false.
     * @type {boolean}
     * @memberof UserAllOf
     */
    'deleted'?: boolean;
    /**
     * The type of user.
     * @type {string}
     * @memberof UserAllOf
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface UserFineGroupResponse
 */
export interface UserFineGroupResponse {
    /**
     * 
     * @type {Array<FineResponse>}
     * @memberof UserFineGroupResponse
     */
    'fines': Array<FineResponse>;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof UserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof UserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof UserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof UserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof UserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof UserResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof UserResponse
     */
    'nickname'?: string;
    /**
     * Whether the user activated
     * @type {boolean}
     * @memberof UserResponse
     */
    'active': boolean;
    /**
     * Whether the user is deleted
     * @type {boolean}
     * @memberof UserResponse
     */
    'deleted': boolean;
    /**
     * The type of user
     * @type {string}
     * @memberof UserResponse
     */
    'type': string;
    /**
     * If local user, the e-mail of the user
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * Whether this user has accepted the TOS
     * @type {string}
     * @memberof UserResponse
     */
    'acceptedToS'?: string;
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof UserResponse
     */
    'extensiveDataProcessing'?: boolean;
    /**
     * Whether someone is old enough to drink beer
     * @type {boolean}
     * @memberof UserResponse
     */
    'ofAge'?: boolean;
    /**
     * Whether this user can get a negative balance
     * @type {boolean}
     * @memberof UserResponse
     */
    'canGoIntoDebt': boolean;
}
/**
 * 
 * @export
 * @interface UserResponseAllOf
 */
export interface UserResponseAllOf {
    /**
     * Whether the user activated
     * @type {boolean}
     * @memberof UserResponseAllOf
     */
    'active': boolean;
    /**
     * Whether the user is deleted
     * @type {boolean}
     * @memberof UserResponseAllOf
     */
    'deleted': boolean;
    /**
     * The type of user
     * @type {string}
     * @memberof UserResponseAllOf
     */
    'type': string;
    /**
     * If local user, the e-mail of the user
     * @type {string}
     * @memberof UserResponseAllOf
     */
    'email'?: string;
    /**
     * Whether this user has accepted the TOS
     * @type {string}
     * @memberof UserResponseAllOf
     */
    'acceptedToS'?: string;
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof UserResponseAllOf
     */
    'extensiveDataProcessing'?: boolean;
    /**
     * Whether someone is old enough to drink beer
     * @type {boolean}
     * @memberof UserResponseAllOf
     */
    'ofAge'?: boolean;
    /**
     * Whether this user can get a negative balance
     * @type {boolean}
     * @memberof UserResponseAllOf
     */
    'canGoIntoDebt': boolean;
}
/**
 * 
 * @export
 * @interface UserToFineResponse
 */
export interface UserToFineResponse {
    /**
     * User ID
     * @type {number}
     * @memberof UserToFineResponse
     */
    'id': number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof UserToFineResponse
     */
    'fineAmount': DineroObjectResponse;
    /**
     * 
     * @type {Array<BalanceResponse>}
     * @memberof UserToFineResponse
     */
    'balances': Array<BalanceResponse>;
}
/**
 * 
 * @export
 * @interface UserVoucherGroup
 */
export interface UserVoucherGroup {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof UserVoucherGroup
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof UserVoucherGroup
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof UserVoucherGroup
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof UserVoucherGroup
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof UserVoucherGroup
     */
    'user': User;
    /**
     * 
     * @type {VoucherGroup}
     * @memberof UserVoucherGroup
     */
    'voucherGroup': VoucherGroup;
}
/**
 * 
 * @export
 * @interface UserVoucherGroupAllOf
 */
export interface UserVoucherGroupAllOf {
    /**
     * 
     * @type {User}
     * @memberof UserVoucherGroupAllOf
     */
    'user': User;
    /**
     * 
     * @type {VoucherGroup}
     * @memberof UserVoucherGroupAllOf
     */
    'voucherGroup': VoucherGroup;
}
/**
 * 
 * @export
 * @interface VatDeclarationResponse
 */
export interface VatDeclarationResponse {
    /**
     * Calendar year of this result table
     * @type {number}
     * @memberof VatDeclarationResponse
     */
    'calendarYear': number;
    /**
     * The used VAT declaration period the rows below are based upon
     * @type {string}
     * @memberof VatDeclarationResponse
     */
    'period': string;
    /**
     * 
     * @type {Array<VatDeclarationRow>}
     * @memberof VatDeclarationResponse
     */
    'rows': Array<VatDeclarationRow>;
}
/**
 * 
 * @export
 * @interface VatDeclarationRow
 */
export interface VatDeclarationRow {
    /**
     * ID of the VAT group
     * @type {number}
     * @memberof VatDeclarationRow
     */
    'id': number;
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatDeclarationRow
     */
    'name': string;
    /**
     * Percentage of VAT in this group
     * @type {number}
     * @memberof VatDeclarationRow
     */
    'percentage': number;
    /**
     * 
     * @type {Array<DineroObject>}
     * @memberof VatDeclarationRow
     */
    'values': Array<DineroObject>;
}
/**
 * 
 * @export
 * @interface VatGroup
 */
export interface VatGroup {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof VatGroup
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof VatGroup
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof VatGroup
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof VatGroup
     */
    'id': number;
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroup
     */
    'name'?: string;
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroup
     */
    'percentage'?: number;
    /**
     * Whether this group is soft-deleted
     * @type {boolean}
     * @memberof VatGroup
     */
    'deleted'?: boolean;
    /**
     * Whether this group is hidden from transactions
     * @type {boolean}
     * @memberof VatGroup
     */
    'hidden'?: boolean;
}
/**
 * 
 * @export
 * @interface VatGroupAllOf
 */
export interface VatGroupAllOf {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroupAllOf
     */
    'name'?: string;
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroupAllOf
     */
    'percentage'?: number;
    /**
     * Whether this group is soft-deleted
     * @type {boolean}
     * @memberof VatGroupAllOf
     */
    'deleted'?: boolean;
    /**
     * Whether this group is hidden from transactions
     * @type {boolean}
     * @memberof VatGroupAllOf
     */
    'hidden'?: boolean;
}
/**
 * 
 * @export
 * @interface VatGroupRequest
 */
export interface VatGroupRequest {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroupRequest
     */
    'name': string;
    /**
     * Whether this group should be hidden in the financial overviews when its value is zero
     * @type {boolean}
     * @memberof VatGroupRequest
     */
    'deleted': boolean;
    /**
     * Whether this group should be hidden from transactions
     * @type {boolean}
     * @memberof VatGroupRequest
     */
    'hidden': boolean;
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroupRequest
     */
    'percentage': number;
}
/**
 * 
 * @export
 * @interface VatGroupRequestAllOf
 */
export interface VatGroupRequestAllOf {
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroupRequestAllOf
     */
    'percentage': number;
}
/**
 * 
 * @export
 * @interface VoucherGroup
 */
export interface VoucherGroup {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof VoucherGroup
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof VoucherGroup
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof VoucherGroup
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof VoucherGroup
     */
    'id': number;
    /**
     * Name of the group.
     * @type {string}
     * @memberof VoucherGroup
     */
    'name': string;
    /**
     * Date after which the included cards are active.
     * @type {string}
     * @memberof VoucherGroup
     */
    'activeStartDate': string;
    /**
     * Date after which cards are no longer active.
     * @type {string}
     * @memberof VoucherGroup
     */
    'activeEndDate'?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof VoucherGroup
     */
    'vouchers': Array<User>;
}
/**
 * 
 * @export
 * @interface VoucherGroupAllOf
 */
export interface VoucherGroupAllOf {
    /**
     * Name of the group.
     * @type {string}
     * @memberof VoucherGroupAllOf
     */
    'name': string;
    /**
     * Date after which the included cards are active.
     * @type {string}
     * @memberof VoucherGroupAllOf
     */
    'activeStartDate': string;
    /**
     * Date after which cards are no longer active.
     * @type {string}
     * @memberof VoucherGroupAllOf
     */
    'activeEndDate'?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof VoucherGroupAllOf
     */
    'vouchers': Array<User>;
}
/**
 * 
 * @export
 * @interface VoucherGroupRequest
 */
export interface VoucherGroupRequest {
    /**
     * Name of the group
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'name': string;
    /**
     * Date from which the included cards are active
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'activeStartDate': string;
    /**
     * Date from which cards are no longer active
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'activeEndDate': string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof VoucherGroupRequest
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the voucher group
     * @type {number}
     * @memberof VoucherGroupRequest
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface VoucherGroupResponse
 */
export interface VoucherGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'version'?: number;
    /**
     * Name of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'name': string;
    /**
     * Start date of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'activeStartDate'?: string;
    /**
     * End date of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'activeEndDate': string;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof VoucherGroupResponse
     */
    'users': Array<UserResponse>;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof VoucherGroupResponse
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the voucher group
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface VoucherGroupResponseAllOf
 */
export interface VoucherGroupResponseAllOf {
    /**
     * Name of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponseAllOf
     */
    'name': string;
    /**
     * Start date of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponseAllOf
     */
    'activeStartDate'?: string;
    /**
     * End date of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponseAllOf
     */
    'activeEndDate': string;
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof VoucherGroupResponseAllOf
     */
    'users': Array<UserResponse>;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof VoucherGroupResponseAllOf
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the voucher group
     * @type {number}
     * @memberof VoucherGroupResponseAllOf
     */
    'amount': number;
}

/**
 * AuthenticateApi - axios parameter creator
 * @export
 */
export const AuthenticateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  EAN login and hand out token
         * @param {AuthenticationEanRequest} req The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication: async (req: AuthenticationEanRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('eanAuthentication', 'req', req)
            const localVarPath = `/authentication/ean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication: async (req: AuthenticationLDAPRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('gewisLDAPAuthentication', 'req', req)
            const localVarPath = `/authentication/GEWIS/LDAP`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication: async (req: GEWISAuthenticationPinRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('gewisPinAuthentication', 'req', req)
            const localVarPath = `/authentication/GEWIS/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication: async (req: GewiswebAuthenticationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('gewisWebAuthentication', 'req', req)
            const localVarPath = `/authentication/gewisweb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Key login and hand out token.
         * @param {AuthenticationKeyRequest} req The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication: async (req: AuthenticationKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('keyAuthentication', 'req', req)
            const localVarPath = `/authentication/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAuthentication: async (req: AuthenticationLDAPRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('ldapAuthentication', 'req', req)
            const localVarPath = `/authentication/LDAP`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Local login and hand out token
         * @param {AuthenticationLocalRequest} req The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication: async (req: AuthenticationLocalRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('localAuthentication', 'req', req)
            const localVarPath = `/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Mock login and hand out token.
         * @param {AuthenticationMockRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication: async (req: AuthenticationMockRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('mockAuthentication', 'req', req)
            const localVarPath = `/authentication/mock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  NFC login and hand out token
         * @param {AuthenticationNfcRequest} req The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication: async (req: AuthenticationNfcRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('nfcAuthentication', 'req', req)
            const localVarPath = `/authentication/nfc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  PIN login and hand out token
         * @param {AuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication: async (req: AuthenticationPinRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('pinAuthentication', 'req', req)
            const localVarPath = `/authentication/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authentication/refreshToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Creates a reset token for the local authentication
         * @param {ResetLocalRequest} req The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal: async (req: ResetLocalRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('resetLocal', 'req', req)
            const localVarPath = `/authentication/local/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} req The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken: async (req: AuthenticationResetTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'req' is not null or undefined
            assertParamExists('resetLocalWithToken', 'req', req)
            const localVarPath = `/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(req, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticateApi - functional programming interface
 * @export
 */
export const AuthenticateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticateApiAxiosParamCreator(configuration)
    return {
        /**
         *  EAN login and hand out token
         * @param {AuthenticationEanRequest} req The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eanAuthentication(req: AuthenticationEanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eanAuthentication(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gewisLDAPAuthentication(req: AuthenticationLDAPRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gewisLDAPAuthentication(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gewisPinAuthentication(req: GEWISAuthenticationPinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gewisPinAuthentication(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gewisWebAuthentication(req: GewiswebAuthenticationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gewisWebAuthentication(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Key login and hand out token.
         * @param {AuthenticationKeyRequest} req The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyAuthentication(req: AuthenticationKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyAuthentication(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ldapAuthentication(req: AuthenticationLDAPRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ldapAuthentication(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Local login and hand out token
         * @param {AuthenticationLocalRequest} req The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localAuthentication(req: AuthenticationLocalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localAuthentication(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Mock login and hand out token.
         * @param {AuthenticationMockRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mockAuthentication(req: AuthenticationMockRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mockAuthentication(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  NFC login and hand out token
         * @param {AuthenticationNfcRequest} req The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nfcAuthentication(req: AuthenticationNfcRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nfcAuthentication(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  PIN login and hand out token
         * @param {AuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinAuthentication(req: AuthenticationPinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinAuthentication(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Creates a reset token for the local authentication
         * @param {ResetLocalRequest} req The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetLocal(req: ResetLocalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetLocal(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} req The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetLocalWithToken(req: AuthenticationResetTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetLocalWithToken(req, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticateApi - factory interface
 * @export
 */
export const AuthenticateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticateApiFp(configuration)
    return {
        /**
         *  EAN login and hand out token
         * @param {AuthenticationEanRequest} req The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication(req: AuthenticationEanRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.eanAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication(req: AuthenticationLDAPRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.gewisLDAPAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication(req: GEWISAuthenticationPinRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.gewisPinAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication(req: GewiswebAuthenticationRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.gewisWebAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  Key login and hand out token.
         * @param {AuthenticationKeyRequest} req The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication(req: AuthenticationKeyRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.keyAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAuthentication(req: AuthenticationLDAPRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.ldapAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  Local login and hand out token
         * @param {AuthenticationLocalRequest} req The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication(req: AuthenticationLocalRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.localAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  Mock login and hand out token.
         * @param {AuthenticationMockRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication(req: AuthenticationMockRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.mockAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  NFC login and hand out token
         * @param {AuthenticationNfcRequest} req The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication(req: AuthenticationNfcRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.nfcAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  PIN login and hand out token
         * @param {AuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication(req: AuthenticationPinRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.pinAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         *  Creates a reset token for the local authentication
         * @param {ResetLocalRequest} req The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal(req: ResetLocalRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resetLocal(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} req The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken(req: AuthenticationResetTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resetLocalWithToken(req, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticateApi - object-oriented interface
 * @export
 * @class AuthenticateApi
 * @extends {BaseAPI}
 */
export class AuthenticateApi extends BaseAPI {
    /**
     *  EAN login and hand out token
     * @param {AuthenticationEanRequest} req The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public eanAuthentication(req: AuthenticationEanRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).eanAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public gewisLDAPAuthentication(req: AuthenticationLDAPRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).gewisLDAPAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public gewisPinAuthentication(req: GEWISAuthenticationPinRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).gewisPinAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public gewisWebAuthentication(req: GewiswebAuthenticationRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).gewisWebAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Key login and hand out token.
     * @param {AuthenticationKeyRequest} req The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public keyAuthentication(req: AuthenticationKeyRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).keyAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public ldapAuthentication(req: AuthenticationLDAPRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).ldapAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Local login and hand out token
     * @param {AuthenticationLocalRequest} req The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public localAuthentication(req: AuthenticationLocalRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).localAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Mock login and hand out token.
     * @param {AuthenticationMockRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public mockAuthentication(req: AuthenticationMockRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).mockAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  NFC login and hand out token
     * @param {AuthenticationNfcRequest} req The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public nfcAuthentication(req: AuthenticationNfcRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).nfcAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  PIN login and hand out token
     * @param {AuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public pinAuthentication(req: AuthenticationPinRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).pinAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public refreshToken(options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Creates a reset token for the local authentication
     * @param {ResetLocalRequest} req The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public resetLocal(req: ResetLocalRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).resetLocal(req, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} req The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public resetLocalWithToken(req: AuthenticationResetTokenRequest, options?: AxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).resetLocalWithToken(req, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BalanceApi - axios parameter creator
 * @export
 */
export const BalanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Get balance of the current user
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {string} [userType] {MEMBER,ORGAN,VOUCHER,LOCAL_USER,LOCAL_ADMIN,INVOICE,AUTOMATIC_INVOICE} - Filter based on user type.
         * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
         * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance: async (date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userType?: string, orderBy?: 'id' | 'amount', orderDirection?: 'ASC' | 'DESC', take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/balances/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (minBalance !== undefined) {
                localVarQueryParameter['minBalance'] = minBalance;
            }

            if (maxBalance !== undefined) {
                localVarQueryParameter['maxBalance'] = maxBalance;
            }

            if (hasFine !== undefined) {
                localVarQueryParameter['hasFine'] = hasFine;
            }

            if (minFine !== undefined) {
                localVarQueryParameter['minFine'] = minFine;
            }

            if (maxFine !== undefined) {
                localVarQueryParameter['maxFine'] = maxFine;
            }

            if (userType !== undefined) {
                localVarQueryParameter['userType[]'] = userType;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBalanceId', 'id', id)
            const localVarPath = `/balances/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceApi - functional programming interface
 * @export
 */
export const BalanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalanceApiAxiosParamCreator(configuration)
    return {
        /**
         *  Get balance of the current user
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {string} [userType] {MEMBER,ORGAN,VOUCHER,LOCAL_USER,LOCAL_ADMIN,INVOICE,AUTOMATIC_INVOICE} - Filter based on user type.
         * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
         * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userType?: string, orderBy?: 'id' | 'amount', orderDirection?: 'ASC' | 'DESC', take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userType, orderBy, orderDirection, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalances(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalances(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BalanceApi - factory interface
 * @export
 */
export const BalanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalanceApiFp(configuration)
    return {
        /**
         *  Get balance of the current user
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {string} [userType] {MEMBER,ORGAN,VOUCHER,LOCAL_USER,LOCAL_ADMIN,INVOICE,AUTOMATIC_INVOICE} - Filter based on user type.
         * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
         * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userType?: string, orderBy?: 'id' | 'amount', orderDirection?: 'ASC' | 'DESC', take?: number, skip?: number, options?: any): AxiosPromise<Array<BalanceResponse>> {
            return localVarFp.getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userType, orderBy, orderDirection, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId(id: number, options?: any): AxiosPromise<BalanceResponse> {
            return localVarFp.getBalanceId(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances(options?: any): AxiosPromise<BalanceResponse> {
            return localVarFp.getBalances(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalanceApi - object-oriented interface
 * @export
 * @class BalanceApi
 * @extends {BaseAPI}
 */
export class BalanceApi extends BaseAPI {
    /**
     *  Get balance of the current user
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {boolean} [hasFine] Only users with(out) fines
     * @param {number} [minFine] Minimum fine
     * @param {number} [maxFine] Maximum fine
     * @param {string} [userType] {MEMBER,ORGAN,VOUCHER,LOCAL_USER,LOCAL_ADMIN,INVOICE,AUTOMATIC_INVOICE} - Filter based on user type.
     * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
     * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userType?: string, orderBy?: 'id' | 'amount', orderDirection?: 'ASC' | 'DESC', take?: number, skip?: number, options?: AxiosRequestConfig) {
        return BalanceApiFp(this.configuration).getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userType, orderBy, orderDirection, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public getBalanceId(id: number, options?: AxiosRequestConfig) {
        return BalanceApiFp(this.configuration).getBalanceId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public getBalances(options?: AxiosRequestConfig) {
        return BalanceApiFp(this.configuration).getBalances(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BannersApi - axios parameter creator
 * @export
 */
export const BannersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Saves a banner to the database
         * @param {BannerRequest} banner The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (banner: BannerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'banner' is not null or undefined
            assertParamExists('create', 'banner', banner)
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(banner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banners/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/open/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBanner', 'id', id)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} banner The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: number, banner: BannerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'banner' is not null or undefined
            assertParamExists('update', 'banner', banner)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(banner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage: async (id: number, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateImage', 'id', id)
            const localVarPath = `/banners/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BannersApi - functional programming interface
 * @export
 */
export const BannersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BannersApiAxiosParamCreator(configuration)
    return {
        /**
         *  Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Saves a banner to the database
         * @param {BannerRequest} banner The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(banner: BannerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(banner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActive(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActive(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBanners(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBanners(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOpenBanners(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOpenBanners(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBanner(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBanner(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} banner The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: number, banner: BannerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, banner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImage(id: number, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImage(id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BannersApi - factory interface
 * @export
 */
export const BannersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BannersApiFp(configuration)
    return {
        /**
         *  Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): AxiosPromise<BannerResponse> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Saves a banner to the database
         * @param {BannerRequest} banner The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(banner: BannerRequest, options?: any): AxiosPromise<BannerResponse> {
            return localVarFp.create(banner, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse> {
            return localVarFp.getActive(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse> {
            return localVarFp.getAllBanners(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse> {
            return localVarFp.getAllOpenBanners(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner(id: number, options?: any): AxiosPromise<BannerResponse> {
            return localVarFp.getBanner(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} banner The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: number, banner: BannerRequest, options?: any): AxiosPromise<BannerResponse> {
            return localVarFp.update(id, banner, options).then((request) => request(axios, basePath));
        },
        /**
         *  Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id: number, file?: File, options?: any): AxiosPromise<void> {
            return localVarFp.updateImage(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BannersApi - object-oriented interface
 * @export
 * @class BannersApi
 * @extends {BaseAPI}
 */
export class BannersApi extends BaseAPI {
    /**
     *  Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public _delete(id: number, options?: AxiosRequestConfig) {
        return BannersApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Saves a banner to the database
     * @param {BannerRequest} banner The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public create(banner: BannerRequest, options?: AxiosRequestConfig) {
        return BannersApiFp(this.configuration).create(banner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getActive(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return BannersApiFp(this.configuration).getActive(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getAllBanners(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return BannersApiFp(this.configuration).getAllBanners(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getAllOpenBanners(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return BannersApiFp(this.configuration).getAllOpenBanners(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getBanner(id: number, options?: AxiosRequestConfig) {
        return BannersApiFp(this.configuration).getBanner(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} banner The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public update(id: number, banner: BannerRequest, options?: AxiosRequestConfig) {
        return BannersApiFp(this.configuration).update(id, banner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public updateImage(id: number, file?: File, options?: AxiosRequestConfig) {
        return BannersApiFp(this.configuration).updateImage(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Create a new container.
         * @param {CreateContainerRequest} container    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer: async (container: CreateContainerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'container' is not null or undefined
            assertParamExists('createContainer', 'container', container)
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(container, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer: async (id: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductsContainer', 'id', id)
            const localVarPath = `/containers/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/containers/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleContainer', 'id', id)
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} container    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: async (id: number, container: UpdateContainerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateContainer', 'id', id)
            // verify required parameter 'container' is not null or undefined
            assertParamExists('updateContainer', 'container', container)
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(container, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainersApiAxiosParamCreator(configuration)
    return {
        /**
         *  Create a new container.
         * @param {CreateContainerRequest} container    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainer(container: CreateContainerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainer(container, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllContainers(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllContainers(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsContainer(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsContainer(id, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicContainers(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicContainers(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleContainer(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleContainer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} container    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainer(id: number, container: UpdateContainerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainer(id, container, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainersApiFp(configuration)
    return {
        /**
         *  Create a new container.
         * @param {CreateContainerRequest} container    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(container: CreateContainerRequest, options?: any): AxiosPromise<ContainerWithProductsResponse> {
            return localVarFp.createContainer(container, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getAllContainers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse> {
            return localVarFp.getProductsContainer(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getPublicContainers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer(id: number, options?: any): AxiosPromise<ContainerWithProductsResponse> {
            return localVarFp.getSingleContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} container    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(id: number, container: UpdateContainerRequest, options?: any): AxiosPromise<ContainerWithProductsResponse> {
            return localVarFp.updateContainer(id, container, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     *  Create a new container.
     * @param {CreateContainerRequest} container    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public createContainer(container: CreateContainerRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).createContainer(container, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getAllContainers(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getAllContainers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getProductsContainer(id: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getProductsContainer(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getPublicContainers(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getPublicContainers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getSingleContainer(id: number, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getSingleContainer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} container    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainer(id: number, container: UpdateContainerRequest, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).updateContainer(id, container, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DebtorsApi - axios parameter creator
 * @export
 */
export const DebtorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Return all users that had at most -5 euros balance both now and on the reference date For all these users, also return their fine based on the reference date.
         * @param {string} referenceDates Dates to base the fines on. Every returned user has at least five euros debt on every reference date. The height of the fine is based on the first date in the array.
         * @param {string} [userTypes] List of all user types fines should be calculated for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateFines: async (referenceDates: string, userTypes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referenceDates' is not null or undefined
            assertParamExists('calculateFines', 'referenceDates', referenceDates)
            const localVarPath = `/fines/eligible`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userTypes !== undefined) {
                localVarQueryParameter['userTypes'] = userTypes;
            }

            if (referenceDates !== undefined) {
                localVarQueryParameter['referenceDates'] = referenceDates;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFine: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFine', 'id', id)
            const localVarPath = `/fines/single/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoutFines: async (body: HandoutFinesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('handoutFines', 'body', body)
            const localVarPath = `/fines/handout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyAboutFutureFines: async (body: HandoutFinesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notifyAboutFutureFines', 'body', body)
            const localVarPath = `/fines/notify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnAllFineHandoutEvents: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnSingleFineHandoutEvent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('returnSingleFineHandoutEvent', 'id', id)
            const localVarPath = `/fines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DebtorsApi - functional programming interface
 * @export
 */
export const DebtorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DebtorsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Return all users that had at most -5 euros balance both now and on the reference date For all these users, also return their fine based on the reference date.
         * @param {string} referenceDates Dates to base the fines on. Every returned user has at least five euros debt on every reference date. The height of the fine is based on the first date in the array.
         * @param {string} [userTypes] List of all user types fines should be calculated for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateFines(referenceDates: string, userTypes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserToFineResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateFines(referenceDates, userTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFine(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFine(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handoutFines(body: HandoutFinesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineHandoutEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handoutFines(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyAboutFutureFines(body: HandoutFinesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyAboutFutureFines(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnAllFineHandoutEvents(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFineHandoutEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnAllFineHandoutEvents(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnSingleFineHandoutEvent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineHandoutEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnSingleFineHandoutEvent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DebtorsApi - factory interface
 * @export
 */
export const DebtorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DebtorsApiFp(configuration)
    return {
        /**
         *  Return all users that had at most -5 euros balance both now and on the reference date For all these users, also return their fine based on the reference date.
         * @param {string} referenceDates Dates to base the fines on. Every returned user has at least five euros debt on every reference date. The height of the fine is based on the first date in the array.
         * @param {string} [userTypes] List of all user types fines should be calculated for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateFines(referenceDates: string, userTypes?: string, options?: any): AxiosPromise<Array<UserToFineResponse>> {
            return localVarFp.calculateFines(referenceDates, userTypes, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFine(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFine(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoutFines(body: HandoutFinesRequest, options?: any): AxiosPromise<FineHandoutEventResponse> {
            return localVarFp.handoutFines(body, options).then((request) => request(axios, basePath));
        },
        /**
         *  Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyAboutFutureFines(body: HandoutFinesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.notifyAboutFutureFines(body, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnAllFineHandoutEvents(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedFineHandoutEventResponse> {
            return localVarFp.returnAllFineHandoutEvents(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnSingleFineHandoutEvent(id: number, options?: any): AxiosPromise<FineHandoutEventResponse> {
            return localVarFp.returnSingleFineHandoutEvent(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DebtorsApi - object-oriented interface
 * @export
 * @class DebtorsApi
 * @extends {BaseAPI}
 */
export class DebtorsApi extends BaseAPI {
    /**
     *  Return all users that had at most -5 euros balance both now and on the reference date For all these users, also return their fine based on the reference date.
     * @param {string} referenceDates Dates to base the fines on. Every returned user has at least five euros debt on every reference date. The height of the fine is based on the first date in the array.
     * @param {string} [userTypes] List of all user types fines should be calculated for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public calculateFines(referenceDates: string, userTypes?: string, options?: AxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).calculateFines(referenceDates, userTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete a fine
     * @param {number} id The id of the fine which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public deleteFine(id: number, options?: AxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).deleteFine(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
     * @param {HandoutFinesRequest} body null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public handoutFines(body: HandoutFinesRequest, options?: AxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).handoutFines(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Send an email to all given users about their possible future fine.
     * @param {HandoutFinesRequest} body null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public notifyAboutFutureFines(body: HandoutFinesRequest, options?: AxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).notifyAboutFutureFines(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get all fine handout events
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public returnAllFineHandoutEvents(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).returnAllFineHandoutEvents(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get all fine handout events
     * @param {number} id The id of the fine handout event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public returnSingleFineHandoutEvent(id: number, options?: AxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).returnSingleFineHandoutEvent(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignEventShift: async (eventId: number, shiftId: number, userId: number, body: EventAnswerAssignmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('assignEventShift', 'eventId', eventId)
            // verify required parameter 'shiftId' is not null or undefined
            assertParamExists('assignEventShift', 'shiftId', shiftId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignEventShift', 'userId', userId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('assignEventShift', 'body', body)
            const localVarPath = `/events/{eventId}/shift/{shiftId}/user/{userId}/assign`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"shiftId"}}`, encodeURIComponent(String(shiftId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Create an event with its corresponding answers objects
         * @param {CreateEventRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (body: CreateEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createEvent', 'body', body)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Create an event shift
         * @param {CreateShiftRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventShift: async (body: CreateShiftRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createEventShift', 'body', body)
            const localVarPath = `/eventshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventShift: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEventShift', 'id', id)
            const localVarPath = `/eventshifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventShifts: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eventshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents: async (name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = beforeDate;
            }

            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = afterDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event which should be deleted
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShiftSelectedCount: async (id: number, eventType?: string, afterDate?: string, beforeDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getShiftSelectedCount', 'id', id)
            const localVarPath = `/eventshifts/{id}/counts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = afterDate;
            }

            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = beforeDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Synchronize an event, so that EventShiftAnswers are created/deleted for users that are (no longer) part of a shift
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncEventShiftAnswers: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('syncEventShiftAnswers', 'id', id)
            const localVarPath = `/events/{id}/sync`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (id: number, body: UpdateEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEvent', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateEvent', 'body', body)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventShift: async (id: number, body: UpdateShiftRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEventShift', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateEventShift', 'body', body)
            const localVarPath = `/eventshifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventShiftAvailability: async (eventId: number, shiftId: number, userId: number, body: EventAnswerAvailabilityRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'eventId', eventId)
            // verify required parameter 'shiftId' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'shiftId', shiftId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'userId', userId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'body', body)
            const localVarPath = `/events/{eventId}/shift/{shiftId}/user/{userId}/availability`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"shiftId"}}`, encodeURIComponent(String(shiftId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignEventShift(eventId: number, shiftId: number, userId: number, body: EventAnswerAssignmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEventAnswerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignEventShift(eventId, shiftId, userId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Create an event with its corresponding answers objects
         * @param {CreateEventRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(body: CreateEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Create an event shift
         * @param {CreateShiftRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventShift(body: CreateShiftRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventShiftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventShift(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventShift(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventShift(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEventShifts(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEventShiftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEventShifts(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event which should be deleted
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShiftSelectedCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventPlanningSelectedCount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShiftSelectedCount(id, eventType, afterDate, beforeDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleEvent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleEvent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Synchronize an event, so that EventShiftAnswers are created/deleted for users that are (no longer) part of a shift
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncEventShiftAnswers(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncEventShiftAnswers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(id: number, body: UpdateEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventShift(id: number, body: UpdateShiftRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventShiftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventShift(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, body: EventAnswerAvailabilityRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEventAnswerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventShiftAvailability(eventId, shiftId, userId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         *  Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignEventShift(eventId: number, shiftId: number, userId: number, body: EventAnswerAssignmentRequest, options?: any): AxiosPromise<BaseEventAnswerResponse> {
            return localVarFp.assignEventShift(eventId, shiftId, userId, body, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create an event with its corresponding answers objects
         * @param {CreateEventRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(body: CreateEventRequest, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.createEvent(body, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create an event shift
         * @param {CreateShiftRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventShift(body: CreateShiftRequest, options?: any): AxiosPromise<EventShiftResponse> {
            return localVarFp.createEventShift(body, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventShift(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventShift(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventShifts(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedEventShiftResponse> {
            return localVarFp.getAllEventShifts(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseEventResponse> {
            return localVarFp.getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event which should be deleted
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShiftSelectedCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: any): AxiosPromise<Array<EventPlanningSelectedCount>> {
            return localVarFp.getShiftSelectedCount(id, eventType, afterDate, beforeDate, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent(id: number, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.getSingleEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Synchronize an event, so that EventShiftAnswers are created/deleted for users that are (no longer) part of a shift
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncEventShiftAnswers(id: number, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.syncEventShiftAnswers(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(id: number, body: UpdateEventRequest, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.updateEvent(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventShift(id: number, body: UpdateShiftRequest, options?: any): AxiosPromise<EventShiftResponse> {
            return localVarFp.updateEventShift(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} body null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, body: EventAnswerAvailabilityRequest, options?: any): AxiosPromise<BaseEventAnswerResponse> {
            return localVarFp.updateEventShiftAvailability(eventId, shiftId, userId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     *  Change the assignment of users to shifts on an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAssignmentRequest} body null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public assignEventShift(eventId: number, shiftId: number, userId: number, body: EventAnswerAssignmentRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).assignEventShift(eventId, shiftId, userId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Create an event with its corresponding answers objects
     * @param {CreateEventRequest} body null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEvent(body: CreateEventRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEvent(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Create an event shift
     * @param {CreateShiftRequest} body null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEventShift(body: CreateShiftRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEventShift(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete an event with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEvent(id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete an event shift with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEventShift(id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEventShift(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get all event shifts
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getAllEventShifts(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getAllEventShifts(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get all events
     * @param {string} [name] Name of the event
     * @param {number} [createdById] ID of user that created the event
     * @param {string} [beforeDate] Get only events that start after this date
     * @param {string} [afterDate] Get only events that start before this date
     * @param {string} [type] Get only events that are this type
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get the number of times a user has been selected for the given shift
     * @param {number} id The id of the event which should be deleted
     * @param {string} [eventType] Only include events of this type
     * @param {string} [afterDate] Only include events after this date
     * @param {string} [beforeDate] Only include events before this date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getShiftSelectedCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getShiftSelectedCount(id, eventType, afterDate, beforeDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get a single event with its answers and shifts
     * @param {number} id The id of the event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getSingleEvent(id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getSingleEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Synchronize an event, so that EventShiftAnswers are created/deleted for users that are (no longer) part of a shift
     * @param {number} id The id of the event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public syncEventShiftAnswers(id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).syncEventShiftAnswers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update an event with its corresponding answers objects
     * @param {number} id The id of the event which should be returned
     * @param {UpdateEventRequest} body null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(id: number, body: UpdateEventRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEvent(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update an event shift
     * @param {number} id The id of the event which should be returned
     * @param {UpdateShiftRequest} body null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEventShift(id: number, body: UpdateShiftRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEventShift(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update the availability of a user for a shift in an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAvailabilityRequest} body null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, body: EventAnswerAvailabilityRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEventShiftAvailability(eventId, shiftId, userId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Upload a file with the given name.
         * @param {File} [file] null
         * @param {string} [name] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (file?: File, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Upload a file with the given name.
         * @param {File} [file] null
         * @param {string} [name] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(file?: File, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(file, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         *  Upload a file with the given name.
         * @param {File} [file] null
         * @param {string} [name] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(file?: File, name?: string, options?: any): AxiosPromise<SimpleFileResponse> {
            return localVarFp.createFile(file, name, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getFile(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     *  Upload a file with the given name.
     * @param {File} [file] null
     * @param {string} [name] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public createFile(file?: File, name?: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).createFile(file, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFile(id: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(id: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFile(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Adds an invoice to the system.
         * @param {CreateInvoiceRequest} invoice The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice: async (invoice: CreateInvoiceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoice' is not null or undefined
            assertParamExists('createInvoice', 'invoice', invoice)
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoice, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInvoice', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices: async (toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (invoiceId !== undefined) {
                localVarQueryParameter['invoiceId'] = invoiceId;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (returnEntries !== undefined) {
                localVarQueryParameter['returnEntries'] = returnEntries;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice: async (id: number, returnEntries?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleInvoice', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (returnEntries !== undefined) {
                localVarQueryParameter['returnEntries'] = returnEntries;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} invoice The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice: async (id: number, invoice: UpdateInvoiceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateInvoice', 'id', id)
            // verify required parameter 'invoice' is not null or undefined
            assertParamExists('updateInvoice', 'invoice', invoice)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoice, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Adds an invoice to the system.
         * @param {CreateInvoiceRequest} invoice The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoice(invoice: CreateInvoiceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoice(invoice, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoice(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoice(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllInvoices(toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleInvoice(id: number, returnEntries?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleInvoice(id, returnEntries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} invoice The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvoice(id: number, invoice: UpdateInvoiceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInvoice(id, invoice, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         *  Adds an invoice to the system.
         * @param {CreateInvoiceRequest} invoice The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(invoice: CreateInvoiceRequest, options?: any): AxiosPromise<InvoiceResponse> {
            return localVarFp.createInvoice(invoice, options).then((request) => request(axios, basePath));
        },
        /**
         *  Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice(id: number, options?: any): AxiosPromise<BaseInvoiceResponse> {
            return localVarFp.deleteInvoice(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices(toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedInvoiceResponse> {
            return localVarFp.getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice(id: number, returnEntries?: boolean, options?: any): AxiosPromise<InvoiceResponse> {
            return localVarFp.getSingleInvoice(id, returnEntries, options).then((request) => request(axios, basePath));
        },
        /**
         *  Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} invoice The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(id: number, invoice: UpdateInvoiceRequest, options?: any): AxiosPromise<BaseInvoiceResponse> {
            return localVarFp.updateInvoice(id, invoice, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     *  Adds an invoice to the system.
     * @param {CreateInvoiceRequest} invoice The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public createInvoice(invoice: CreateInvoiceRequest, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).createInvoice(invoice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public deleteInvoice(id: number, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).deleteInvoice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getAllInvoices(toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getSingleInvoice(id: number, returnEntries?: boolean, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getSingleInvoice(id, returnEntries, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} invoice The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public updateInvoice(id: number, invoice: UpdateInvoiceRequest, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).updateInvoice(id, invoice, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PayoutRequestsApi - axios parameter creator
 * @export
 */
export const PayoutRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Create a new payout request
         * @param {PayoutRequestRequest} payoutRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest: async (payoutRequest: PayoutRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payoutRequest' is not null or undefined
            assertParamExists('createPayoutRequest', 'payoutRequest', payoutRequest)
            const localVarPath = `/payoutrequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all payout requests given the filter parameters
         * @param {string} [requestedById] ID of user(s) who requested a payout
         * @param {string} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests: async (requestedById?: string, approvedById?: string, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payoutrequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (requestedById !== undefined) {
                localVarQueryParameter['requestedById'] = requestedById;
            }

            if (approvedById !== undefined) {
                localVarQueryParameter['approvedById'] = approvedById;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSinglePayoutRequest', 'id', id)
            const localVarPath = `/payoutrequests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} state New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus: async (id: number, state: PayoutRequestStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setPayoutRequestStatus', 'id', id)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('setPayoutRequestStatus', 'state', state)
            const localVarPath = `/payoutrequests/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(state, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayoutRequestsApi - functional programming interface
 * @export
 */
export const PayoutRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayoutRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Create a new payout request
         * @param {PayoutRequestRequest} payoutRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayoutRequest(payoutRequest: PayoutRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayoutRequest(payoutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all payout requests given the filter parameters
         * @param {string} [requestedById] ID of user(s) who requested a payout
         * @param {string} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPayoutRequests(requestedById?: string, approvedById?: string, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBasePayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSinglePayoutRequest(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSinglePayoutRequest(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} state New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPayoutRequestStatus(id: number, state: PayoutRequestStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPayoutRequestStatus(id, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PayoutRequestsApi - factory interface
 * @export
 */
export const PayoutRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayoutRequestsApiFp(configuration)
    return {
        /**
         *  Create a new payout request
         * @param {PayoutRequestRequest} payoutRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest(payoutRequest: PayoutRequestRequest, options?: any): AxiosPromise<PayoutRequestResponse> {
            return localVarFp.createPayoutRequest(payoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all payout requests given the filter parameters
         * @param {string} [requestedById] ID of user(s) who requested a payout
         * @param {string} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests(requestedById?: string, approvedById?: string, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBasePayoutRequestResponse> {
            return localVarFp.getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest(id: number, options?: any): AxiosPromise<PayoutRequestResponse> {
            return localVarFp.getSinglePayoutRequest(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} state New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus(id: number, state: PayoutRequestStatusRequest, options?: any): AxiosPromise<PayoutRequestResponse> {
            return localVarFp.setPayoutRequestStatus(id, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayoutRequestsApi - object-oriented interface
 * @export
 * @class PayoutRequestsApi
 * @extends {BaseAPI}
 */
export class PayoutRequestsApi extends BaseAPI {
    /**
     *  Create a new payout request
     * @param {PayoutRequestRequest} payoutRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public createPayoutRequest(payoutRequest: PayoutRequestRequest, options?: AxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).createPayoutRequest(payoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all payout requests given the filter parameters
     * @param {string} [requestedById] ID of user(s) who requested a payout
     * @param {string} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public getAllPayoutRequests(requestedById?: string, approvedById?: string, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public getSinglePayoutRequest(id: number, options?: AxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).getSinglePayoutRequest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} state New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public setPayoutRequestStatus(id: number, state: PayoutRequestStatusRequest, options?: AxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).setPayoutRequestStatus(id, state, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PointofsaleApi - axios parameter creator
 * @export
 */
export const PointofsaleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale: async (pointofsale: CreatePointOfSaleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pointofsale' is not null or undefined
            assertParamExists('createPointOfSale', 'pointofsale', pointofsale)
            const localVarPath = `/pointsofsale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pointofsale, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers: async (id: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAllPointOfSaleContainers', 'id', id)
            const localVarPath = `/pointsofsale/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts: async (id: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAllPointOfSaleProducts', 'id', id)
            const localVarPath = `/pointsofsale/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pointsofsale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSinglePointOfSale', 'id', id)
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns a Point of Sale transactions
         * @param {number} id          The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (id: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransactions', 'id', id)
            const localVarPath = `/pointsofsale/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale: async (id: number, pointofsale: UpdatePointOfSaleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePointOfSale', 'id', id)
            // verify required parameter 'pointofsale' is not null or undefined
            assertParamExists('updatePointOfSale', 'pointofsale', pointofsale)
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pointofsale, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PointofsaleApi - functional programming interface
 * @export
 */
export const PointofsaleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PointofsaleApiAxiosParamCreator(configuration)
    return {
        /**
         *  Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPointOfSale(pointofsale: CreatePointOfSaleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPointOfSale(pointofsale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPointOfSaleContainers(id, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPointOfSaleProducts(id, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPointsOfSale(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPointOfSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPointsOfSale(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSinglePointOfSale(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSinglePointOfSale(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns a Point of Sale transactions
         * @param {number} id          The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(id, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePointOfSale(id: number, pointofsale: UpdatePointOfSaleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePointOfSale(id, pointofsale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PointofsaleApi - factory interface
 * @export
 */
export const PointofsaleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PointofsaleApiFp(configuration)
    return {
        /**
         *  Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale(pointofsale: CreatePointOfSaleRequest, options?: any): AxiosPromise<PointOfSaleWithContainersResponse> {
            return localVarFp.createPointOfSale(pointofsale, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getAllPointOfSaleContainers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse> {
            return localVarFp.getAllPointOfSaleProducts(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedPointOfSaleResponse> {
            return localVarFp.getAllPointsOfSale(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale(id: number, options?: any): AxiosPromise<PointOfSaleWithContainersResponse> {
            return localVarFp.getSinglePointOfSale(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a Point of Sale transactions
         * @param {number} id          The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse> {
            return localVarFp.getTransactions(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale(id: number, pointofsale: UpdatePointOfSaleRequest, options?: any): AxiosPromise<PointOfSaleWithContainersResponse> {
            return localVarFp.updatePointOfSale(id, pointofsale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PointofsaleApi - object-oriented interface
 * @export
 * @class PointofsaleApi
 * @extends {BaseAPI}
 */
export class PointofsaleApi extends BaseAPI {
    /**
     *  Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public createPointOfSale(pointofsale: CreatePointOfSaleRequest, options?: AxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).createPointOfSale(pointofsale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getAllPointOfSaleContainers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getAllPointOfSaleProducts(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getAllPointsOfSale(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getAllPointsOfSale(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getSinglePointOfSale(id: number, options?: AxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getSinglePointOfSale(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns a Point of Sale transactions
     * @param {number} id          The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getTransactions(id: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getTransactions(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public updatePointOfSale(id: number, pointofsale: UpdatePointOfSaleRequest, options?: AxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).updatePointOfSale(id, pointofsale, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductCategoriesApi - axios parameter creator
 * @export
 */
export const ProductCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Post a new productCategory.
         * @param {ProductCategoryRequest} productCategory The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory: async (productCategory: ProductCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productCategory' is not null or undefined
            assertParamExists('createProductCategory', 'productCategory', productCategory)
            const localVarPath = `/productcategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all existing productcategories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/productcategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleProductCategory', 'id', id)
            const localVarPath = `/productcategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategory The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory: async (id: number, productCategory: ProductCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProductCategory', 'id', id)
            // verify required parameter 'productCategory' is not null or undefined
            assertParamExists('updateProductCategory', 'productCategory', productCategory)
            const localVarPath = `/productcategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductCategoriesApi - functional programming interface
 * @export
 */
export const ProductCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Post a new productCategory.
         * @param {ProductCategoryRequest} productCategory The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductCategory(productCategory: ProductCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProductCategory(productCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all existing productcategories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProductCategories(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProductCategories(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleProductCategory(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleProductCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategory The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductCategory(id: number, productCategory: ProductCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductCategory(id, productCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductCategoriesApi - factory interface
 * @export
 */
export const ProductCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductCategoriesApiFp(configuration)
    return {
        /**
         *  Post a new productCategory.
         * @param {ProductCategoryRequest} productCategory The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory(productCategory: ProductCategoryRequest, options?: any): AxiosPromise<ProductCategoryResponse> {
            return localVarFp.createProductCategory(productCategory, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing productcategories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductCategoryResponse> {
            return localVarFp.getAllProductCategories(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory(id: number, options?: any): AxiosPromise<ProductCategoryResponse> {
            return localVarFp.getSingleProductCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategory The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory(id: number, productCategory: ProductCategoryRequest, options?: any): AxiosPromise<ProductCategoryResponse> {
            return localVarFp.updateProductCategory(id, productCategory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductCategoriesApi - object-oriented interface
 * @export
 * @class ProductCategoriesApi
 * @extends {BaseAPI}
 */
export class ProductCategoriesApi extends BaseAPI {
    /**
     *  Post a new productCategory.
     * @param {ProductCategoryRequest} productCategory The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public createProductCategory(productCategory: ProductCategoryRequest, options?: AxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).createProductCategory(productCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all existing productcategories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public getAllProductCategories(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).getAllProductCategories(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public getSingleProductCategory(id: number, options?: AxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).getSingleProductCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategory The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public updateProductCategory(id: number, productCategory: ProductCategoryRequest, options?: AxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).updateProductCategory(id, productCategory, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Create a new product.
         * @param {CreateProductRequest} product The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (product: CreateProductRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('createProduct', 'product', product)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} product The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (id: number, product: UpdateProductRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduct', 'id', id)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('updateProduct', 'product', product)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage: async (id: number, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProductImage', 'id', id)
            const localVarPath = `/products/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Create a new product.
         * @param {CreateProductRequest} product The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(product: CreateProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProducts(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProducts(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleProduct(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} product The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(id: number, product: UpdateProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(id, product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductImage(id: number, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductImage(id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         *  Create a new product.
         * @param {CreateProductRequest} product The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(product: CreateProductRequest, options?: any): AxiosPromise<ProductResponse> {
            return localVarFp.createProduct(product, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse> {
            return localVarFp.getAllProducts(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct(id: number, options?: any): AxiosPromise<ProductResponse> {
            return localVarFp.getSingleProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} product The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: number, product: UpdateProductRequest, options?: any): AxiosPromise<ProductResponse> {
            return localVarFp.updateProduct(id, product, options).then((request) => request(axios, basePath));
        },
        /**
         *  Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage(id: number, file?: File, options?: any): AxiosPromise<void> {
            return localVarFp.updateProductImage(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     *  Create a new product.
     * @param {CreateProductRequest} product The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProduct(product: CreateProductRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).createProduct(product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getAllProducts(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getAllProducts(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getSingleProduct(id: number, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getSingleProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} product The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(id: number, product: UpdateProductRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).updateProduct(id, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProductImage(id: number, file?: File, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).updateProductImage(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RbacApi - axios parameter creator
 * @export
 */
export const RbacApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rbac/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RbacApi - functional programming interface
 * @export
 */
export const RbacApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RbacApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRoles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRoles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RbacApi - factory interface
 * @export
 */
export const RbacApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RbacApiFp(configuration)
    return {
        /**
         *  Returns all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options?: any): AxiosPromise<Array<RoleResponse>> {
            return localVarFp.getAllRoles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RbacApi - object-oriented interface
 * @export
 * @class RbacApi
 * @extends {BaseAPI}
 */
export class RbacApi extends BaseAPI {
    /**
     *  Returns all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    public getAllRoles(options?: AxiosRequestConfig) {
        return RbacApiFp(this.configuration).getAllRoles(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RootApi - axios parameter creator
 * @export
 */
export const RootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Ping the backend to check whether everything is working correctly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RootApiAxiosParamCreator(configuration)
    return {
        /**
         *  Ping the backend to check whether everything is working correctly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RootApi - factory interface
 * @export
 */
export const RootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RootApiFp(configuration)
    return {
        /**
         *  Ping the backend to check whether everything is working correctly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<void> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export class RootApi extends BaseAPI {
    /**
     *  Ping the backend to check whether everything is working correctly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    public ping(options?: AxiosRequestConfig) {
        return RootApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Start the stripe deposit flow
         * @param {StripeRequest} stripe The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: async (stripe: StripeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stripe' is not null or undefined
            assertParamExists('deposit', 'stripe', stripe)
            const localVarPath = `/stripe/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stripe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Webhook for Stripe event updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhook: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         *  Start the stripe deposit flow
         * @param {StripeRequest} stripe The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deposit(stripe: StripeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deposit(stripe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Webhook for Stripe event updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhook(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         *  Start the stripe deposit flow
         * @param {StripeRequest} stripe The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(stripe: StripeRequest, options?: any): AxiosPromise<StripePaymentIntentResponse> {
            return localVarFp.deposit(stripe, options).then((request) => request(axios, basePath));
        },
        /**
         *  Webhook for Stripe event updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhook(options?: any): AxiosPromise<void> {
            return localVarFp.webhook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     *  Start the stripe deposit flow
     * @param {StripeRequest} stripe The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public deposit(stripe: StripeRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).deposit(stripe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Webhook for Stripe event updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public webhook(options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).webhook(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestApi - axios parameter creator
 * @export
 */
export const TestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test/helloworld`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestApi - functional programming interface
 * @export
 */
export const TestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestApiAxiosParamCreator(configuration)
    return {
        /**
         *  Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helloworld(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helloworld(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestApi - factory interface
 * @export
 */
export const TestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestApiFp(configuration)
    return {
        /**
         *  Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld(options?: any): AxiosPromise<void> {
            return localVarFp.helloworld(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestApi - object-oriented interface
 * @export
 * @class TestApi
 * @extends {BaseAPI}
 */
export class TestApi extends BaseAPI {
    /**
     *  Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public helloworld(options?: AxiosRequestConfig) {
        return TestApiFp(this.configuration).helloworld(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Creates a new transaction
         * @param {TransactionRequest} transaction The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (transaction: TransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transaction' is not null or undefined
            assertParamExists('createTransaction', 'transaction', transaction)
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransaction', 'id', id)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions: async (fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (pointOfSaleId !== undefined) {
                localVarQueryParameter['pointOfSaleId'] = pointOfSaleId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (productRevision !== undefined) {
                localVarQueryParameter['productRevision'] = productRevision;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleTransaction', 'id', id)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transaction The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: async (id: number, transaction: TransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransaction', 'id', id)
            // verify required parameter 'transaction' is not null or undefined
            assertParamExists('updateTransaction', 'transaction', transaction)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transaction The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction: async (transaction: TransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transaction' is not null or undefined
            assertParamExists('validateTransaction', 'transaction', transaction)
            const localVarPath = `/transactions/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Creates a new transaction
         * @param {TransactionRequest} transaction The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(transaction: TransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransaction(transaction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransaction(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransaction(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleTransaction(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleTransaction(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transaction The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction(id: number, transaction: TransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction(id, transaction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transaction The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateTransaction(transaction: TransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateTransaction(transaction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         *  Creates a new transaction
         * @param {TransactionRequest} transaction The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(transaction: TransactionRequest, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.createTransaction(transaction, options).then((request) => request(axios, basePath));
        },
        /**
         *  Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id: number, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.deleteTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse> {
            return localVarFp.getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction(id: number, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.getSingleTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transaction The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id: number, transaction: TransactionRequest, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.updateTransaction(id, transaction, options).then((request) => request(axios, basePath));
        },
        /**
         *  Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transaction The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction(transaction: TransactionRequest, options?: any): AxiosPromise<void> {
            return localVarFp.validateTransaction(transaction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     *  Creates a new transaction
     * @param {TransactionRequest} transaction The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransaction(transaction: TransactionRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createTransaction(transaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransaction(id: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).deleteTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getSingleTransaction(id: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getSingleTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transaction The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransaction(id: number, transaction: TransactionRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).updateTransaction(id, transaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transaction The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public validateTransaction(transaction: TransactionRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).validateTransaction(transaction, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Post a new transfer.
         * @param {TransferRequest} transfer The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: async (transfer: TransferRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transfer' is not null or undefined
            assertParamExists('createTransfer', 'transfer', transfer)
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleTransfer', 'id', id)
            const localVarPath = `/transfers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         *  Post a new transfer.
         * @param {TransferRequest} transfer The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransfer(transfer: TransferRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(transfer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransfers(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransferResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTransfers(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleTransfer(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleTransfer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         *  Post a new transfer.
         * @param {TransferRequest} transfer The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(transfer: TransferRequest, options?: any): AxiosPromise<TransferResponse> {
            return localVarFp.createTransfer(transfer, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers(take?: number, skip?: number, options?: any): AxiosPromise<Array<TransferResponse>> {
            return localVarFp.getAllTransfers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer(id: number, options?: any): AxiosPromise<TransferResponse> {
            return localVarFp.getSingleTransfer(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI {
    /**
     *  Post a new transfer.
     * @param {TransferRequest} transfer The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public createTransfer(transfer: TransferRequest, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).createTransfer(transfer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getAllTransfers(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getAllTransfers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getSingleTransfer(id: number, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getSingleTransfer(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos: async (params: AcceptTosRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'params' is not null or undefined
            assertParamExists('acceptTos', 'params', params)
            const localVarPath = `/users/acceptTos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(params, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authenticateAs', 'id', id)
            const localVarPath = `/users/{id}/authenticate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Create a new user
         * @param {CreateUserRequest} user The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (user: CreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUser', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserKey', 'id', id)
            const localVarPath = `/users/{id}/authenticator/key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserNfc', 'id', id)
            const localVarPath = `/users/{id}/authenticator/nfc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {string} [type] {MEMBER,ORGAN,VOUCHER,LOCAL_USER,LOCAL_ADMIN,INVOICE,AUTOMATIC_INVOICE} - Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (ofAge !== undefined) {
                localVarQueryParameter['ofAge'] = ofAge;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType: async (userType: string, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userType' is not null or undefined
            assertParamExists('getAllUsersOfUserType', 'userType', userType)
            const localVarPath = `/users/usertype/{userType}`
                .replace(`{${"userType"}}`, encodeURIComponent(String(userType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIndividualUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers: async (id: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganMembers', 'id', id)
            const localVarPath = `/users/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserAuthenticatable', 'id', id)
            const localVarPath = `/users/{id}/authenticate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserRoles', 'id', id)
            const localVarPath = `/users/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers: async (id: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersContainers', 'id', id)
            const localVarPath = `/users/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get all financial mutations of a user.
         * @param {number} id The id of the user to get the mutations from
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations: async (id: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersFinancialMutations', 'id', id)
            const localVarPath = `/users/{id}/financialmutations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale: async (id: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersPointsOfSale', 'id', id)
            const localVarPath = `/users/{id}/pointsofsale`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersProcessingDeposits', 'id', id)
            const localVarPath = `/users/{id}/deposits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts: async (id: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersProducts', 'id', id)
            const localVarPath = `/users/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get an user\'s transactions (from, to or created)
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions: async (id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersTransactions', 'id', id)
            const localVarPath = `/users/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (productRevision !== undefined) {
                localVarQueryParameter['productRevision'] = productRevision;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactionsReport: async (id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersTransactionsReport', 'id', id)
            const localVarPath = `/users/{id}/transactions/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (exclusiveToId !== undefined) {
                localVarQueryParameter['exclusiveToId'] = exclusiveToId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get an user\'s transfers
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers: async (id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersTransfers', 'id', id)
            const localVarPath = `/users/{id}/transfers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (id2 !== undefined) {
                localVarQueryParameter['id'] = id2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update a user
         * @param {number} id The id of the user
         * @param {UserRequest} user The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: number, user: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserKey', 'id', id)
            const localVarPath = `/users/{id}/authenticator/key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} update    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword: async (id: number, update: UpdateLocalRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserLocalPassword', 'id', id)
            // verify required parameter 'update' is not null or undefined
            assertParamExists('updateUserLocalPassword', 'update', update)
            const localVarPath = `/users/{id}/authenticator/local`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(update, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} update    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc: async (id: number, update: UpdateNfcRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserNfc', 'id', id)
            // verify required parameter 'update' is not null or undefined
            assertParamExists('updateUserNfc', 'update', update)
            const localVarPath = `/users/{id}/authenticator/nfc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(update, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} update    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin: async (id: number, update: UpdatePinRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserPin', 'id', id)
            // verify required parameter 'update' is not null or undefined
            assertParamExists('updateUserPin', 'update', update)
            const localVarPath = `/users/{id}/authenticator/pin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(update, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waiveUserFines: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('waiveUserFines', 'id', id)
            const localVarPath = `/users/{id}/fines/waive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         *  Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptTos(params: AcceptTosRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptTos(params, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateAs(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateAs(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Create a new user
         * @param {CreateUserRequest} user The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(user: CreateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserNfc(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserNfc(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {string} [type] {MEMBER,ORGAN,VOUCHER,LOCAL_USER,LOCAL_ADMIN,INVOICE,AUTOMATIC_INVOICE} - Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(take, skip, search, active, ofAge, id, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsersOfUserType(userType, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndividualUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndividualUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganMembers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganMembers(id, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAuthenticatable(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAuthenticatable(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoles(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoles(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersContainers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersContainers(id, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get all financial mutations of a user.
         * @param {number} id The id of the user to get the mutations from
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFinancialMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersFinancialMutations(id, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPointOfSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersPointsOfSale(id, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersProcessingDeposits(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersProcessingDeposits(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersProducts(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersProducts(id, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get an user\'s transactions (from, to or created)
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionReportResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get an user\'s transfers
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTransfers(id, take, skip, fromId, toId, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update a user
         * @param {number} id The id of the user
         * @param {UserRequest} user The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: number, user: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} update    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserLocalPassword(id: number, update: UpdateLocalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserLocalPassword(id, update, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} update    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserNfc(id: number, update: UpdateNfcRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserNfc(id, update, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} update    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPin(id: number, update: UpdatePinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPin(id, update, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waiveUserFines(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.waiveUserFines(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         *  Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos(params: AcceptTosRequest, options?: any): AxiosPromise<void> {
            return localVarFp.acceptTos(params, options).then((request) => request(axios, basePath));
        },
        /**
         *  Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs(id: number, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.authenticateAs(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new user
         * @param {CreateUserRequest} user The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: CreateUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserNfc(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {string} [type] {MEMBER,ORGAN,VOUCHER,LOCAL_USER,LOCAL_ADMIN,INVOICE,AUTOMATIC_INVOICE} - Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: string, options?: any): AxiosPromise<PaginatedUserResponse> {
            return localVarFp.getAllUsers(take, skip, search, active, ofAge, id, type, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedUserResponse> {
            return localVarFp.getAllUsersOfUserType(userType, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser(id: number, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getIndividualUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedUserResponse> {
            return localVarFp.getOrganMembers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable(id: number, options?: any): AxiosPromise<Array<UserResponse>> {
            return localVarFp.getUserAuthenticatable(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(id: number, options?: any): AxiosPromise<Array<RoleResponse>> {
            return localVarFp.getUserRoles(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getUsersContainers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all financial mutations of a user.
         * @param {number} id The id of the user to get the mutations from
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedFinancialMutationResponse> {
            return localVarFp.getUsersFinancialMutations(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedPointOfSaleResponse> {
            return localVarFp.getUsersPointsOfSale(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits(id: number, options?: any): AxiosPromise<Array<RoleResponse>> {
            return localVarFp.getUsersProcessingDeposits(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse> {
            return localVarFp.getUsersProducts(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get an user\'s transactions (from, to or created)
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse> {
            return localVarFp.getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: any): AxiosPromise<Array<TransactionReportResponse>> {
            return localVarFp.getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get an user\'s transfers
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: any): AxiosPromise<PaginatedTransferResponse> {
            return localVarFp.getUsersTransfers(id, take, skip, fromId, toId, id2, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update a user
         * @param {number} id The id of the user
         * @param {UserRequest} user The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, user: UserRequest, options?: any): AxiosPromise<UserRequest> {
            return localVarFp.updateUser(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         *  POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey(id: number, options?: any): AxiosPromise<UpdateKeyResponse> {
            return localVarFp.updateUserKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} update    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword(id: number, update: UpdateLocalRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserLocalPassword(id, update, options).then((request) => request(axios, basePath));
        },
        /**
         *  Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} update    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc(id: number, update: UpdateNfcRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserNfc(id, update, options).then((request) => request(axios, basePath));
        },
        /**
         *  Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} update    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin(id: number, update: UpdatePinRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPin(id, update, options).then((request) => request(axios, basePath));
        },
        /**
         *  Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waiveUserFines(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.waiveUserFines(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     *  Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public acceptTos(params: AcceptTosRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).acceptTos(params, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public authenticateAs(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).authenticateAs(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Create a new user
     * @param {CreateUserRequest} user The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(user: CreateUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserKey(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserNfc(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserNfc(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {string} [type] {MEMBER,ORGAN,VOUCHER,LOCAL_USER,LOCAL_ADMIN,INVOICE,AUTOMATIC_INVOICE} - Filter based on user type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getAllUsers(take, skip, search, active, ofAge, id, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getAllUsersOfUserType(userType, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getIndividualUser(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getIndividualUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get an organs members
     * @param {number} id The id of the user
     * @param {number} [take] How many members the endpoint should return
     * @param {number} [skip] How many members should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOrganMembers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getOrganMembers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserAuthenticatable(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserAuthenticatable(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserRoles(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserRoles(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersContainers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersContainers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get all financial mutations of a user.
     * @param {number} id The id of the user to get the mutations from
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersFinancialMutations(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersPointsOfSale(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersProcessingDeposits(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersProcessingDeposits(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersProducts(id: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersProducts(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get an user\'s transactions (from, to or created)
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get an user\'s transfers
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTransfers(id, take, skip, fromId, toId, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update a user
     * @param {number} id The id of the user
     * @param {UserRequest} user The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: number, user: UserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserKey(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} update    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserLocalPassword(id: number, update: UpdateLocalRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserLocalPassword(id, update, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} update    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserNfc(id: number, update: UpdateNfcRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserNfc(id, update, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} update    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPin(id: number, update: UpdatePinRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPin(id, update, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Waive all given user\'s fines
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public waiveUserFines(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).waiveUserFines(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VatGroupsApi - axios parameter creator
 * @export
 */
export const VatGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Create a new VAT group
         * @param {VatGroupRequest} vatGroup The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup: async (vatGroup: VatGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vatGroup' is not null or undefined
            assertParamExists('createVatGroup', 'vatGroup', vatGroup)
            const localVarPath = `/vatgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vatGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups: async (vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vatgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (vatGroupId !== undefined) {
                localVarQueryParameter['vatGroupId'] = vatGroupId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (percentage !== undefined) {
                localVarQueryParameter['percentage'] = percentage;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleVatGroup', 'id', id)
            const localVarPath = `/vatgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts: async (year: number, period: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            assertParamExists('getVatDeclarationAmounts', 'year', year)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getVatDeclarationAmounts', 'period', period)
            const localVarPath = `/vatgroups/declaration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} vatGroup The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup: async (id: number, vatGroup: UpdateVatGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVatGroup', 'id', id)
            // verify required parameter 'vatGroup' is not null or undefined
            assertParamExists('updateVatGroup', 'vatGroup', vatGroup)
            const localVarPath = `/vatgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vatGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VatGroupsApi - functional programming interface
 * @export
 */
export const VatGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VatGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Create a new VAT group
         * @param {VatGroupRequest} vatGroup The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVatGroup(vatGroup: VatGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVatGroup(vatGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVatGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleVatGroup(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleVatGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVatDeclarationAmounts(year: number, period: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVatGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVatDeclarationAmounts(year, period, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} vatGroup The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVatGroup(id: number, vatGroup: UpdateVatGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVatGroup(id, vatGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VatGroupsApi - factory interface
 * @export
 */
export const VatGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VatGroupsApiFp(configuration)
    return {
        /**
         *  Create a new VAT group
         * @param {VatGroupRequest} vatGroup The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup(vatGroup: VatGroupRequest, options?: any): AxiosPromise<VatGroup> {
            return localVarFp.createVatGroup(vatGroup, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedVatGroupResponse> {
            return localVarFp.getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup(id: number, options?: any): AxiosPromise<VatGroup> {
            return localVarFp.getSingleVatGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts(year: number, period: string, options?: any): AxiosPromise<PaginatedVatGroupResponse> {
            return localVarFp.getVatDeclarationAmounts(year, period, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} vatGroup The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup(id: number, vatGroup: UpdateVatGroupRequest, options?: any): AxiosPromise<VatGroup> {
            return localVarFp.updateVatGroup(id, vatGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VatGroupsApi - object-oriented interface
 * @export
 * @class VatGroupsApi
 * @extends {BaseAPI}
 */
export class VatGroupsApi extends BaseAPI {
    /**
     *  Create a new VAT group
     * @param {VatGroupRequest} vatGroup The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public createVatGroup(vatGroup: VatGroupRequest, options?: AxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).createVatGroup(vatGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public getSingleVatGroup(id: number, options?: AxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).getSingleVatGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public getVatDeclarationAmounts(year: number, period: string, options?: AxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).getVatDeclarationAmounts(year, period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} vatGroup The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public updateVatGroup(id: number, vatGroup: UpdateVatGroupRequest, options?: AxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).updateVatGroup(id, vatGroup, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VouchergroupsApi - axios parameter creator
 * @export
 */
export const VouchergroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Creates a new voucher group
         * @param {VoucherGroupRequest} vouchergroup The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVouchergroup: async (vouchergroup: VoucherGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vouchergroup' is not null or undefined
            assertParamExists('createVouchergroup', 'vouchergroup', vouchergroup)
            const localVarPath = `/vouchergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vouchergroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVouchergroups: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vouchergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchergroupId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVouchergroupId', 'id', id)
            const localVarPath = `/vouchergroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} vouchergroup The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherGroup: async (id: number, vouchergroup: VoucherGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVoucherGroup', 'id', id)
            // verify required parameter 'vouchergroup' is not null or undefined
            assertParamExists('updateVoucherGroup', 'vouchergroup', vouchergroup)
            const localVarPath = `/vouchergroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vouchergroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VouchergroupsApi - functional programming interface
 * @export
 */
export const VouchergroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VouchergroupsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Creates a new voucher group
         * @param {VoucherGroupRequest} vouchergroup The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVouchergroup(vouchergroup: VoucherGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVouchergroup(vouchergroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVouchergroups(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVouchergroups(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVouchergroupId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVouchergroupId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} vouchergroup The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVoucherGroup(id: number, vouchergroup: VoucherGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoucherGroup(id, vouchergroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VouchergroupsApi - factory interface
 * @export
 */
export const VouchergroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VouchergroupsApiFp(configuration)
    return {
        /**
         *  Creates a new voucher group
         * @param {VoucherGroupRequest} vouchergroup The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVouchergroup(vouchergroup: VoucherGroupRequest, options?: any): AxiosPromise<VoucherGroupResponse> {
            return localVarFp.createVouchergroup(vouchergroup, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVouchergroups(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedVoucherGroupResponse> {
            return localVarFp.getAllVouchergroups(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchergroupId(id: number, options?: any): AxiosPromise<VoucherGroupResponse> {
            return localVarFp.getVouchergroupId(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} vouchergroup The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherGroup(id: number, vouchergroup: VoucherGroupRequest, options?: any): AxiosPromise<VoucherGroupResponse> {
            return localVarFp.updateVoucherGroup(id, vouchergroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VouchergroupsApi - object-oriented interface
 * @export
 * @class VouchergroupsApi
 * @extends {BaseAPI}
 */
export class VouchergroupsApi extends BaseAPI {
    /**
     *  Creates a new voucher group
     * @param {VoucherGroupRequest} vouchergroup The voucher group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public createVouchergroup(vouchergroup: VoucherGroupRequest, options?: AxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).createVouchergroup(vouchergroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns all existing voucher groups
     * @param {number} [take] How many voucher groups the endpoint should return
     * @param {number} [skip] How many voucher groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public getAllVouchergroups(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).getAllVouchergroups(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the requested voucher group
     * @param {number} id The id of the voucher group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public getVouchergroupId(id: number, options?: AxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).getVouchergroupId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Updates the requested voucher group
     * @param {number} id The id of the voucher group which should be updated
     * @param {VoucherGroupRequest} vouchergroup The updated voucher group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public updateVoucherGroup(id: number, vouchergroup: VoucherGroupRequest, options?: AxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).updateVoucherGroup(id, vouchergroup, options).then((request) => request(this.axios, this.basePath));
    }
}


