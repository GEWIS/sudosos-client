/* tslint:disable */
/* eslint-disable */
/**
 * sudosos-back-end
 * SudoSOS
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AcceptTosRequest
 */
export interface AcceptTosRequest {
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof AcceptTosRequest
     */
    'extensiveDataProcessing': boolean;
}
/**
 * 
 * @export
 * @interface ActionResponse
 */
export interface ActionResponse {
    /**
     * The name of the action performed on the entity.
     * @type {string}
     * @memberof ActionResponse
     */
    'action'?: string;
    /**
     * The ownership relations with permissions.
     * @type {Array<RelationResponse>}
     * @memberof ActionResponse
     */
    'relations'?: Array<RelationResponse>;
}
/**
 * 
 * @export
 * @interface AuthenticationEanRequest
 */
export interface AuthenticationEanRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationEanRequest
     */
    'eanCode': string;
}
/**
 * 
 * @export
 * @interface AuthenticationKeyRequest
 */
export interface AuthenticationKeyRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationKeyRequest
     */
    'userId': number;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationKeyRequest
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface AuthenticationLDAPRequest
 */
export interface AuthenticationLDAPRequest {
    /**
     * The AD account name to authenticate
     * @type {string}
     * @memberof AuthenticationLDAPRequest
     */
    'accountName': string;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationLDAPRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationLocalRequest
 */
export interface AuthenticationLocalRequest {
    /**
     * The users mail to authenticate
     * @type {string}
     * @memberof AuthenticationLocalRequest
     */
    'accountMail': string;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationLocalRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationMockRequest
 */
export interface AuthenticationMockRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationMockRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationMockRequest
     */
    'nonce': string;
}
/**
 * 
 * @export
 * @interface AuthenticationNfcRequest
 */
export interface AuthenticationNfcRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationNfcRequest
     */
    'nfcCode': string;
}
/**
 * 
 * @export
 * @interface AuthenticationPinRequest
 */
export interface AuthenticationPinRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationPinRequest
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationPinRequest
     */
    'pin': string;
}
/**
 * 
 * @export
 * @interface AuthenticationResetTokenRequest
 */
export interface AuthenticationResetTokenRequest {
    /**
     * The mail of the user
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'accountMail': string;
    /**
     * The reset token passcode
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'token': string;
    /**
     * The new password to set
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     * 
     * @type {UserResponse}
     * @memberof AuthenticationResponse
     */
    'user': UserResponse;
    /**
     * The RBAC roles that the user has.
     * @type {Array<string>}
     * @memberof AuthenticationResponse
     */
    'roles': Array<string>;
    /**
     * The organs that the user is a member of.
     * @type {Array<UserResponse>}
     * @memberof AuthenticationResponse
     */
    'organs': Array<UserResponse>;
    /**
     * The JWT token that can be used as Bearer token for authentication.
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'token': string;
    /**
     * Whether the related user has accepted the Terms of Service  or is not required to.
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'acceptedToS': string;
}
/**
 * 
 * @export
 * @interface BalanceResponse
 */
export interface BalanceResponse {
    /**
     * ID of the user this balance belongs to
     * @type {number}
     * @memberof BalanceResponse
     */
    'id': number;
    /**
     * Date at which this user had this balance
     * @type {string}
     * @memberof BalanceResponse
     */
    'date': string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BalanceResponse
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BalanceResponse
     */
    'fine'?: DineroObjectResponse;
    /**
     * Timestamp of the first fine
     * @type {string}
     * @memberof BalanceResponse
     */
    'fineSince'?: string;
    /**
     * The ID of the last transaction that was present when the balance was cached
     * @type {number}
     * @memberof BalanceResponse
     */
    'lastTransactionId'?: number;
    /**
     * The ID of the last transfer that was present when the balance was cached
     * @type {number}
     * @memberof BalanceResponse
     */
    'lastTransferId'?: number;
}
/**
 * 
 * @export
 * @interface BannerRequest
 */
export interface BannerRequest {
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerRequest
     */
    'name'?: string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerRequest
     */
    'duration'?: number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerRequest
     */
    'active'?: boolean;
    /**
     * The starting date from which the advertisement should be shown
     * @type {string}
     * @memberof BannerRequest
     */
    'startDate'?: string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerRequest
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface BannerResponse
 */
export interface BannerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BannerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BannerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BannerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BannerResponse
     */
    'version'?: number;
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerResponse
     */
    'name': string;
    /**
     * Location of the image
     * @type {string}
     * @memberof BannerResponse
     */
    'image'?: string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerResponse
     */
    'duration': number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerResponse
     */
    'active': boolean;
    /**
     * The starting date from which the banner should be shown
     * @type {string}
     * @memberof BannerResponse
     */
    'startDate': string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerResponse
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface BaseContainerResponse
 */
export interface BaseContainerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof BaseContainerResponse
     */
    'public'?: boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'revision'?: number;
}
/**
 * 
 * @export
 * @interface BaseEntity
 */
export interface BaseEntity {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BaseEntity
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BaseEntity
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BaseEntity
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof BaseEntity
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface BaseEntityWithoutId
 */
export interface BaseEntityWithoutId {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BaseEntityWithoutId
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BaseEntityWithoutId
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BaseEntityWithoutId
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface BaseEventAnswerResponse
 */
export interface BaseEventAnswerResponse {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseEventAnswerResponse
     */
    'user': BaseUserResponse;
    /**
     * Filled in availability per slot.
     * @type {string}
     * @memberof BaseEventAnswerResponse
     */
    'availability'?: string;
    /**
     * Whether this user is selected for the shift in the event
     * @type {boolean}
     * @memberof BaseEventAnswerResponse
     */
    'selected': boolean;
}
/**
 * 
 * @export
 * @interface BaseEventResponse
 */
export interface BaseEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseEventResponse
     */
    'version'?: number;
    /**
     * Name of the borrel.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseEventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'endDate': string;
    /**
     * The tpye of event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface BaseEventShiftResponse
 */
export interface BaseEventShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseEventShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseEventShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BaseFile
 */
export interface BaseFile {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BaseFile
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BaseFile
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BaseFile
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof BaseFile
     */
    'id': number;
    /**
     * The filename when the file is downloaded
     * @type {string}
     * @memberof BaseFile
     */
    'downloadName': string;
    /**
     * The location of the file, including filename in storage
     * @type {string}
     * @memberof BaseFile
     */
    'location': string;
    /**
     * 
     * @type {User}
     * @memberof BaseFile
     */
    'createdBy': User;
}
/**
 * 
 * @export
 * @interface BaseFineHandoutEventResponse
 */
export interface BaseFineHandoutEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseFineHandoutEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseFineHandoutEventResponse
     */
    'version'?: number;
    /**
     * Reference date of fines
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'referenceDate': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseFineHandoutEventResponse
     */
    'createdBy': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface BaseInvoiceResponse
 */
export interface BaseInvoiceResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseInvoiceResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseInvoiceResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseInvoiceResponse
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'description': string;
    /**
     * 
     * @type {InvoiceStatusResponse}
     * @memberof BaseInvoiceResponse
     */
    'currentState': InvoiceStatusResponse;
    /**
     * 
     * @type {TransferResponse}
     * @memberof BaseInvoiceResponse
     */
    'transfer'?: TransferResponse;
}
/**
 * 
 * @export
 * @interface BasePayoutRequestResponse
 */
export interface BasePayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BasePayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BasePayoutRequestResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BasePayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BasePayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BasePayoutRequestResponse
     */
    'amount': DineroObjectResponse;
    /**
     * The current status of the payout request
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface BasePointOfSaleResponse
 */
export interface BasePointOfSaleResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BasePointOfSaleResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BasePointOfSaleResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BaseProductResponse
 */
export interface BaseProductResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseProductResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseProductResponse
     */
    'version'?: number;
    /**
     * The name of the product.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BaseProductResponse
     */
    'priceInclVat': DineroObjectResponse;
    /**
     * 
     * @type {BaseVatGroupResponse}
     * @memberof BaseProductResponse
     */
    'vat': BaseVatGroupResponse;
}
/**
 * 
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseResponse
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface BaseTransactionResponse
 */
export interface BaseTransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseTransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseTransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseTransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseTransactionResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseTransactionResponse
     */
    'from': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BaseTransactionResponse
     */
    'createdBy'?: BaseUserResponse;
    /**
     * 
     * @type {BasePointOfSaleResponse}
     * @memberof BaseTransactionResponse
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     * 
     * @type {Dinero}
     * @memberof BaseTransactionResponse
     */
    'value': Dinero;
}
/**
 * 
 * @export
 * @interface BaseUserResponse
 */
export interface BaseUserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseUserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseUserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof BaseUserResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof BaseUserResponse
     */
    'nickname'?: string;
}
/**
 * 
 * @export
 * @interface BaseVatGroupResponse
 */
export interface BaseVatGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseVatGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseVatGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'version'?: number;
    /**
     * Percentage of VAT
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'percentage': number;
    /**
     * Whether VAT should be hidden
     * @type {boolean}
     * @memberof BaseVatGroupResponse
     */
    'hidden': boolean;
}
/**
 * 
 * @export
 * @interface BoilerPayoutRequestResponse
 */
export interface BoilerPayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BoilerPayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BoilerPayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BoilerPayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BoilerPayoutRequestResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'amount': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface ContainerResponse
 */
export interface ContainerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ContainerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ContainerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ContainerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ContainerResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof ContainerResponse
     */
    'public'?: boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof ContainerResponse
     */
    'revision'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof ContainerResponse
     */
    'owner': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface ContainerWithProductsResponse
 */
export interface ContainerWithProductsResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof ContainerWithProductsResponse
     */
    'public'?: boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'revision'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof ContainerWithProductsResponse
     */
    'owner': BaseUserResponse;
    /**
     * The products in the container.
     * @type {Array<ProductResponse>}
     * @memberof ContainerWithProductsResponse
     */
    'products': Array<ProductResponse>;
}
/**
 * 
 * @export
 * @interface CreateContainerRequest
 */
export interface CreateContainerRequest {
    /**
     * Name of the container
     * @type {string}
     * @memberof CreateContainerRequest
     */
    'name': string;
    /**
     *    IDs or requests of the products to add to the container
     * @type {Array<number>}
     * @memberof CreateContainerRequest
     */
    'products': Array<number>;
    /**
     * Whether the container is public or not
     * @type {boolean}
     * @memberof CreateContainerRequest
     */
    'public': boolean;
    /**
     * Id of the user who will own the container, if undefined it will    default to the token ID.
     * @type {number}
     * @memberof CreateContainerRequest
     */
    'ownerId'?: number;
}
/**
 * 
 * @export
 * @interface CreateEventRequest
 */
export interface CreateEventRequest {
    /**
     * Name of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'name': string;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'endDate': string;
    /**
     * The type of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'type'?: string;
    /**
     * IDs of shifts that are in this event per participant per borrel.
     * @type {Array<number>}
     * @memberof CreateEventRequest
     */
    'shiftIds': Array<number>;
}
/**
 * 
 * @export
 * @interface CreateInvoiceRequest
 */
export interface CreateInvoiceRequest {
    /**
     * The recipient of the Invoice.
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'forId': number;
    /**
     * The creator of the Invoice, defaults to the ID of the requester.
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'byId'?: number;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'addressee': string;
    /**
     * The description of the invoice.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'description': string;
    /**
     * Custom entries to be added to the invoice
     * @type {Array<InvoiceEntryRequest>}
     * @memberof CreateInvoiceRequest
     */
    'customEntries'?: Array<InvoiceEntryRequest>;
    /**
     * IDs of the transactions to add to the Invoice.
     * @type {Array<number>}
     * @memberof CreateInvoiceRequest
     */
    'transactionIDs'?: Array<number>;
    /**
     * For creating an Invoice for all transactions from a specific date.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'fromDate'?: string;
    /**
     * If the invoice is an credit Invoice  If an invoice is a credit invoice the relevant subtransactions are defined as all the sub transactions which have `subTransaction.toId == forId`.
     * @type {boolean}
     * @memberof CreateInvoiceRequest
     */
    'isCreditInvoice': boolean;
}
/**
 * 
 * @export
 * @interface CreatePointOfSaleRequest
 */
export interface CreatePointOfSaleRequest {
    /**
     * Name of the POS
     * @type {string}
     * @memberof CreatePointOfSaleRequest
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof CreatePointOfSaleRequest
     */
    'useAuthentication': boolean;
    /**
     * IDs or Requests of the containers to add to the POS
     * @type {Array<number>}
     * @memberof CreatePointOfSaleRequest
     */
    'containers'?: Array<number>;
    /**
     * ID of the user who will own the POS, if undefined it will    default to the token ID.
     * @type {number}
     * @memberof CreatePointOfSaleRequest
     */
    'ownerId'?: number;
}
/**
 * 
 * @export
 * @interface CreateProductRequest
 */
export interface CreateProductRequest {
    /**
     * Name of the product
     * @type {string}
     * @memberof CreateProductRequest
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof CreateProductRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * VAT group ID of the product
     * @type {number}
     * @memberof CreateProductRequest
     */
    'vat': number;
    /**
     * Category of the product
     * @type {number}
     * @memberof CreateProductRequest
     */
    'category': number;
    /**
     * Alcohol percentage of the product in 2 decimals
     * @type {number}
     * @memberof CreateProductRequest
     */
    'alcoholPercentage': number;
    /**
     * ID of the owner
     * @type {number}
     * @memberof CreateProductRequest
     */
    'ownerId': number;
}
/**
 * 
 * @export
 * @interface CreateShiftRequest
 */
export interface CreateShiftRequest {
    /**
     * Name of the event
     * @type {string}
     * @memberof CreateShiftRequest
     */
    'name': string;
    /**
     * Roles that (can) have this shift
     * @type {Array<string>}
     * @memberof CreateShiftRequest
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'canGoIntoDebt': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'ofAge': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof CreateUserRequest
     */
    'type': number;
}
/**
 * 
 * @export
 * @interface Dinero
 */
export interface Dinero {
    /**
     * The amount of money as integer in the given precision.
     * @type {number}
     * @memberof Dinero
     */
    'amount': number;
    /**
     * The precision of the amount, in decimal places.
     * @type {number}
     * @memberof Dinero
     */
    'precision': number;
    /**
     * The ISO 4217 currency code.
     * @type {string}
     * @memberof Dinero
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface DineroObject
 */
export interface DineroObject {
    /**
     * amount
     * @type {number}
     * @memberof DineroObject
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObject
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObject
     */
    'precision': number;
}
/**
 * 
 * @export
 * @interface DineroObjectRequest
 */
export interface DineroObjectRequest {
    /**
     * amount
     * @type {number}
     * @memberof DineroObjectRequest
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObjectRequest
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObjectRequest
     */
    'precision': number;
}
/**
 * 
 * @export
 * @interface DineroObjectResponse
 */
export interface DineroObjectResponse {
    /**
     * amount
     * @type {number}
     * @memberof DineroObjectResponse
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObjectResponse
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObjectResponse
     */
    'precision': number;
}
/**
 * 
 * @export
 * @interface EntityResponse
 */
export interface EntityResponse {
    /**
     * The name of the entity for which the permissions are.
     * @type {string}
     * @memberof EntityResponse
     */
    'entity'?: string;
    /**
     * The permissions per action.
     * @type {Array<ActionResponse>}
     * @memberof EntityResponse
     */
    'actions'?: Array<ActionResponse>;
}
/**
 * 
 * @export
 * @interface EventAnswerAssignmentRequest
 */
export interface EventAnswerAssignmentRequest {
    /**
     * Whether this user is selected for the given shift at the given event
     * @type {boolean}
     * @memberof EventAnswerAssignmentRequest
     */
    'selected': boolean;
}
/**
 * 
 * @export
 * @interface EventAnswerAvailabilityRequest
 */
export interface EventAnswerAvailabilityRequest {
    /**
     * New availability of the given user for the given event (YES, NO, LATER, NA)
     * @type {string}
     * @memberof EventAnswerAvailabilityRequest
     */
    'availability': string;
}
/**
 * 
 * @export
 * @interface EventInShiftResponse
 */
export interface EventInShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventInShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventInShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'name': string;
    /**
     * Which roles can fill in this shift.
     * @type {Array<string>}
     * @memberof EventInShiftResponse
     */
    'roles': Array<string>;
    /**
     * Answers for this shift.
     * @type {Array<BaseEventAnswerResponse>}
     * @memberof EventInShiftResponse
     */
    'answers'?: Array<BaseEventAnswerResponse>;
}
/**
 * 
 * @export
 * @interface EventPlanningSelectedCount
 */
export interface EventPlanningSelectedCount {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'nickname'?: string;
    /**
     * Number of times this user was selected for this shift
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventResponse
     */
    'version'?: number;
    /**
     * Name of the borrel.
     * @type {string}
     * @memberof EventResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof EventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof EventResponse
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof EventResponse
     */
    'endDate': string;
    /**
     * The tpye of event.
     * @type {string}
     * @memberof EventResponse
     */
    'type': string;
    /**
     * Shifts for this event
     * @type {Array<EventInShiftResponse>}
     * @memberof EventResponse
     */
    'shifts': Array<EventInShiftResponse>;
}
/**
 * 
 * @export
 * @interface EventShiftResponse
 */
export interface EventShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'name': string;
    /**
     * Which roles can fill in this shift.
     * @type {Array<string>}
     * @memberof EventShiftResponse
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface FinancialMutationResponse
 */
export interface FinancialMutationResponse {
    /**
     * Type of mutation (\'transfer\' or \'transaction\') (Optional)
     * @type {string}
     * @memberof FinancialMutationResponse
     */
    'type': FinancialMutationResponseTypeEnum;
    /**
     * 
     * @type {FinancialMutationResponseMutation}
     * @memberof FinancialMutationResponse
     */
    'mutation'?: FinancialMutationResponseMutation;
}

export const FinancialMutationResponseTypeEnum = {
    Transfer: 'transfer',
    Transaction: 'transaction'
} as const;

export type FinancialMutationResponseTypeEnum = typeof FinancialMutationResponseTypeEnum[keyof typeof FinancialMutationResponseTypeEnum];

/**
 * @type FinancialMutationResponseMutation
 * Details of mutation, this can be either of type TransferResponse or BaseTransactionResponse
 * @export
 */
export type FinancialMutationResponseMutation = BaseTransactionResponse | TransferResponse;

/**
 * 
 * @export
 * @interface FineHandoutEventResponse
 */
export interface FineHandoutEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof FineHandoutEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof FineHandoutEventResponse
     */
    'version'?: number;
    /**
     * Reference date of fines
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'referenceDate': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof FineHandoutEventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * Fines that have been handed out
     * @type {Array<FineResponse>}
     * @memberof FineHandoutEventResponse
     */
    'fines': Array<FineResponse>;
}
/**
 * 
 * @export
 * @interface FineResponse
 */
export interface FineResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof FineResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof FineResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof FineResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof FineResponse
     */
    'version'?: number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof FineResponse
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof FineResponse
     */
    'user'?: BaseUserResponse;
}
/**
 * 
 * @export
 * @interface GEWISAuthenticationPinRequest
 */
export interface GEWISAuthenticationPinRequest {
    /**
     * 
     * @type {number}
     * @memberof GEWISAuthenticationPinRequest
     */
    'gewisId': number;
    /**
     * 
     * @type {string}
     * @memberof GEWISAuthenticationPinRequest
     */
    'pin': string;
}
/**
 * @type GetAllPayoutRequestsRequestedByIdParameter
 * @export
 */
export type GetAllPayoutRequestsRequestedByIdParameter = Array<number> | number;

/**
 * 
 * @export
 * @interface GewiswebAuthenticationRequest
 */
export interface GewiswebAuthenticationRequest {
    /**
     * The gewisweb JWT token.
     * @type {string}
     * @memberof GewiswebAuthenticationRequest
     */
    'token': string;
    /**
     * The nonce used in the newly signed JWT token.
     * @type {string}
     * @memberof GewiswebAuthenticationRequest
     */
    'nonce': string;
}
/**
 * 
 * @export
 * @interface HandoutFinesRequest
 */
export interface HandoutFinesRequest {
    /**
     * Users to fine. If a user is not eligible for a fine, a fine of 0,00 will be handed out.
     * @type {Array<number>}
     * @memberof HandoutFinesRequest
     */
    'userIds': Array<number>;
    /**
     * Reference date to calculate the balance and thus the height of the fine for.
     * @type {string}
     * @memberof HandoutFinesRequest
     */
    'referenceDate': string;
}
/**
 * 
 * @export
 * @interface InvoiceEntryRequest
 */
export interface InvoiceEntryRequest {
    /**
     * The description of the entry
     * @type {string}
     * @memberof InvoiceEntryRequest
     */
    'description': string;
    /**
     * Amount of item sold.
     * @type {number}
     * @memberof InvoiceEntryRequest
     */
    'amount': number;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof InvoiceEntryRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * The percentage of VAT applied to this item
     * @type {number}
     * @memberof InvoiceEntryRequest
     */
    'vatPercentage': number;
}
/**
 * 
 * @export
 * @interface InvoiceEntryResponse
 */
export interface InvoiceEntryResponse {
    /**
     * The description of the entry
     * @type {string}
     * @memberof InvoiceEntryResponse
     */
    'description': string;
    /**
     * Amount of products sold.
     * @type {number}
     * @memberof InvoiceEntryResponse
     */
    'amount': number;
    /**
     * 
     * @type {DineroObject}
     * @memberof InvoiceEntryResponse
     */
    'priceInclVat': DineroObject;
    /**
     * The percentage of VAT applied to this entry
     * @type {number}
     * @memberof InvoiceEntryResponse
     */
    'vatPercentage': number;
}
/**
 * 
 * @export
 * @interface InvoiceResponse
 */
export interface InvoiceResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof InvoiceResponse
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'description': string;
    /**
     * 
     * @type {InvoiceStatusResponse}
     * @memberof InvoiceResponse
     */
    'currentState': InvoiceStatusResponse;
    /**
     * 
     * @type {TransferResponse}
     * @memberof InvoiceResponse
     */
    'transfer'?: TransferResponse;
    /**
     * The entries of the invoice
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponse
     */
    'invoiceEntries': Array<InvoiceEntryResponse>;
}
/**
 * 
 * @export
 * @interface InvoiceResponseTypes
 */
export interface InvoiceResponseTypes {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof InvoiceResponseTypes
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof InvoiceResponseTypes
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof InvoiceResponseTypes
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'description': string;
    /**
     * 
     * @type {InvoiceStatusResponse}
     * @memberof InvoiceResponseTypes
     */
    'currentState': InvoiceStatusResponse;
    /**
     * 
     * @type {TransferResponse}
     * @memberof InvoiceResponseTypes
     */
    'transfer'?: TransferResponse;
    /**
     * The entries of the invoice
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponseTypes
     */
    'invoiceEntries'?: Array<InvoiceEntryResponse>;
}
/**
 * 
 * @export
 * @interface InvoiceStatusResponse
 */
export interface InvoiceStatusResponse {
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof InvoiceStatusResponse
     */
    'changedBy': BaseUserResponse;
    /**
     * The state of the invoice
     * @type {string}
     * @memberof InvoiceStatusResponse
     */
    'state': InvoiceStatusResponseStateEnum;
}

export const InvoiceStatusResponseStateEnum = {
    Created: 'CREATED',
    Sent: 'SENT',
    Paid: 'PAID',
    Deleted: 'DELETED'
} as const;

export type InvoiceStatusResponseStateEnum = typeof InvoiceStatusResponseStateEnum[keyof typeof InvoiceStatusResponseStateEnum];

/**
 * 
 * @export
 * @interface InvoiceUser
 */
export interface InvoiceUser {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof InvoiceUser
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof InvoiceUser
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof InvoiceUser
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof InvoiceUser
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof InvoiceUser
     */
    'user': User;
    /**
     * Whether the user gets automatic invoices
     * @type {boolean}
     * @memberof InvoiceUser
     */
    'automatic'?: boolean;
}
/**
 * 
 * @export
 * @interface LocalUser
 */
export interface LocalUser {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof LocalUser
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof LocalUser
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof LocalUser
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof LocalUser
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof LocalUser
     */
    'user': User;
    /**
     * The hashed password of the user.
     * @type {string}
     * @memberof LocalUser
     */
    'passwordHash': string;
}
/**
 * 
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * The message response text.
     * @type {string}
     * @memberof MessageResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PaginatedBalanceResponse
 */
export interface PaginatedBalanceResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBalanceResponse
     */
    '_pagination'?: PaginationResult;
    /**
     * Returned balance responses
     * @type {Array<BalanceResponse>}
     * @memberof PaginatedBalanceResponse
     */
    'records'?: Array<BalanceResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedBannerResponse
 */
export interface PaginatedBannerResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBannerResponse
     */
    '_pagination'?: PaginationResult;
    /**
     * Returned banners
     * @type {Array<BannerResponse>}
     * @memberof PaginatedBannerResponse
     */
    'records'?: Array<BannerResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedBaseEventResponse
 */
export interface PaginatedBaseEventResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBaseEventResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned borrel Schemas
     * @type {Array<BaseEventResponse>}
     * @memberof PaginatedBaseEventResponse
     */
    'records': Array<BaseEventResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedBasePayoutRequestResponse
 */
export interface PaginatedBasePayoutRequestResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBasePayoutRequestResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned payout requests
     * @type {Array<BasePayoutRequestResponse>}
     * @memberof PaginatedBasePayoutRequestResponse
     */
    'records': Array<BasePayoutRequestResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedBaseTransactionResponse
 */
export interface PaginatedBaseTransactionResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedBaseTransactionResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned banners
     * @type {Array<BaseTransactionResponse>}
     * @memberof PaginatedBaseTransactionResponse
     */
    'records': Array<BaseTransactionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedContainerResponse
 */
export interface PaginatedContainerResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedContainerResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned containers
     * @type {Array<ContainerResponse>}
     * @memberof PaginatedContainerResponse
     */
    'records': Array<ContainerResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedContainerWithProductResponse
 */
export interface PaginatedContainerWithProductResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedContainerWithProductResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned containers
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PaginatedContainerWithProductResponse
     */
    'records': Array<ContainerWithProductsResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedEventShiftResponse
 */
export interface PaginatedEventShiftResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedEventShiftResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned event shifts
     * @type {Array<EventShiftResponse>}
     * @memberof PaginatedEventShiftResponse
     */
    'records': Array<EventShiftResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedFinancialMutationResponse
 */
export interface PaginatedFinancialMutationResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedFinancialMutationResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned mutations
     * @type {Array<FinancialMutationResponse>}
     * @memberof PaginatedFinancialMutationResponse
     */
    'records': Array<FinancialMutationResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedFineHandoutEventResponse
 */
export interface PaginatedFineHandoutEventResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedFineHandoutEventResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned fine handout events
     * @type {Array<BaseFineHandoutEventResponse>}
     * @memberof PaginatedFineHandoutEventResponse
     */
    'records': Array<BaseFineHandoutEventResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedInvoiceResponse
 */
export interface PaginatedInvoiceResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedInvoiceResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned Invoices
     * @type {Array<InvoiceResponseTypes>}
     * @memberof PaginatedInvoiceResponse
     */
    'records': Array<InvoiceResponseTypes>;
}
/**
 * 
 * @export
 * @interface PaginatedPointOfSaleResponse
 */
export interface PaginatedPointOfSaleResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedPointOfSaleResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned points of sale
     * @type {Array<PointOfSaleResponse>}
     * @memberof PaginatedPointOfSaleResponse
     */
    'records': Array<PointOfSaleResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedProductCategoryResponse
 */
export interface PaginatedProductCategoryResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedProductCategoryResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned product categories
     * @type {Array<ProductCategoryResponse>}
     * @memberof PaginatedProductCategoryResponse
     */
    'records': Array<ProductCategoryResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedProductResponse
 */
export interface PaginatedProductResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedProductResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned products
     * @type {Array<ProductResponse>}
     * @memberof PaginatedProductResponse
     */
    'records': Array<ProductResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedTransferResponse
 */
export interface PaginatedTransferResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedTransferResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned transfers
     * @type {Array<TransferResponse>}
     * @memberof PaginatedTransferResponse
     */
    'records': Array<TransferResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedUserResponse
 */
export interface PaginatedUserResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedUserResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned users
     * @type {Array<UserResponse>}
     * @memberof PaginatedUserResponse
     */
    'records': Array<UserResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedVatGroupResponse
 */
export interface PaginatedVatGroupResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedVatGroupResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned VAT groups
     * @type {Array<VatGroup>}
     * @memberof PaginatedVatGroupResponse
     */
    'records': Array<VatGroup>;
}
/**
 * 
 * @export
 * @interface PaginatedVoucherGroupResponse
 */
export interface PaginatedVoucherGroupResponse {
    /**
     * 
     * @type {PaginationResult}
     * @memberof PaginatedVoucherGroupResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned voucher groups
     * @type {Array<VoucherGroupResponse>}
     * @memberof PaginatedVoucherGroupResponse
     */
    'records': Array<VoucherGroupResponse>;
}
/**
 * 
 * @export
 * @interface PaginationResult
 */
export interface PaginationResult {
    /**
     * Number of records queried
     * @type {number}
     * @memberof PaginationResult
     */
    'take': number;
    /**
     * Number of skipped records
     * @type {number}
     * @memberof PaginationResult
     */
    'skip': number;
    /**
     * Total number of resulting records
     * @type {number}
     * @memberof PaginationResult
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface PayoutRequestRequest
 */
export interface PayoutRequestRequest {
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof PayoutRequestRequest
     */
    'amount': DineroObjectRequest;
    /**
     * The bank account number to transfer the money to
     * @type {string}
     * @memberof PayoutRequestRequest
     */
    'bankAccountNumber': string;
    /**
     * The name of the owner of the bank account
     * @type {string}
     * @memberof PayoutRequestRequest
     */
    'bankAccountName': string;
}
/**
 * 
 * @export
 * @interface PayoutRequestResponse
 */
export interface PayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PayoutRequestResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof PayoutRequestResponse
     */
    'amount': DineroObjectResponse;
    /**
     * Statuses of this payout response over time
     * @type {Array<PayoutRequestStatusResponse>}
     * @memberof PayoutRequestResponse
     */
    'status': Array<PayoutRequestStatusResponse>;
    /**
     * Bank account number
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'bankAccountNumber': string;
    /**
     * Name of the account owner
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'bankAccountName': string;
}
/**
 * 
 * @export
 * @interface PayoutRequestStatusRequest
 */
export interface PayoutRequestStatusRequest {
    /**
     * PayoutRequestState to change to.
     * @type {string}
     * @memberof PayoutRequestStatusRequest
     */
    'state'?: PayoutRequestStatusRequestStateEnum;
}

export const PayoutRequestStatusRequestStateEnum = {
    Created: 'CREATED',
    Approved: 'APPROVED',
    Denied: 'DENIED',
    Cancelled: 'CANCELLED'
} as const;

export type PayoutRequestStatusRequestStateEnum = typeof PayoutRequestStatusRequestStateEnum[keyof typeof PayoutRequestStatusRequestStateEnum];

/**
 * 
 * @export
 * @interface PayoutRequestStatusResponse
 */
export interface PayoutRequestStatusResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PayoutRequestStatusResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PayoutRequestStatusResponse
     */
    'version'?: number;
    /**
     * The state of this status change
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface PointOfSaleResponse
 */
export interface PointOfSaleResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PointOfSaleResponse
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleResponse
     */
    'useAuthentication': boolean;
}
/**
 * 
 * @export
 * @interface PointOfSaleWithContainersResponse
 */
export interface PointOfSaleWithContainersResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof PointOfSaleWithContainersResponse
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleWithContainersResponse
     */
    'useAuthentication': boolean;
    /**
     * The containers in the point-of-sale.
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PointOfSaleWithContainersResponse
     */
    'containers': Array<ContainerWithProductsResponse>;
}
/**
 * 
 * @export
 * @interface ProductCategoryRequest
 */
export interface ProductCategoryRequest {
    /**
     * Name/label of the productCategory
     * @type {string}
     * @memberof ProductCategoryRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ProductCategoryResponse
 */
export interface ProductCategoryResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ProductCategoryResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ProductCategoryResponse
     */
    'version'?: number;
    /**
     * The name of the productCategory.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ProductResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ProductResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ProductResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ProductResponse
     */
    'version'?: number;
    /**
     * The name of the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ProductResponse
     */
    'priceInclVat': DineroObjectResponse;
    /**
     * 
     * @type {BaseVatGroupResponse}
     * @memberof ProductResponse
     */
    'vat': BaseVatGroupResponse;
    /**
     * The product revision ID
     * @type {number}
     * @memberof ProductResponse
     */
    'revision': number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof ProductResponse
     */
    'owner': BaseUserResponse;
    /**
     * 
     * @type {ProductCategoryResponse}
     * @memberof ProductResponse
     */
    'category': ProductCategoryResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof ProductResponse
     */
    'priceExclVat': DineroObjectResponse;
    /**
     * The URL to the picture representing this product.
     * @type {string}
     * @memberof ProductResponse
     */
    'image'?: string;
    /**
     * The percentage of alcohol in this product.
     * @type {number}
     * @memberof ProductResponse
     */
    'alcoholPercentage': number;
}
/**
 * 
 * @export
 * @interface RelationResponse
 */
export interface RelationResponse {
    /**
     * The the ownership relation towards the entity.
     * @type {string}
     * @memberof RelationResponse
     */
    'relation'?: string;
    /**
     * The attributes of the entity for which there is access.
     * @type {Array<string>}
     * @memberof RelationResponse
     */
    'attributes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ResetLocalRequest
 */
export interface ResetLocalRequest {
    /**
     * The mail of the user
     * @type {string}
     * @memberof ResetLocalRequest
     */
    'accountMail': string;
}
/**
 * 
 * @export
 * @interface RevisionRequest
 */
export interface RevisionRequest {
    /**
     * revision id
     * @type {number}
     * @memberof RevisionRequest
     */
    'id': number;
    /**
     * revision number
     * @type {number}
     * @memberof RevisionRequest
     */
    'revision': number;
}
/**
 * 
 * @export
 * @interface RoleResponse
 */
export interface RoleResponse {
    /**
     * The name of the role.
     * @type {string}
     * @memberof RoleResponse
     */
    'role': string;
    /**
     * The permissions with regards to the entity.
     * @type {Array<EntityResponse>}
     * @memberof RoleResponse
     */
    'entities'?: Array<EntityResponse>;
}
/**
 * 
 * @export
 * @interface SimpleFileRequest
 */
export interface SimpleFileRequest {
    /**
     * Name of the file
     * @type {string}
     * @memberof SimpleFileRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface SimpleFileResponse
 */
export interface SimpleFileResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SimpleFileResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SimpleFileResponse
     */
    'version'?: number;
    /**
     * The filename of the file
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'downloadName': string;
    /**
     * The location of the file in storage
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'location': string;
    /**
     * 
     * @type {UserResponse}
     * @memberof SimpleFileResponse
     */
    'createdBy': UserResponse;
}
/**
 * 
 * @export
 * @interface StripeDepositResponse
 */
export interface StripeDepositResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripeDepositResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripeDepositResponse
     */
    'version'?: number;
    /**
     * The ID of the payment intent in Stripe
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'stripeId': string;
    /**
     * Current status of the deposit
     * @type {Array<StripeDepositStatusResponse>}
     * @memberof StripeDepositResponse
     */
    'depositStatus': Array<StripeDepositStatusResponse>;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof StripeDepositResponse
     */
    'amount': DineroObjectResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof StripeDepositResponse
     */
    'to': BaseUserResponse;
}
/**
 * 
 * @export
 * @interface StripeDepositStatusResponse
 */
export interface StripeDepositStatusResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripeDepositStatusResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripeDepositStatusResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripeDepositStatusResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripeDepositStatusResponse
     */
    'version'?: number;
    /**
     * State of the Stripe deposit. It can be 1 (\'CREATED\'), 2 (\'PROCESSING\'), 3 (\'SUCCEEDED\'), or 4 (\'FAILED\')
     * @type {number}
     * @memberof StripeDepositStatusResponse
     */
    'state': number;
}
/**
 * 
 * @export
 * @interface StripePaymentIntentResponse
 */
export interface StripePaymentIntentResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripePaymentIntentResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripePaymentIntentResponse
     */
    'version'?: number;
    /**
     * ID of the intent in Stripe.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'stripeId': string;
    /**
     * The client secret of the created Payment Intent.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'clientSecret': string;
}
/**
 * 
 * @export
 * @interface StripeRequest
 */
export interface StripeRequest {
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof StripeRequest
     */
    'amount'?: DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface SubTransactionRequest
 */
export interface SubTransactionRequest {
    /**
     * to user id
     * @type {number}
     * @memberof SubTransactionRequest
     */
    'to': number;
    /**
     * 
     * @type {RevisionRequest}
     * @memberof SubTransactionRequest
     */
    'container': RevisionRequest;
    /**
     * subtransaction rows
     * @type {Array<SubTransactionRowRequest>}
     * @memberof SubTransactionRequest
     */
    'subTransactionRows': Array<SubTransactionRowRequest>;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof SubTransactionRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface SubTransactionResponse
 */
export interface SubTransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SubTransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SubTransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SubTransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SubTransactionResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof SubTransactionResponse
     */
    'to': BaseUserResponse;
    /**
     * 
     * @type {BaseContainerResponse}
     * @memberof SubTransactionResponse
     */
    'container': BaseContainerResponse;
    /**
     * The rows of this     SubTransaction
     * @type {Array<SubTransactionRowResponse>}
     * @memberof SubTransactionResponse
     */
    'subTransactionRows': Array<SubTransactionRowResponse>;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof SubTransactionResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface SubTransactionRowRequest
 */
export interface SubTransactionRowRequest {
    /**
     * 
     * @type {RevisionRequest}
     * @memberof SubTransactionRowRequest
     */
    'product'?: RevisionRequest;
    /**
     * amount of this product in subtransaction
     * @type {number}
     * @memberof SubTransactionRowRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof SubTransactionRowRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface SubTransactionRowResponse
 */
export interface SubTransactionRowResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SubTransactionRowResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SubTransactionRowResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseProductResponse}
     * @memberof SubTransactionRowResponse
     */
    'product': BaseProductResponse;
    /**
     * The amount that has been bought
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'amount': number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof SubTransactionRowResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionFilterParameters
 */
export interface TransactionFilterParameters {
    /**
     * 
     * @type {Array<number>}
     * @memberof TransactionFilterParameters
     */
    'transactionId'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'fromId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'createdById'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'toId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionFilterParameters
     */
    'exclusiveToId'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'pointOfSaleId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'pointOfSaleRevision'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'containerId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'containerRevision'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'productId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'productRevision'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionFilterParameters
     */
    'fromDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionFilterParameters
     */
    'tillDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'invoiceId'?: number;
}
/**
 * 
 * @export
 * @interface TransactionReportCategoryEntryResponse
 */
export interface TransactionReportCategoryEntryResponse {
    /**
     * 
     * @type {ProductCategoryResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'category': ProductCategoryResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionReportDataResponse
 */
export interface TransactionReportDataResponse {
    /**
     * The entries grouped by product
     * @type {Array<TransactionReportEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'entries': Array<TransactionReportEntryResponse>;
    /**
     * The entries grouped by category
     * @type {Array<TransactionReportCategoryEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'categories': Array<TransactionReportCategoryEntryResponse>;
    /**
     * The entries grouped by vat
     * @type {Array<TransactionReportVatEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'vat': Array<TransactionReportVatEntryResponse>;
}
/**
 * 
 * @export
 * @interface TransactionReportEntryResponse
 */
export interface TransactionReportEntryResponse {
    /**
     * The amount of times this product is in the report
     * @type {number}
     * @memberof TransactionReportEntryResponse
     */
    'count': number;
    /**
     * 
     * @type {BaseProductResponse}
     * @memberof TransactionReportEntryResponse
     */
    'product': BaseProductResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionReportResponse
 */
export interface TransactionReportResponse {
    /**
     * 
     * @type {TransactionFilterParameters}
     * @memberof TransactionReportResponse
     */
    'parameters': TransactionFilterParameters;
    /**
     * 
     * @type {TransactionReportDataResponse}
     * @memberof TransactionReportResponse
     */
    'data': TransactionReportDataResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportResponse
     */
    'totalInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionReportVatEntryResponse
 */
export interface TransactionReportVatEntryResponse {
    /**
     * 
     * @type {BaseVatGroupResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'vat': BaseVatGroupResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransactionRequest
 */
export interface TransactionRequest {
    /**
     * from user id
     * @type {number}
     * @memberof TransactionRequest
     */
    'from': number;
    /**
     * createdBy user id
     * @type {number}
     * @memberof TransactionRequest
     */
    'createdBy'?: number;
    /**
     * subtransactions
     * @type {Array<SubTransactionRequest>}
     * @memberof TransactionRequest
     */
    'subTransactions': Array<SubTransactionRequest>;
    /**
     * 
     * @type {RevisionRequest}
     * @memberof TransactionRequest
     */
    'pointOfSale': RevisionRequest;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof TransactionRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 * 
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof TransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof TransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof TransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof TransactionResponse
     */
    'version'?: number;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransactionResponse
     */
    'from': BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransactionResponse
     */
    'createdBy'?: BaseUserResponse;
    /**
     * The subtransactions belonging to this transaction.
     * @type {Array<SubTransactionResponse>}
     * @memberof TransactionResponse
     */
    'subTransactions': Array<SubTransactionResponse>;
    /**
     * 
     * @type {BasePointOfSaleResponse}
     * @memberof TransactionResponse
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof TransactionResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 * 
 * @export
 * @interface TransferRequest
 */
export interface TransferRequest {
    /**
     * Description of the transfer
     * @type {string}
     * @memberof TransferRequest
     */
    'description'?: string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof TransferRequest
     */
    'amount'?: DineroObjectRequest;
    /**
     * Type of transfer
     * @type {number}
     * @memberof TransferRequest
     */
    'type'?: number;
    /**
     * from which user the money is being transferred
     * @type {number}
     * @memberof TransferRequest
     */
    'fromId'?: number;
    /**
     * to which user the money is being transferred.
     * @type {number}
     * @memberof TransferRequest
     */
    'toId'?: number;
}
/**
 * 
 * @export
 * @interface TransferResponse
 */
export interface TransferResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof TransferResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof TransferResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof TransferResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof TransferResponse
     */
    'version'?: number;
    /**
     * Description of the transfer
     * @type {string}
     * @memberof TransferResponse
     */
    'description': string;
    /**
     * 
     * @type {Dinero}
     * @memberof TransferResponse
     */
    'amount': Dinero;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransferResponse
     */
    'from'?: BaseUserResponse;
    /**
     * 
     * @type {BaseUserResponse}
     * @memberof TransferResponse
     */
    'to'?: BaseUserResponse;
    /**
     * 
     * @type {BaseInvoiceResponse}
     * @memberof TransferResponse
     */
    'invoice'?: BaseInvoiceResponse;
    /**
     * 
     * @type {StripeDepositResponse}
     * @memberof TransferResponse
     */
    'deposit'?: StripeDepositResponse;
    /**
     * 
     * @type {BasePayoutRequestResponse}
     * @memberof TransferResponse
     */
    'payoutRequest'?: BasePayoutRequestResponse;
    /**
     * 
     * @type {FineResponse}
     * @memberof TransferResponse
     */
    'fine'?: FineResponse;
    /**
     * 
     * @type {UserFineGroupResponse}
     * @memberof TransferResponse
     */
    'waivedFines'?: UserFineGroupResponse;
}
/**
 * 
 * @export
 * @interface UpdateContainerRequest
 */
export interface UpdateContainerRequest {
    /**
     * Name of the container
     * @type {string}
     * @memberof UpdateContainerRequest
     */
    'name': string;
    /**
     *    IDs or requests of the products to add to the container
     * @type {Array<number>}
     * @memberof UpdateContainerRequest
     */
    'products': Array<number>;
    /**
     * Whether the container is public or not
     * @type {boolean}
     * @memberof UpdateContainerRequest
     */
    'public': boolean;
}
/**
 * 
 * @export
 * @interface UpdateEventRequest
 */
export interface UpdateEventRequest {
    /**
     * Name of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'name'?: string;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'startDate'?: string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'endDate'?: string;
    /**
     * The type of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'type'?: string;
    /**
     * IDs of shifts that are in this event per participant per borrel.
     * @type {Array<number>}
     * @memberof UpdateEventRequest
     */
    'shiftIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UpdateInvoiceRequest
 */
export interface UpdateInvoiceRequest {
    /**
     * The user who updates the Invoice, defaults to the ID of the requester.
     * @type {number}
     * @memberof UpdateInvoiceRequest
     */
    'byId'?: number;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'addressee': string;
    /**
     * The description of the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'description': string;
    /**
     * The state to set of the invoice,
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'state'?: UpdateInvoiceRequestStateEnum;
}

export const UpdateInvoiceRequestStateEnum = {
    Created: 'CREATED',
    Sent: 'SENT',
    Paid: 'PAID',
    Deleted: 'DELETED'
} as const;

export type UpdateInvoiceRequestStateEnum = typeof UpdateInvoiceRequestStateEnum[keyof typeof UpdateInvoiceRequestStateEnum];

/**
 * 
 * @export
 * @interface UpdateKeyResponse
 */
export interface UpdateKeyResponse {
    /**
     * The key to return
     * @type {string}
     * @memberof UpdateKeyResponse
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface UpdateLocalRequest
 */
export interface UpdateLocalRequest {
    /**
     * The password to set
     * @type {string}
     * @memberof UpdateLocalRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UpdateNfcRequest
 */
export interface UpdateNfcRequest {
    /**
     * The NFC code to set
     * @type {string}
     * @memberof UpdateNfcRequest
     */
    'nfcCode': string;
}
/**
 * 
 * @export
 * @interface UpdatePinRequest
 */
export interface UpdatePinRequest {
    /**
     * The PIN code to set
     * @type {string}
     * @memberof UpdatePinRequest
     */
    'pin': string;
}
/**
 * 
 * @export
 * @interface UpdatePointOfSaleRequest
 */
export interface UpdatePointOfSaleRequest {
    /**
     * Name of the POS
     * @type {string}
     * @memberof UpdatePointOfSaleRequest
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof UpdatePointOfSaleRequest
     */
    'useAuthentication': boolean;
    /**
     * IDs or Requests of the containers to add to the POS
     * @type {Array<number>}
     * @memberof UpdatePointOfSaleRequest
     */
    'containers'?: Array<number>;
    /**
     * ID of the POS to update.
     * @type {number}
     * @memberof UpdatePointOfSaleRequest
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface UpdateProductRequest
 */
export interface UpdateProductRequest {
    /**
     * Name of the product
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'name': string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof UpdateProductRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * VAT group ID of the product
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'vat': number;
    /**
     * Category of the product
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'category': number;
    /**
     * Alcohol percentage of the product in 2 decimals
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'alcoholPercentage': number;
}
/**
 * 
 * @export
 * @interface UpdateShiftRequest
 */
export interface UpdateShiftRequest {
    /**
     * Name of the event
     * @type {string}
     * @memberof UpdateShiftRequest
     */
    'name'?: string;
    /**
     * Roles that (can) have this shift
     * @type {Array<string>}
     * @memberof UpdateShiftRequest
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'canGoIntoDebt'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'ofAge'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateVatGroupRequest
 */
export interface UpdateVatGroupRequest {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof UpdateVatGroupRequest
     */
    'name': string;
    /**
     * Whether this group should be hidden in the financial overviews when its value is zero
     * @type {boolean}
     * @memberof UpdateVatGroupRequest
     */
    'deleted': boolean;
    /**
     * Whether this group should be hidden from transactions
     * @type {boolean}
     * @memberof UpdateVatGroupRequest
     */
    'hidden': boolean;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof User
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * First name of the user.
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * Last name of the user.
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * Nickname of the user.
     * @type {string}
     * @memberof User
     */
    'nickname'?: string;
    /**
     * Whether the user has accepted the TOS. Defaults to false.
     * @type {boolean}
     * @memberof User
     */
    'active'?: boolean;
    /**
     * Whether the user can have a negative balance. Defaults to false
     * @type {boolean}
     * @memberof User
     */
    'canGoIntoDebt'?: boolean;
    /**
     * Whether the user is 18+ or not.
     * @type {boolean}
     * @memberof User
     */
    'ofAge'?: boolean;
    /**
     * The email of the user.
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * Whether the user was deleted. Defaults to false.
     * @type {boolean}
     * @memberof User
     */
    'deleted'?: boolean;
    /**
     * The type of user 1 (MEMBER), 2 (ORGAN), 3 (VOUCHER), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE).
     * @type {string}
     * @memberof User
     */
    'type': UserTypeEnum;
}

export const UserTypeEnum = {
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7'
} as const;

export type UserTypeEnum = typeof UserTypeEnum[keyof typeof UserTypeEnum];

/**
 * 
 * @export
 * @interface UserFineGroupResponse
 */
export interface UserFineGroupResponse {
    /**
     * Fines that have been handed out
     * @type {Array<FineResponse>}
     * @memberof UserFineGroupResponse
     */
    'fines': Array<FineResponse>;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof UserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof UserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof UserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof UserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof UserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof UserResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof UserResponse
     */
    'nickname'?: string;
    /**
     * Whether the user activated
     * @type {boolean}
     * @memberof UserResponse
     */
    'active': boolean;
    /**
     * Whether the user is deleted
     * @type {boolean}
     * @memberof UserResponse
     */
    'deleted': boolean;
    /**
     * The type of user
     * @type {string}
     * @memberof UserResponse
     */
    'type': string;
    /**
     * If local user, the e-mail of the user
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * Whether this user has accepted the TOS
     * @type {string}
     * @memberof UserResponse
     */
    'acceptedToS'?: string;
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof UserResponse
     */
    'extensiveDataProcessing'?: boolean;
    /**
     * Whether someone is old enough to drink beer
     * @type {boolean}
     * @memberof UserResponse
     */
    'ofAge'?: boolean;
    /**
     * Whether this user can get a negative balance
     * @type {boolean}
     * @memberof UserResponse
     */
    'canGoIntoDebt': boolean;
}
/**
 * 
 * @export
 * @interface UserToFineResponse
 */
export interface UserToFineResponse {
    /**
     * User ID
     * @type {number}
     * @memberof UserToFineResponse
     */
    'id': number;
    /**
     * 
     * @type {DineroObjectResponse}
     * @memberof UserToFineResponse
     */
    'fineAmount': DineroObjectResponse;
    /**
     * Balances at the given reference dates
     * @type {Array<BalanceResponse>}
     * @memberof UserToFineResponse
     */
    'balances': Array<BalanceResponse>;
}
/**
 * 
 * @export
 * @interface UserVoucherGroup
 */
export interface UserVoucherGroup {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof UserVoucherGroup
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof UserVoucherGroup
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof UserVoucherGroup
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof UserVoucherGroup
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof UserVoucherGroup
     */
    'user': User;
    /**
     * 
     * @type {VoucherGroup}
     * @memberof UserVoucherGroup
     */
    'voucherGroup': VoucherGroup;
}
/**
 * 
 * @export
 * @interface VatDeclarationResponse
 */
export interface VatDeclarationResponse {
    /**
     * Calendar year of this result table
     * @type {number}
     * @memberof VatDeclarationResponse
     */
    'calendarYear': number;
    /**
     * The used VAT declaration period the rows below are based upon
     * @type {string}
     * @memberof VatDeclarationResponse
     */
    'period': string;
    /**
     * The rows of the result table
     * @type {Array<VatDeclarationRow>}
     * @memberof VatDeclarationResponse
     */
    'rows': Array<VatDeclarationRow>;
}
/**
 * 
 * @export
 * @interface VatDeclarationRow
 */
export interface VatDeclarationRow {
    /**
     * ID of the VAT group
     * @type {number}
     * @memberof VatDeclarationRow
     */
    'id': number;
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatDeclarationRow
     */
    'name': string;
    /**
     * Percentage of VAT in this group
     * @type {number}
     * @memberof VatDeclarationRow
     */
    'percentage': number;
    /**
     * Amount of VAT to be paid to the tax administration per period
     * @type {Array<DineroObject>}
     * @memberof VatDeclarationRow
     */
    'values': Array<DineroObject>;
}
/**
 * 
 * @export
 * @interface VatGroup
 */
export interface VatGroup {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof VatGroup
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof VatGroup
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof VatGroup
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof VatGroup
     */
    'id': number;
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroup
     */
    'name'?: string;
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroup
     */
    'percentage'?: number;
    /**
     * Whether this group is soft-deleted
     * @type {boolean}
     * @memberof VatGroup
     */
    'deleted'?: boolean;
    /**
     * Whether this group is hidden from transactions
     * @type {boolean}
     * @memberof VatGroup
     */
    'hidden'?: boolean;
}
/**
 * 
 * @export
 * @interface VatGroupRequest
 */
export interface VatGroupRequest {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroupRequest
     */
    'name': string;
    /**
     * Whether this group should be hidden in the financial overviews when its value is zero
     * @type {boolean}
     * @memberof VatGroupRequest
     */
    'deleted': boolean;
    /**
     * Whether this group should be hidden from transactions
     * @type {boolean}
     * @memberof VatGroupRequest
     */
    'hidden': boolean;
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroupRequest
     */
    'percentage': number;
}
/**
 * 
 * @export
 * @interface VoucherGroup
 */
export interface VoucherGroup {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof VoucherGroup
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof VoucherGroup
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof VoucherGroup
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof VoucherGroup
     */
    'id': number;
    /**
     * Name of the group.
     * @type {string}
     * @memberof VoucherGroup
     */
    'name': string;
    /**
     * Date after which the included cards are active.
     * @type {string}
     * @memberof VoucherGroup
     */
    'activeStartDate': string;
    /**
     * Date after which cards are no longer active.
     * @type {string}
     * @memberof VoucherGroup
     */
    'activeEndDate'?: string;
    /**
     * Cards included in this group.
     * @type {Array<User>}
     * @memberof VoucherGroup
     */
    'vouchers': Array<User>;
}
/**
 * 
 * @export
 * @interface VoucherGroupRequest
 */
export interface VoucherGroupRequest {
    /**
     * Name of the group
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'name': string;
    /**
     * Date from which the included cards are active
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'activeStartDate': string;
    /**
     * Date from which cards are no longer active
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'activeEndDate': string;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof VoucherGroupRequest
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the voucher group
     * @type {number}
     * @memberof VoucherGroupRequest
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface VoucherGroupResponse
 */
export interface VoucherGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'version'?: number;
    /**
     * Name of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'name': string;
    /**
     * Start date of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'activeStartDate'?: string;
    /**
     * End date of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'activeEndDate': string;
    /**
     * Users in the voucher group
     * @type {Array<UserResponse>}
     * @memberof VoucherGroupResponse
     */
    'users': Array<UserResponse>;
    /**
     * 
     * @type {DineroObjectRequest}
     * @memberof VoucherGroupResponse
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the voucher group
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'amount': number;
}

/**
 * AuthenticateApi - axios parameter creator
 * @export
 */
export const AuthenticateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary EAN login and hand out token
         * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication: async (authenticationEanRequest: AuthenticationEanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationEanRequest' is not null or undefined
            assertParamExists('eanAuthentication', 'authenticationEanRequest', authenticationEanRequest)
            const localVarPath = `/authentication/ean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationEanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication: async (authenticationLDAPRequest: AuthenticationLDAPRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationLDAPRequest' is not null or undefined
            assertParamExists('gewisLDAPAuthentication', 'authenticationLDAPRequest', authenticationLDAPRequest)
            const localVarPath = `/authentication/GEWIS/LDAP`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationLDAPRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication: async (gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gEWISAuthenticationPinRequest' is not null or undefined
            assertParamExists('gewisPinAuthentication', 'gEWISAuthenticationPinRequest', gEWISAuthenticationPinRequest)
            const localVarPath = `/authentication/GEWIS/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gEWISAuthenticationPinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication: async (gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gewiswebAuthenticationRequest' is not null or undefined
            assertParamExists('gewisWebAuthentication', 'gewiswebAuthenticationRequest', gewiswebAuthenticationRequest)
            const localVarPath = `/authentication/gewisweb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gewiswebAuthenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Key login and hand out token.
         * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication: async (authenticationKeyRequest: AuthenticationKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationKeyRequest' is not null or undefined
            assertParamExists('keyAuthentication', 'authenticationKeyRequest', authenticationKeyRequest)
            const localVarPath = `/authentication/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Local login and hand out token
         * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication: async (authenticationLocalRequest: AuthenticationLocalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationLocalRequest' is not null or undefined
            assertParamExists('localAuthentication', 'authenticationLocalRequest', authenticationLocalRequest)
            const localVarPath = `/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationLocalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mock login and hand out token.
         * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication: async (authenticationMockRequest: AuthenticationMockRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationMockRequest' is not null or undefined
            assertParamExists('mockAuthentication', 'authenticationMockRequest', authenticationMockRequest)
            const localVarPath = `/authentication/mock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationMockRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary NFC login and hand out token
         * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication: async (authenticationNfcRequest: AuthenticationNfcRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationNfcRequest' is not null or undefined
            assertParamExists('nfcAuthentication', 'authenticationNfcRequest', authenticationNfcRequest)
            const localVarPath = `/authentication/nfc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationNfcRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PIN login and hand out token
         * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication: async (authenticationPinRequest: AuthenticationPinRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationPinRequest' is not null or undefined
            assertParamExists('pinAuthentication', 'authenticationPinRequest', authenticationPinRequest)
            const localVarPath = `/authentication/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationPinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authentication/refreshToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a reset token for the local authentication
         * @param {ResetLocalRequest} resetLocalRequest The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal: async (resetLocalRequest: ResetLocalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetLocalRequest' is not null or undefined
            assertParamExists('resetLocal', 'resetLocalRequest', resetLocalRequest)
            const localVarPath = `/authentication/local/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetLocalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken: async (authenticationResetTokenRequest: AuthenticationResetTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationResetTokenRequest' is not null or undefined
            assertParamExists('resetLocalWithToken', 'authenticationResetTokenRequest', authenticationResetTokenRequest)
            const localVarPath = `/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationResetTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticateApi - functional programming interface
 * @export
 */
export const AuthenticateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary EAN login and hand out token
         * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eanAuthentication(authenticationEanRequest: AuthenticationEanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eanAuthentication(authenticationEanRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.eanAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gewisLDAPAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gewisLDAPAuthentication(authenticationLDAPRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.gewisLDAPAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gewisPinAuthentication(gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gewisPinAuthentication(gEWISAuthenticationPinRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.gewisPinAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gewisWebAuthentication(gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gewisWebAuthentication(gewiswebAuthenticationRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.gewisWebAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Key login and hand out token.
         * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyAuthentication(authenticationKeyRequest: AuthenticationKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyAuthentication(authenticationKeyRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.keyAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Local login and hand out token
         * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localAuthentication(authenticationLocalRequest: AuthenticationLocalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localAuthentication(authenticationLocalRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.localAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Mock login and hand out token.
         * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mockAuthentication(authenticationMockRequest: AuthenticationMockRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mockAuthentication(authenticationMockRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.mockAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary NFC login and hand out token
         * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nfcAuthentication(authenticationNfcRequest: AuthenticationNfcRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nfcAuthentication(authenticationNfcRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.nfcAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary PIN login and hand out token
         * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinAuthentication(authenticationPinRequest: AuthenticationPinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinAuthentication(authenticationPinRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.pinAuthentication']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.refreshToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a reset token for the local authentication
         * @param {ResetLocalRequest} resetLocalRequest The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetLocal(resetLocalRequest: ResetLocalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetLocal(resetLocalRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.resetLocal']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetLocalWithToken(authenticationResetTokenRequest: AuthenticationResetTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetLocalWithToken(authenticationResetTokenRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthenticateApi.resetLocalWithToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthenticateApi - factory interface
 * @export
 */
export const AuthenticateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticateApiFp(configuration)
    return {
        /**
         * 
         * @summary EAN login and hand out token
         * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication(authenticationEanRequest: AuthenticationEanRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.eanAuthentication(authenticationEanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.gewisLDAPAuthentication(authenticationLDAPRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication(gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.gewisPinAuthentication(gEWISAuthenticationPinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication(gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.gewisWebAuthentication(gewiswebAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Key login and hand out token.
         * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication(authenticationKeyRequest: AuthenticationKeyRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.keyAuthentication(authenticationKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Local login and hand out token
         * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication(authenticationLocalRequest: AuthenticationLocalRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.localAuthentication(authenticationLocalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mock login and hand out token.
         * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication(authenticationMockRequest: AuthenticationMockRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.mockAuthentication(authenticationMockRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary NFC login and hand out token
         * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication(authenticationNfcRequest: AuthenticationNfcRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.nfcAuthentication(authenticationNfcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PIN login and hand out token
         * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication(authenticationPinRequest: AuthenticationPinRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.pinAuthentication(authenticationPinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a reset token for the local authentication
         * @param {ResetLocalRequest} resetLocalRequest The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal(resetLocalRequest: ResetLocalRequest, options?: any): AxiosPromise<string> {
            return localVarFp.resetLocal(resetLocalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken(authenticationResetTokenRequest: AuthenticationResetTokenRequest, options?: any): AxiosPromise<string> {
            return localVarFp.resetLocalWithToken(authenticationResetTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticateApi - object-oriented interface
 * @export
 * @class AuthenticateApi
 * @extends {BaseAPI}
 */
export class AuthenticateApi extends BaseAPI {
    /**
     * 
     * @summary EAN login and hand out token
     * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public eanAuthentication(authenticationEanRequest: AuthenticationEanRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).eanAuthentication(authenticationEanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public gewisLDAPAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).gewisLDAPAuthentication(authenticationLDAPRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public gewisPinAuthentication(gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).gewisPinAuthentication(gEWISAuthenticationPinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public gewisWebAuthentication(gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).gewisWebAuthentication(gewiswebAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Key login and hand out token.
     * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public keyAuthentication(authenticationKeyRequest: AuthenticationKeyRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).keyAuthentication(authenticationKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Local login and hand out token
     * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public localAuthentication(authenticationLocalRequest: AuthenticationLocalRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).localAuthentication(authenticationLocalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mock login and hand out token.
     * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public mockAuthentication(authenticationMockRequest: AuthenticationMockRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).mockAuthentication(authenticationMockRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary NFC login and hand out token
     * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public nfcAuthentication(authenticationNfcRequest: AuthenticationNfcRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).nfcAuthentication(authenticationNfcRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PIN login and hand out token
     * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public pinAuthentication(authenticationPinRequest: AuthenticationPinRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).pinAuthentication(authenticationPinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public refreshToken(options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a reset token for the local authentication
     * @param {ResetLocalRequest} resetLocalRequest The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public resetLocal(resetLocalRequest: ResetLocalRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).resetLocal(resetLocalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    public resetLocalWithToken(authenticationResetTokenRequest: AuthenticationResetTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthenticateApiFp(this.configuration).resetLocalWithToken(authenticationResetTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BalanceApi - axios parameter creator
 * @export
 */
export const BalanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get balance of the current user
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {GetAllBalanceUserTypeEnum} [userType] Filter based on user type.
         * @param {string} [orderBy] Column to order balance by - eg: id,amount
         * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance: async (date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userType?: GetAllBalanceUserTypeEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/balances/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (minBalance !== undefined) {
                localVarQueryParameter['minBalance'] = minBalance;
            }

            if (maxBalance !== undefined) {
                localVarQueryParameter['maxBalance'] = maxBalance;
            }

            if (hasFine !== undefined) {
                localVarQueryParameter['hasFine'] = hasFine;
            }

            if (minFine !== undefined) {
                localVarQueryParameter['minFine'] = minFine;
            }

            if (maxFine !== undefined) {
                localVarQueryParameter['maxFine'] = maxFine;
            }

            if (userType !== undefined) {
                localVarQueryParameter['userType'] = userType;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBalanceId', 'id', id)
            const localVarPath = `/balances/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceApi - functional programming interface
 * @export
 */
export const BalanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalanceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get balance of the current user
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {GetAllBalanceUserTypeEnum} [userType] Filter based on user type.
         * @param {string} [orderBy] Column to order balance by - eg: id,amount
         * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userType?: GetAllBalanceUserTypeEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userType, orderBy, orderDirection, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BalanceApi.getAllBalance']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceId(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BalanceApi.getBalanceId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalances(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalances(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BalanceApi.getBalances']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BalanceApi - factory interface
 * @export
 */
export const BalanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalanceApiFp(configuration)
    return {
        /**
         * 
         * @summary Get balance of the current user
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {GetAllBalanceUserTypeEnum} [userType] Filter based on user type.
         * @param {string} [orderBy] Column to order balance by - eg: id,amount
         * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userType?: GetAllBalanceUserTypeEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, take?: number, skip?: number, options?: any): AxiosPromise<Array<BalanceResponse>> {
            return localVarFp.getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userType, orderBy, orderDirection, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId(id: number, options?: any): AxiosPromise<BalanceResponse> {
            return localVarFp.getBalanceId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances(options?: any): AxiosPromise<BalanceResponse> {
            return localVarFp.getBalances(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalanceApi - object-oriented interface
 * @export
 * @class BalanceApi
 * @extends {BaseAPI}
 */
export class BalanceApi extends BaseAPI {
    /**
     * 
     * @summary Get balance of the current user
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {boolean} [hasFine] Only users with(out) fines
     * @param {number} [minFine] Minimum fine
     * @param {number} [maxFine] Maximum fine
     * @param {GetAllBalanceUserTypeEnum} [userType] Filter based on user type.
     * @param {string} [orderBy] Column to order balance by - eg: id,amount
     * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userType?: GetAllBalanceUserTypeEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return BalanceApiFp(this.configuration).getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userType, orderBy, orderDirection, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public getBalanceId(id: number, options?: RawAxiosRequestConfig) {
        return BalanceApiFp(this.configuration).getBalanceId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public getBalances(options?: RawAxiosRequestConfig) {
        return BalanceApiFp(this.configuration).getBalances(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllBalanceUserTypeEnum = {
    Member: 'MEMBER',
    Organ: 'ORGAN',
    Voucher: 'VOUCHER',
    LocalUser: 'LOCAL_USER',
    LocalAdmin: 'LOCAL_ADMIN',
    Invoice: 'INVOICE',
    AutomaticInvoice: 'AUTOMATIC_INVOICE'
} as const;
export type GetAllBalanceUserTypeEnum = typeof GetAllBalanceUserTypeEnum[keyof typeof GetAllBalanceUserTypeEnum];
/**
 * @export
 */
export const GetAllBalanceOrderDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetAllBalanceOrderDirectionEnum = typeof GetAllBalanceOrderDirectionEnum[keyof typeof GetAllBalanceOrderDirectionEnum];


/**
 * BannersApi - axios parameter creator
 * @export
 */
export const BannersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Saves a banner to the database
         * @param {BannerRequest} bannerRequest The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (bannerRequest: BannerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bannerRequest' is not null or undefined
            assertParamExists('create', 'bannerRequest', bannerRequest)
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bannerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banners/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/open/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBanner', 'id', id)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} bannerRequest The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: number, bannerRequest: BannerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'bannerRequest' is not null or undefined
            assertParamExists('update', 'bannerRequest', bannerRequest)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bannerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateImage', 'id', id)
            const localVarPath = `/banners/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BannersApi - functional programming interface
 * @export
 */
export const BannersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BannersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi._delete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Saves a banner to the database
         * @param {BannerRequest} bannerRequest The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(bannerRequest: BannerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(bannerRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.create']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActive(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActive(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.getActive']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBanners(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.getAllBanners']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOpenBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOpenBanners(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.getAllOpenBanners']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBanner(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBanner(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.getBanner']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} bannerRequest The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: number, bannerRequest: BannerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, bannerRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.update']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImage(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImage(id, file, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BannersApi.updateImage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BannersApi - factory interface
 * @export
 */
export const BannersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BannersApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): AxiosPromise<BannerResponse> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Saves a banner to the database
         * @param {BannerRequest} bannerRequest The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(bannerRequest: BannerRequest, options?: any): AxiosPromise<BannerResponse> {
            return localVarFp.create(bannerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse> {
            return localVarFp.getActive(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse> {
            return localVarFp.getAllBanners(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse> {
            return localVarFp.getAllOpenBanners(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner(id: number, options?: any): AxiosPromise<BannerResponse> {
            return localVarFp.getBanner(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} bannerRequest The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: number, bannerRequest: BannerRequest, options?: any): AxiosPromise<BannerResponse> {
            return localVarFp.update(id, bannerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id: number, file?: File, options?: any): AxiosPromise<void> {
            return localVarFp.updateImage(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BannersApi - object-oriented interface
 * @export
 * @class BannersApi
 * @extends {BaseAPI}
 */
export class BannersApi extends BaseAPI {
    /**
     * 
     * @summary Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public _delete(id: number, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Saves a banner to the database
     * @param {BannerRequest} bannerRequest The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public create(bannerRequest: BannerRequest, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).create(bannerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getActive(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).getActive(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getAllBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).getAllBanners(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getAllOpenBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).getAllOpenBanners(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getBanner(id: number, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).getBanner(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} bannerRequest The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public update(id: number, bannerRequest: BannerRequest, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).update(id, bannerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public updateImage(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).updateImage(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new container.
         * @param {CreateContainerRequest} createContainerRequest    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer: async (createContainerRequest: CreateContainerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createContainerRequest' is not null or undefined
            assertParamExists('createContainer', 'createContainerRequest', createContainerRequest)
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContainerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductsContainer', 'id', id)
            const localVarPath = `/containers/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/containers/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleContainer', 'id', id)
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: async (id: number, updateContainerRequest: UpdateContainerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateContainer', 'id', id)
            // verify required parameter 'updateContainerRequest' is not null or undefined
            assertParamExists('updateContainer', 'updateContainerRequest', updateContainerRequest)
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContainerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new container.
         * @param {CreateContainerRequest} createContainerRequest    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainer(createContainerRequest: CreateContainerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContainer(createContainerRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.createContainer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllContainers(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.getAllContainers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsContainer(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsContainer(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.getProductsContainer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicContainers(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.getPublicContainers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleContainer(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleContainer(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.getSingleContainer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainer(id: number, updateContainerRequest: UpdateContainerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContainer(id, updateContainerRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContainersApi.updateContainer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new container.
         * @param {CreateContainerRequest} createContainerRequest    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(createContainerRequest: CreateContainerRequest, options?: any): AxiosPromise<ContainerWithProductsResponse> {
            return localVarFp.createContainer(createContainerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getAllContainers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse> {
            return localVarFp.getProductsContainer(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getPublicContainers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer(id: number, options?: any): AxiosPromise<ContainerWithProductsResponse> {
            return localVarFp.getSingleContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(id: number, updateContainerRequest: UpdateContainerRequest, options?: any): AxiosPromise<ContainerWithProductsResponse> {
            return localVarFp.updateContainer(id, updateContainerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new container.
     * @param {CreateContainerRequest} createContainerRequest    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public createContainer(createContainerRequest: CreateContainerRequest, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).createContainer(createContainerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getAllContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getAllContainers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getProductsContainer(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getProductsContainer(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getPublicContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getPublicContainers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public getSingleContainer(id: number, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).getSingleContainer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainer(id: number, updateContainerRequest: UpdateContainerRequest, options?: RawAxiosRequestConfig) {
        return ContainersApiFp(this.configuration).updateContainer(id, updateContainerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DebtorsApi - axios parameter creator
 * @export
 */
export const DebtorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFine: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFine', 'id', id)
            const localVarPath = `/fines/single/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoutFines: async (handoutFinesRequest: HandoutFinesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'handoutFinesRequest' is not null or undefined
            assertParamExists('handoutFines', 'handoutFinesRequest', handoutFinesRequest)
            const localVarPath = `/fines/handout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(handoutFinesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyAboutFutureFines: async (handoutFinesRequest: HandoutFinesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'handoutFinesRequest' is not null or undefined
            assertParamExists('notifyAboutFutureFines', 'handoutFinesRequest', handoutFinesRequest)
            const localVarPath = `/fines/notify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(handoutFinesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnAllFineHandoutEvents: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnSingleFineHandoutEvent: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('returnSingleFineHandoutEvent', 'id', id)
            const localVarPath = `/fines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DebtorsApi - functional programming interface
 * @export
 */
export const DebtorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DebtorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFine(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFine(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.deleteFine']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handoutFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineHandoutEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handoutFines(handoutFinesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.handoutFines']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyAboutFutureFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyAboutFutureFines(handoutFinesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.notifyAboutFutureFines']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnAllFineHandoutEvents(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFineHandoutEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnAllFineHandoutEvents(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.returnAllFineHandoutEvents']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnSingleFineHandoutEvent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineHandoutEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnSingleFineHandoutEvent(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DebtorsApi.returnSingleFineHandoutEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DebtorsApi - factory interface
 * @export
 */
export const DebtorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DebtorsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFine(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteFine(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoutFines(handoutFinesRequest: HandoutFinesRequest, options?: any): AxiosPromise<FineHandoutEventResponse> {
            return localVarFp.handoutFines(handoutFinesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} handoutFinesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyAboutFutureFines(handoutFinesRequest: HandoutFinesRequest, options?: any): AxiosPromise<string> {
            return localVarFp.notifyAboutFutureFines(handoutFinesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnAllFineHandoutEvents(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedFineHandoutEventResponse> {
            return localVarFp.returnAllFineHandoutEvents(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnSingleFineHandoutEvent(id: number, options?: any): AxiosPromise<FineHandoutEventResponse> {
            return localVarFp.returnSingleFineHandoutEvent(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DebtorsApi - object-oriented interface
 * @export
 * @class DebtorsApi
 * @extends {BaseAPI}
 */
export class DebtorsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a fine
     * @param {number} id The id of the fine which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public deleteFine(id: number, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).deleteFine(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
     * @param {HandoutFinesRequest} handoutFinesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public handoutFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).handoutFines(handoutFinesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send an email to all given users about their possible future fine.
     * @param {HandoutFinesRequest} handoutFinesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public notifyAboutFutureFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).notifyAboutFutureFines(handoutFinesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all fine handout events
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public returnAllFineHandoutEvents(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).returnAllFineHandoutEvents(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all fine handout events
     * @param {number} id The id of the fine handout event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    public returnSingleFineHandoutEvent(id: number, options?: RawAxiosRequestConfig) {
        return DebtorsApiFp(this.configuration).returnSingleFineHandoutEvent(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignEventShift: async (eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('assignEventShift', 'eventId', eventId)
            // verify required parameter 'shiftId' is not null or undefined
            assertParamExists('assignEventShift', 'shiftId', shiftId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignEventShift', 'userId', userId)
            // verify required parameter 'eventAnswerAssignmentRequest' is not null or undefined
            assertParamExists('assignEventShift', 'eventAnswerAssignmentRequest', eventAnswerAssignmentRequest)
            const localVarPath = `/events/{eventId}/shift/{shiftId}/user/{userId}/assign`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"shiftId"}}`, encodeURIComponent(String(shiftId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventAnswerAssignmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an event with its corresponding answers objects
         * @param {CreateEventRequest} createEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (createEventRequest: CreateEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventRequest' is not null or undefined
            assertParamExists('createEvent', 'createEventRequest', createEventRequest)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an event shift
         * @param {CreateShiftRequest} createShiftRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventShift: async (createShiftRequest: CreateShiftRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createShiftRequest' is not null or undefined
            assertParamExists('createEventShift', 'createShiftRequest', createShiftRequest)
            const localVarPath = `/eventshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createShiftRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventShift: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEventShift', 'id', id)
            const localVarPath = `/eventshifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventShifts: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eventshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents: async (name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = beforeDate;
            }

            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = afterDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event shift
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventShiftCount: async (id: number, eventType?: string, afterDate?: string, beforeDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEventShiftCount', 'id', id)
            const localVarPath = `/eventshifts/{id}/counts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = afterDate;
            }

            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = beforeDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (id: number, updateEventRequest: UpdateEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEvent', 'id', id)
            // verify required parameter 'updateEventRequest' is not null or undefined
            assertParamExists('updateEvent', 'updateEventRequest', updateEventRequest)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} updateShiftRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventShift: async (id: number, updateShiftRequest: UpdateShiftRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEventShift', 'id', id)
            // verify required parameter 'updateShiftRequest' is not null or undefined
            assertParamExists('updateEventShift', 'updateShiftRequest', updateShiftRequest)
            const localVarPath = `/eventshifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateShiftRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventShiftAvailability: async (eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'eventId', eventId)
            // verify required parameter 'shiftId' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'shiftId', shiftId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'userId', userId)
            // verify required parameter 'eventAnswerAvailabilityRequest' is not null or undefined
            assertParamExists('updateEventShiftAvailability', 'eventAnswerAvailabilityRequest', eventAnswerAvailabilityRequest)
            const localVarPath = `/events/{eventId}/shift/{shiftId}/user/{userId}/availability`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"shiftId"}}`, encodeURIComponent(String(shiftId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventAnswerAvailabilityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignEventShift(eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEventAnswerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.assignEventShift']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create an event with its corresponding answers objects
         * @param {CreateEventRequest} createEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(createEventRequest: CreateEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(createEventRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.createEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create an event shift
         * @param {CreateShiftRequest} createShiftRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventShift(createShiftRequest: CreateShiftRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventShiftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventShift(createShiftRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.createEventShift']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.deleteEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventShift(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventShift(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.deleteEventShift']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEventShifts(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEventShiftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEventShifts(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getAllEventShifts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getAllEvents']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event shift
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventShiftCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaginatedEventShiftResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventShiftCount(id, eventType, afterDate, beforeDate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getEventShiftCount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleEvent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleEvent(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getSingleEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(id: number, updateEventRequest: UpdateEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(id, updateEventRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.updateEvent']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} updateShiftRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventShift(id: number, updateShiftRequest: UpdateShiftRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventShiftResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventShift(id, updateShiftRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.updateEventShift']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEventAnswerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.updateEventShiftAvailability']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignEventShift(eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options?: any): AxiosPromise<BaseEventAnswerResponse> {
            return localVarFp.assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an event with its corresponding answers objects
         * @param {CreateEventRequest} createEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(createEventRequest: CreateEventRequest, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.createEvent(createEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an event shift
         * @param {CreateShiftRequest} createShiftRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventShift(createShiftRequest: CreateShiftRequest, options?: any): AxiosPromise<EventShiftResponse> {
            return localVarFp.createEventShift(createShiftRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventShift(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteEventShift(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventShifts(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedEventShiftResponse> {
            return localVarFp.getAllEventShifts(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseEventResponse> {
            return localVarFp.getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event shift
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventShiftCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: any): AxiosPromise<Array<PaginatedEventShiftResponse>> {
            return localVarFp.getEventShiftCount(id, eventType, afterDate, beforeDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleEvent(id: number, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.getSingleEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} updateEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(id: number, updateEventRequest: UpdateEventRequest, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.updateEvent(id, updateEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} updateShiftRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventShift(id: number, updateShiftRequest: UpdateShiftRequest, options?: any): AxiosPromise<EventShiftResponse> {
            return localVarFp.updateEventShift(id, updateShiftRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options?: any): AxiosPromise<BaseEventAnswerResponse> {
            return localVarFp.updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Change the assignment of users to shifts on an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public assignEventShift(eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an event with its corresponding answers objects
     * @param {CreateEventRequest} createEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEvent(createEventRequest: CreateEventRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEvent(createEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an event shift
     * @param {CreateShiftRequest} createShiftRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEventShift(createShiftRequest: CreateShiftRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEventShift(createShiftRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an event with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEvent(id: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an event shift with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEventShift(id: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEventShift(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all event shifts
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getAllEventShifts(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getAllEventShifts(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all events
     * @param {string} [name] Name of the event
     * @param {number} [createdById] ID of user that created the event
     * @param {string} [beforeDate] Get only events that start after this date
     * @param {string} [afterDate] Get only events that start before this date
     * @param {string} [type] Get only events that are this type
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the number of times a user has been selected for the given shift
     * @param {number} id The id of the event shift
     * @param {string} [eventType] Only include events of this type
     * @param {string} [afterDate] Only include events after this date
     * @param {string} [beforeDate] Only include events before this date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventShiftCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventShiftCount(id, eventType, afterDate, beforeDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single event with its answers and shifts
     * @param {number} id The id of the event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getSingleEvent(id: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getSingleEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an event with its corresponding answers objects
     * @param {number} id The id of the event which should be returned
     * @param {UpdateEventRequest} updateEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(id: number, updateEventRequest: UpdateEventRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEvent(id, updateEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an event shift
     * @param {number} id The id of the event which should be returned
     * @param {UpdateShiftRequest} updateShiftRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEventShift(id: number, updateShiftRequest: UpdateShiftRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEventShift(id, updateShiftRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the availability of a user for a shift in an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a file with the given name.
         * @param {string} name The name of the file
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (name: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createFile', 'name', name)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload a file with the given name.
         * @param {string} name The name of the file
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(name: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(name, file, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FilesApi.createFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FilesApi.deleteFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FilesApi.getFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload a file with the given name.
         * @param {string} name The name of the file
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(name: string, file?: File, options?: any): AxiosPromise<SimpleFileResponse> {
            return localVarFp.createFile(name, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.getFile(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Upload a file with the given name.
     * @param {string} name The name of the file
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public createFile(name: string, file?: File, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).createFile(name, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFile(id: number, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(id: number, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFile(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {CreateInvoiceRequest} [createInvoiceRequest] The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice: async (createInvoiceRequest?: CreateInvoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInvoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInvoice', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices: async (toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (invoiceId !== undefined) {
                localVarQueryParameter['invoiceId'] = invoiceId;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (returnEntries !== undefined) {
                localVarQueryParameter['returnEntries'] = returnEntries;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice: async (id: number, returnEntries?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleInvoice', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (returnEntries !== undefined) {
                localVarQueryParameter['returnEntries'] = returnEntries;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} [updateInvoiceRequest] The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice: async (id: number, updateInvoiceRequest?: UpdateInvoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateInvoice', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateInvoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {CreateInvoiceRequest} [createInvoiceRequest] The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoice(createInvoiceRequest?: CreateInvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoice(createInvoiceRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.createInvoice']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoice(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoice(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.deleteInvoice']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllInvoices(toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.getAllInvoices']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleInvoice(id: number, returnEntries?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleInvoice(id, returnEntries, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.getSingleInvoice']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} [updateInvoiceRequest] The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvoice(id: number, updateInvoiceRequest?: UpdateInvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInvoice(id, updateInvoiceRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['InvoicesApi.updateInvoice']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {CreateInvoiceRequest} [createInvoiceRequest] The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(createInvoiceRequest?: CreateInvoiceRequest, options?: any): AxiosPromise<InvoiceResponse> {
            return localVarFp.createInvoice(createInvoiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice(id: number, options?: any): AxiosPromise<BaseInvoiceResponse> {
            return localVarFp.deleteInvoice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices(toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedInvoiceResponse> {
            return localVarFp.getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice(id: number, returnEntries?: boolean, options?: any): AxiosPromise<InvoiceResponse> {
            return localVarFp.getSingleInvoice(id, returnEntries, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} [updateInvoiceRequest] The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(id: number, updateInvoiceRequest?: UpdateInvoiceRequest, options?: any): AxiosPromise<BaseInvoiceResponse> {
            return localVarFp.updateInvoice(id, updateInvoiceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * 
     * @summary Adds an invoice to the system.
     * @param {CreateInvoiceRequest} [createInvoiceRequest] The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public createInvoice(createInvoiceRequest?: CreateInvoiceRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).createInvoice(createInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public deleteInvoice(id: number, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).deleteInvoice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getAllInvoices(toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getSingleInvoice(id: number, returnEntries?: boolean, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getSingleInvoice(id, returnEntries, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} [updateInvoiceRequest] The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public updateInvoice(id: number, updateInvoiceRequest?: UpdateInvoiceRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).updateInvoice(id, updateInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PayoutRequestsApi - axios parameter creator
 * @export
 */
export const PayoutRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new payout request
         * @param {PayoutRequestRequest} [payoutRequestRequest] New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest: async (payoutRequestRequest?: PayoutRequestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payoutrequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all payout requests given the filter parameters
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests: async (requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payoutrequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requestedById !== undefined) {
                for (const [key, value] of Object.entries(requestedById)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (approvedById !== undefined) {
                for (const [key, value] of Object.entries(approvedById)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSinglePayoutRequest', 'id', id)
            const localVarPath = `/payoutrequests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} [payoutRequestStatusRequest] New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus: async (id: number, payoutRequestStatusRequest?: PayoutRequestStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setPayoutRequestStatus', 'id', id)
            const localVarPath = `/payoutrequests/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutRequestStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayoutRequestsApi - functional programming interface
 * @export
 */
export const PayoutRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayoutRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new payout request
         * @param {PayoutRequestRequest} [payoutRequestRequest] New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayoutRequest(payoutRequestRequest?: PayoutRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayoutRequest(payoutRequestRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PayoutRequestsApi.createPayoutRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all payout requests given the filter parameters
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPayoutRequests(requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBasePayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PayoutRequestsApi.getAllPayoutRequests']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSinglePayoutRequest(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSinglePayoutRequest(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PayoutRequestsApi.getSinglePayoutRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} [payoutRequestStatusRequest] New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPayoutRequestStatus(id: number, payoutRequestStatusRequest?: PayoutRequestStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPayoutRequestStatus(id, payoutRequestStatusRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PayoutRequestsApi.setPayoutRequestStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PayoutRequestsApi - factory interface
 * @export
 */
export const PayoutRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayoutRequestsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new payout request
         * @param {PayoutRequestRequest} [payoutRequestRequest] New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest(payoutRequestRequest?: PayoutRequestRequest, options?: any): AxiosPromise<PayoutRequestResponse> {
            return localVarFp.createPayoutRequest(payoutRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all payout requests given the filter parameters
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests(requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBasePayoutRequestResponse> {
            return localVarFp.getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest(id: number, options?: any): AxiosPromise<PayoutRequestResponse> {
            return localVarFp.getSinglePayoutRequest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} [payoutRequestStatusRequest] New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus(id: number, payoutRequestStatusRequest?: PayoutRequestStatusRequest, options?: any): AxiosPromise<PayoutRequestResponse> {
            return localVarFp.setPayoutRequestStatus(id, payoutRequestStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayoutRequestsApi - object-oriented interface
 * @export
 * @class PayoutRequestsApi
 * @extends {BaseAPI}
 */
export class PayoutRequestsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new payout request
     * @param {PayoutRequestRequest} [payoutRequestRequest] New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public createPayoutRequest(payoutRequestRequest?: PayoutRequestRequest, options?: RawAxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).createPayoutRequest(payoutRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all payout requests given the filter parameters
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public getAllPayoutRequests(requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public getSinglePayoutRequest(id: number, options?: RawAxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).getSinglePayoutRequest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} [payoutRequestStatusRequest] New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    public setPayoutRequestStatus(id: number, payoutRequestStatusRequest?: PayoutRequestStatusRequest, options?: RawAxiosRequestConfig) {
        return PayoutRequestsApiFp(this.configuration).setPayoutRequestStatus(id, payoutRequestStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PointofsaleApi - axios parameter creator
 * @export
 */
export const PointofsaleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} [createPointOfSaleRequest] The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale: async (createPointOfSaleRequest?: CreatePointOfSaleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pointsofsale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPointOfSaleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAllPointOfSaleContainers', 'id', id)
            const localVarPath = `/pointsofsale/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAllPointOfSaleProducts', 'id', id)
            const localVarPath = `/pointsofsale/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pointsofsale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSinglePointOfSale', 'id', id)
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a Point of Sale transactions
         * @param {number} id The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransactions', 'id', id)
            const localVarPath = `/pointsofsale/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} [updatePointOfSaleRequest]    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale: async (id: number, updatePointOfSaleRequest?: UpdatePointOfSaleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePointOfSale', 'id', id)
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePointOfSaleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PointofsaleApi - functional programming interface
 * @export
 */
export const PointofsaleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PointofsaleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} [createPointOfSaleRequest] The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPointOfSale(createPointOfSaleRequest?: CreatePointOfSaleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPointOfSale(createPointOfSaleRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.createPointOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPointOfSaleContainers(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.getAllPointOfSaleContainers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPointOfSaleProducts(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.getAllPointOfSaleProducts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPointsOfSale(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPointOfSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPointsOfSale(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.getAllPointsOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSinglePointOfSale(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSinglePointOfSale(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.getSinglePointOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a Point of Sale transactions
         * @param {number} id The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.getTransactions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} [updatePointOfSaleRequest]    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePointOfSale(id: number, updatePointOfSaleRequest?: UpdatePointOfSaleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePointOfSale(id, updatePointOfSaleRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PointofsaleApi.updatePointOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PointofsaleApi - factory interface
 * @export
 */
export const PointofsaleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PointofsaleApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} [createPointOfSaleRequest] The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale(createPointOfSaleRequest?: CreatePointOfSaleRequest, options?: any): AxiosPromise<PointOfSaleWithContainersResponse> {
            return localVarFp.createPointOfSale(createPointOfSaleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getAllPointOfSaleContainers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse> {
            return localVarFp.getAllPointOfSaleProducts(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedPointOfSaleResponse> {
            return localVarFp.getAllPointsOfSale(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale(id: number, options?: any): AxiosPromise<PointOfSaleWithContainersResponse> {
            return localVarFp.getSinglePointOfSale(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a Point of Sale transactions
         * @param {number} id The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse> {
            return localVarFp.getTransactions(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} [updatePointOfSaleRequest]    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale(id: number, updatePointOfSaleRequest?: UpdatePointOfSaleRequest, options?: any): AxiosPromise<PointOfSaleWithContainersResponse> {
            return localVarFp.updatePointOfSale(id, updatePointOfSaleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PointofsaleApi - object-oriented interface
 * @export
 * @class PointofsaleApi
 * @extends {BaseAPI}
 */
export class PointofsaleApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} [createPointOfSaleRequest] The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public createPointOfSale(createPointOfSaleRequest?: CreatePointOfSaleRequest, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).createPointOfSale(createPointOfSaleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getAllPointOfSaleContainers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getAllPointOfSaleProducts(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getAllPointsOfSale(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getAllPointsOfSale(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getSinglePointOfSale(id: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getSinglePointOfSale(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a Point of Sale transactions
     * @param {number} id The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public getTransactions(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).getTransactions(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} [updatePointOfSaleRequest]    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    public updatePointOfSale(id: number, updatePointOfSaleRequest?: UpdatePointOfSaleRequest, options?: RawAxiosRequestConfig) {
        return PointofsaleApiFp(this.configuration).updatePointOfSale(id, updatePointOfSaleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductCategoriesApi - axios parameter creator
 * @export
 */
export const ProductCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post a new productCategory.
         * @param {ProductCategoryRequest} [productCategoryRequest] The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory: async (productCategoryRequest?: ProductCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/productcategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing productcategories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/productcategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleProductCategory', 'id', id)
            const localVarPath = `/productcategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} [productCategoryRequest] The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory: async (id: number, productCategoryRequest?: ProductCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProductCategory', 'id', id)
            const localVarPath = `/productcategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductCategoriesApi - functional programming interface
 * @export
 */
export const ProductCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post a new productCategory.
         * @param {ProductCategoryRequest} [productCategoryRequest] The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductCategory(productCategoryRequest?: ProductCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProductCategory(productCategoryRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductCategoriesApi.createProductCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing productcategories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProductCategories(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProductCategories(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductCategoriesApi.getAllProductCategories']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleProductCategory(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleProductCategory(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductCategoriesApi.getSingleProductCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} [productCategoryRequest] The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductCategory(id: number, productCategoryRequest?: ProductCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductCategory(id, productCategoryRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductCategoriesApi.updateProductCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProductCategoriesApi - factory interface
 * @export
 */
export const ProductCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductCategoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Post a new productCategory.
         * @param {ProductCategoryRequest} [productCategoryRequest] The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory(productCategoryRequest?: ProductCategoryRequest, options?: any): AxiosPromise<ProductCategoryResponse> {
            return localVarFp.createProductCategory(productCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing productcategories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductCategoryResponse> {
            return localVarFp.getAllProductCategories(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory(id: number, options?: any): AxiosPromise<ProductCategoryResponse> {
            return localVarFp.getSingleProductCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} [productCategoryRequest] The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory(id: number, productCategoryRequest?: ProductCategoryRequest, options?: any): AxiosPromise<ProductCategoryResponse> {
            return localVarFp.updateProductCategory(id, productCategoryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductCategoriesApi - object-oriented interface
 * @export
 * @class ProductCategoriesApi
 * @extends {BaseAPI}
 */
export class ProductCategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Post a new productCategory.
     * @param {ProductCategoryRequest} [productCategoryRequest] The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public createProductCategory(productCategoryRequest?: ProductCategoryRequest, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).createProductCategory(productCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing productcategories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public getAllProductCategories(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).getAllProductCategories(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public getSingleProductCategory(id: number, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).getSingleProductCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} [productCategoryRequest] The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public updateProductCategory(id: number, productCategoryRequest?: ProductCategoryRequest, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).updateProductCategory(id, productCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new product.
         * @param {CreateProductRequest} [createProductRequest] The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (createProductRequest?: CreateProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} [updateProductRequest] The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (id: number, updateProductRequest?: UpdateProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProductImage', 'id', id)
            const localVarPath = `/products/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new product.
         * @param {CreateProductRequest} [createProductRequest] The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(createProductRequest?: CreateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(createProductRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.createProduct']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProducts(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProducts(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.getAllProducts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleProduct(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleProduct(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.getSingleProduct']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} [updateProductRequest] The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(id: number, updateProductRequest?: UpdateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(id, updateProductRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.updateProduct']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductImage(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductImage(id, file, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProductsApi.updateProductImage']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new product.
         * @param {CreateProductRequest} [createProductRequest] The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(createProductRequest?: CreateProductRequest, options?: any): AxiosPromise<ProductResponse> {
            return localVarFp.createProduct(createProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse> {
            return localVarFp.getAllProducts(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct(id: number, options?: any): AxiosPromise<ProductResponse> {
            return localVarFp.getSingleProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} [updateProductRequest] The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: number, updateProductRequest?: UpdateProductRequest, options?: any): AxiosPromise<ProductResponse> {
            return localVarFp.updateProduct(id, updateProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage(id: number, file?: File, options?: any): AxiosPromise<void> {
            return localVarFp.updateProductImage(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new product.
     * @param {CreateProductRequest} [createProductRequest] The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProduct(createProductRequest?: CreateProductRequest, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).createProduct(createProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getAllProducts(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getAllProducts(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getSingleProduct(id: number, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getSingleProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} [updateProductRequest] The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(id: number, updateProductRequest?: UpdateProductRequest, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).updateProduct(id, updateProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProductImage(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).updateProductImage(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RbacApi - axios parameter creator
 * @export
 */
export const RbacApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rbac/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RbacApi - functional programming interface
 * @export
 */
export const RbacApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RbacApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRoles(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacApi.getAllRoles']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RbacApi - factory interface
 * @export
 */
export const RbacApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RbacApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options?: any): AxiosPromise<Array<RoleResponse>> {
            return localVarFp.getAllRoles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RbacApi - object-oriented interface
 * @export
 * @class RbacApi
 * @extends {BaseAPI}
 */
export class RbacApi extends BaseAPI {
    /**
     * 
     * @summary Returns all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    public getAllRoles(options?: RawAxiosRequestConfig) {
        return RbacApiFp(this.configuration).getAllRoles(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RootApi - axios parameter creator
 * @export
 */
export const RootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Ping the backend to check whether everything is working correctly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RootApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Ping the backend to check whether everything is working correctly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RootApi.ping']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RootApi - factory interface
 * @export
 */
export const RootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RootApiFp(configuration)
    return {
        /**
         * 
         * @summary Ping the backend to check whether everything is working correctly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export class RootApi extends BaseAPI {
    /**
     * 
     * @summary Ping the backend to check whether everything is working correctly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return RootApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Start the stripe deposit flow
         * @param {StripeRequest} [stripeRequest] The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: async (stripeRequest?: StripeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stripeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Start the stripe deposit flow
         * @param {StripeRequest} [stripeRequest] The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deposit(stripeRequest?: StripeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deposit(stripeRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StripeApi.deposit']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * 
         * @summary Start the stripe deposit flow
         * @param {StripeRequest} [stripeRequest] The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(stripeRequest?: StripeRequest, options?: any): AxiosPromise<StripePaymentIntentResponse> {
            return localVarFp.deposit(stripeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * 
     * @summary Start the stripe deposit flow
     * @param {StripeRequest} [stripeRequest] The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public deposit(stripeRequest?: StripeRequest, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).deposit(stripeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestOperationsOfTheTestControllerApi - axios parameter creator
 * @export
 */
export const TestOperationsOfTheTestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test/helloworld`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestOperationsOfTheTestControllerApi - functional programming interface
 * @export
 */
export const TestOperationsOfTheTestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestOperationsOfTheTestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helloworld(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helloworld(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TestOperationsOfTheTestControllerApi.helloworld']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TestOperationsOfTheTestControllerApi - factory interface
 * @export
 */
export const TestOperationsOfTheTestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestOperationsOfTheTestControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld(options?: any): AxiosPromise<string> {
            return localVarFp.helloworld(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestOperationsOfTheTestControllerApi - object-oriented interface
 * @export
 * @class TestOperationsOfTheTestControllerApi
 * @extends {BaseAPI}
 */
export class TestOperationsOfTheTestControllerApi extends BaseAPI {
    /**
     * 
     * @summary Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestOperationsOfTheTestControllerApi
     */
    public helloworld(options?: RawAxiosRequestConfig) {
        return TestOperationsOfTheTestControllerApiFp(this.configuration).helloworld(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new transaction
         * @param {TransactionRequest} [transactionRequest] The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (transactionRequest?: TransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransaction', 'id', id)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions: async (fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (pointOfSaleId !== undefined) {
                localVarQueryParameter['pointOfSaleId'] = pointOfSaleId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (productRevision !== undefined) {
                localVarQueryParameter['productRevision'] = productRevision;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleTransaction', 'id', id)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} [transactionRequest] The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: async (id: number, transactionRequest?: TransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransaction', 'id', id)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} [transactionRequest] The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction: async (transactionRequest?: TransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new transaction
         * @param {TransactionRequest} [transactionRequest] The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(transactionRequest?: TransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransaction(transactionRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.createTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransaction(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransaction(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.deleteTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.getAllTransactions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleTransaction(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleTransaction(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.getSingleTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} [transactionRequest] The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction(id: number, transactionRequest?: TransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction(id, transactionRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.updateTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} [transactionRequest] The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateTransaction(transactionRequest?: TransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateTransaction(transactionRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.validateTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new transaction
         * @param {TransactionRequest} [transactionRequest] The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(transactionRequest?: TransactionRequest, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.createTransaction(transactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id: number, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.deleteTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse> {
            return localVarFp.getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction(id: number, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.getSingleTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} [transactionRequest] The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id: number, transactionRequest?: TransactionRequest, options?: any): AxiosPromise<TransactionResponse> {
            return localVarFp.updateTransaction(id, transactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} [transactionRequest] The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction(transactionRequest?: TransactionRequest, options?: any): AxiosPromise<boolean> {
            return localVarFp.validateTransaction(transactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new transaction
     * @param {TransactionRequest} [transactionRequest] The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransaction(transactionRequest?: TransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createTransaction(transactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransaction(id: number, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).deleteTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getSingleTransaction(id: number, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getSingleTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} [transactionRequest] The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransaction(id: number, transactionRequest?: TransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).updateTransaction(id, transactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} [transactionRequest] The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public validateTransaction(transactionRequest?: TransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).validateTransaction(transactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post a new transfer.
         * @param {TransferRequest} [transferRequest] The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: async (transferRequest?: TransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleTransfer', 'id', id)
            const localVarPath = `/transfers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post a new transfer.
         * @param {TransferRequest} [transferRequest] The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransfer(transferRequest?: TransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(transferRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransfersApi.createTransfer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransfers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransferResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTransfers(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransfersApi.getAllTransfers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleTransfer(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleTransfer(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransfersApi.getSingleTransfer']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         * 
         * @summary Post a new transfer.
         * @param {TransferRequest} [transferRequest] The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(transferRequest?: TransferRequest, options?: any): AxiosPromise<TransferResponse> {
            return localVarFp.createTransfer(transferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers(take?: number, skip?: number, options?: any): AxiosPromise<Array<TransferResponse>> {
            return localVarFp.getAllTransfers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer(id: number, options?: any): AxiosPromise<TransferResponse> {
            return localVarFp.getSingleTransfer(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI {
    /**
     * 
     * @summary Post a new transfer.
     * @param {TransferRequest} [transferRequest] The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public createTransfer(transferRequest?: TransferRequest, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).createTransfer(transferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getAllTransfers(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getAllTransfers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getSingleTransfer(id: number, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getSingleTransfer(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} [acceptTosRequest] \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos: async (acceptTosRequest?: AcceptTosRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/acceptTos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptTosRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authenticateAs', 'id', id)
            const localVarPath = `/users/{id}/authenticate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserRequest} [createUserRequest] The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest?: CreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserKey', 'id', id)
            const localVarPath = `/users/{id}/authenticator/key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserNfc', 'id', id)
            const localVarPath = `/users/{id}/authenticator/nfc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (ofAge !== undefined) {
                localVarQueryParameter['ofAge'] = ofAge;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType: async (userType: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userType' is not null or undefined
            assertParamExists('getAllUsersOfUserType', 'userType', userType)
            const localVarPath = `/users/usertype/{userType}`
                .replace(`{${"userType"}}`, encodeURIComponent(String(userType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIndividualUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganMembers', 'id', id)
            const localVarPath = `/users/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserAuthenticatable', 'id', id)
            const localVarPath = `/users/{id}/authenticate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserRoles', 'id', id)
            const localVarPath = `/users/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersContainers', 'id', id)
            const localVarPath = `/users/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all financial mutations of a user.
         * @param {number} id The id of the user to get the mutations from
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersFinancialMutations', 'id', id)
            const localVarPath = `/users/{id}/financialmutations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersPointsOfSale', 'id', id)
            const localVarPath = `/users/{id}/pointsofsale`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersProcessingDeposits', 'id', id)
            const localVarPath = `/users/{id}/deposits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts: async (id: number, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersProducts', 'id', id)
            const localVarPath = `/users/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an user\'s transactions (from, to or created)
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions: async (id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersTransactions', 'id', id)
            const localVarPath = `/users/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (productRevision !== undefined) {
                localVarQueryParameter['productRevision'] = productRevision;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactionsReport: async (id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersTransactionsReport', 'id', id)
            const localVarPath = `/users/{id}/transactions/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (exclusiveToId !== undefined) {
                localVarQueryParameter['exclusiveToId'] = exclusiveToId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an user\'s transfers
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers: async (id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersTransfers', 'id', id)
            const localVarPath = `/users/{id}/transfers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }

            if (id2 !== undefined) {
                localVarQueryParameter['id'] = id2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} updateUserRequest The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: number, updateUserRequest: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('updateUser', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserKey', 'id', id)
            const localVarPath = `/users/{id}/authenticator/key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} [updateLocalRequest]    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword: async (id: number, updateLocalRequest?: UpdateLocalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserLocalPassword', 'id', id)
            const localVarPath = `/users/{id}/authenticator/local`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLocalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} [updateNfcRequest]    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc: async (id: number, updateNfcRequest?: UpdateNfcRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserNfc', 'id', id)
            const localVarPath = `/users/{id}/authenticator/nfc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNfcRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} [updatePinRequest]    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin: async (id: number, updatePinRequest?: UpdatePinRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserPin', 'id', id)
            const localVarPath = `/users/{id}/authenticator/pin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waiveUserFines: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('waiveUserFines', 'id', id)
            const localVarPath = `/users/{id}/fines/waive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} [acceptTosRequest] \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptTos(acceptTosRequest?: AcceptTosRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptTos(acceptTosRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.acceptTos']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateAs(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateAs(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.authenticateAs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserRequest} [createUserRequest] The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest?: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.createUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.deleteUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserKey(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserKey(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.deleteUserKey']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserNfc(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserNfc(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.deleteUserNfc']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(take, skip, search, active, ofAge, id, type, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getAllUsers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsersOfUserType(userType, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getAllUsersOfUserType']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndividualUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndividualUser(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getIndividualUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganMembers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganMembers(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getOrganMembers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAuthenticatable(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAuthenticatable(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUserAuthenticatable']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoles(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoles(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUserRoles']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersContainers(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersContainers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all financial mutations of a user.
         * @param {number} id The id of the user to get the mutations from
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFinancialMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersFinancialMutations(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersFinancialMutations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPointOfSaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersPointsOfSale(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersPointsOfSale']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersProcessingDeposits(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersProcessingDeposits(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersProcessingDeposits']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersProducts(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersProducts(id, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersProducts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get an user\'s transactions (from, to or created)
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersTransactions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionReportResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersTransactionsReport']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get an user\'s transfers
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTransfers(id, take, skip, fromId, toId, id2, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.getUsersTransfers']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} updateUserRequest The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: number, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, updateUserRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.updateUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserKey(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserKey(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.updateUserKey']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} [updateLocalRequest]    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserLocalPassword(id: number, updateLocalRequest?: UpdateLocalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserLocalPassword(id, updateLocalRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.updateUserLocalPassword']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} [updateNfcRequest]    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserNfc(id: number, updateNfcRequest?: UpdateNfcRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserNfc(id, updateNfcRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.updateUserNfc']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} [updatePinRequest]    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPin(id: number, updatePinRequest?: UpdatePinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPin(id, updatePinRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.updateUserPin']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waiveUserFines(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.waiveUserFines(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.waiveUserFines']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} [acceptTosRequest] \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos(acceptTosRequest?: AcceptTosRequest, options?: any): AxiosPromise<string> {
            return localVarFp.acceptTos(acceptTosRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs(id: number, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.authenticateAs(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user
         * @param {CreateUserRequest} [createUserRequest] The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest?: CreateUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserNfc(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options?: any): AxiosPromise<PaginatedUserResponse> {
            return localVarFp.getAllUsers(take, skip, search, active, ofAge, id, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedUserResponse> {
            return localVarFp.getAllUsersOfUserType(userType, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser(id: number, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getIndividualUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedUserResponse> {
            return localVarFp.getOrganMembers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable(id: number, options?: any): AxiosPromise<Array<UserResponse>> {
            return localVarFp.getUserAuthenticatable(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(id: number, options?: any): AxiosPromise<Array<RoleResponse>> {
            return localVarFp.getUserRoles(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse> {
            return localVarFp.getUsersContainers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all financial mutations of a user.
         * @param {number} id The id of the user to get the mutations from
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedFinancialMutationResponse> {
            return localVarFp.getUsersFinancialMutations(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedPointOfSaleResponse> {
            return localVarFp.getUsersPointsOfSale(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits(id: number, options?: any): AxiosPromise<Array<RoleResponse>> {
            return localVarFp.getUsersProcessingDeposits(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse> {
            return localVarFp.getUsersProducts(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an user\'s transactions (from, to or created)
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse> {
            return localVarFp.getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: any): AxiosPromise<Array<TransactionReportResponse>> {
            return localVarFp.getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an user\'s transfers
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: any): AxiosPromise<PaginatedTransferResponse> {
            return localVarFp.getUsersTransfers(id, take, skip, fromId, toId, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} updateUserRequest The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, updateUserRequest: UpdateUserRequest, options?: any): AxiosPromise<UpdateUserRequest> {
            return localVarFp.updateUser(id, updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey(id: number, options?: any): AxiosPromise<UpdateKeyResponse> {
            return localVarFp.updateUserKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} [updateLocalRequest]    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword(id: number, updateLocalRequest?: UpdateLocalRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserLocalPassword(id, updateLocalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} [updateNfcRequest]    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc(id: number, updateNfcRequest?: UpdateNfcRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserNfc(id, updateNfcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} [updatePinRequest]    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin(id: number, updatePinRequest?: UpdatePinRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPin(id, updatePinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waiveUserFines(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.waiveUserFines(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} [acceptTosRequest] \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public acceptTos(acceptTosRequest?: AcceptTosRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).acceptTos(acceptTosRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public authenticateAs(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).authenticateAs(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user
     * @param {CreateUserRequest} [createUserRequest] The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(createUserRequest?: CreateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserKey(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserNfc(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserNfc(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getAllUsers(take, skip, search, active, ofAge, id, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getAllUsersOfUserType(userType, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getIndividualUser(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getIndividualUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an organs members
     * @param {number} id The id of the user
     * @param {number} [take] How many members the endpoint should return
     * @param {number} [skip] How many members should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOrganMembers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getOrganMembers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserAuthenticatable(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserAuthenticatable(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserRoles(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserRoles(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersContainers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all financial mutations of a user.
     * @param {number} id The id of the user to get the mutations from
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersFinancialMutations(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersPointsOfSale(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersProcessingDeposits(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersProcessingDeposits(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersProducts(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersProducts(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an user\'s transactions (from, to or created)
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an user\'s transfers
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTransfers(id, take, skip, fromId, toId, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} updateUserRequest The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: number, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(id, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserKey(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} [updateLocalRequest]    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserLocalPassword(id: number, updateLocalRequest?: UpdateLocalRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserLocalPassword(id, updateLocalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} [updateNfcRequest]    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserNfc(id: number, updateNfcRequest?: UpdateNfcRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserNfc(id, updateNfcRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} [updatePinRequest]    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPin(id: number, updatePinRequest?: UpdatePinRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPin(id, updatePinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Waive all given user\'s fines
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public waiveUserFines(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).waiveUserFines(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllUsersTypeEnum = {
    Member: 'MEMBER',
    Organ: 'ORGAN',
    Voucher: 'VOUCHER',
    LocalUser: 'LOCAL_USER',
    LocalAdmin: 'LOCAL_ADMIN',
    Invoice: 'INVOICE',
    AutomaticInvoice: 'AUTOMATIC_INVOICE'
} as const;
export type GetAllUsersTypeEnum = typeof GetAllUsersTypeEnum[keyof typeof GetAllUsersTypeEnum];


/**
 * VatGroupsApi - axios parameter creator
 * @export
 */
export const VatGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new VAT group
         * @param {VatGroupRequest} [vatGroupRequest] The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup: async (vatGroupRequest?: VatGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vatgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vatGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups: async (vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vatgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vatGroupId !== undefined) {
                localVarQueryParameter['vatGroupId'] = vatGroupId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (percentage !== undefined) {
                localVarQueryParameter['percentage'] = percentage;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleVatGroup', 'id', id)
            const localVarPath = `/vatgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts: async (year: number, period: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            assertParamExists('getVatDeclarationAmounts', 'year', year)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getVatDeclarationAmounts', 'period', period)
            const localVarPath = `/vatgroups/declaration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} [updateVatGroupRequest] The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup: async (id: number, updateVatGroupRequest?: UpdateVatGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVatGroup', 'id', id)
            const localVarPath = `/vatgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVatGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VatGroupsApi - functional programming interface
 * @export
 */
export const VatGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VatGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new VAT group
         * @param {VatGroupRequest} [vatGroupRequest] The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVatGroup(vatGroupRequest?: VatGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVatGroup(vatGroupRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VatGroupsApi.createVatGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVatGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VatGroupsApi.getAllVatGroups']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleVatGroup(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleVatGroup(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VatGroupsApi.getSingleVatGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVatDeclarationAmounts(year: number, period: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVatGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVatDeclarationAmounts(year, period, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VatGroupsApi.getVatDeclarationAmounts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} [updateVatGroupRequest] The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVatGroup(id: number, updateVatGroupRequest?: UpdateVatGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVatGroup(id, updateVatGroupRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VatGroupsApi.updateVatGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * VatGroupsApi - factory interface
 * @export
 */
export const VatGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VatGroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new VAT group
         * @param {VatGroupRequest} [vatGroupRequest] The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup(vatGroupRequest?: VatGroupRequest, options?: any): AxiosPromise<VatGroup> {
            return localVarFp.createVatGroup(vatGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedVatGroupResponse> {
            return localVarFp.getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup(id: number, options?: any): AxiosPromise<VatGroup> {
            return localVarFp.getSingleVatGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts(year: number, period: string, options?: any): AxiosPromise<PaginatedVatGroupResponse> {
            return localVarFp.getVatDeclarationAmounts(year, period, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} [updateVatGroupRequest] The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup(id: number, updateVatGroupRequest?: UpdateVatGroupRequest, options?: any): AxiosPromise<VatGroup> {
            return localVarFp.updateVatGroup(id, updateVatGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VatGroupsApi - object-oriented interface
 * @export
 * @class VatGroupsApi
 * @extends {BaseAPI}
 */
export class VatGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new VAT group
     * @param {VatGroupRequest} [vatGroupRequest] The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public createVatGroup(vatGroupRequest?: VatGroupRequest, options?: RawAxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).createVatGroup(vatGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public getSingleVatGroup(id: number, options?: RawAxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).getSingleVatGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public getVatDeclarationAmounts(year: number, period: string, options?: RawAxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).getVatDeclarationAmounts(year, period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} [updateVatGroupRequest] The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    public updateVatGroup(id: number, updateVatGroupRequest?: UpdateVatGroupRequest, options?: RawAxiosRequestConfig) {
        return VatGroupsApiFp(this.configuration).updateVatGroup(id, updateVatGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VouchergroupsApi - axios parameter creator
 * @export
 */
export const VouchergroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new voucher group
         * @param {VoucherGroupRequest} [voucherGroupRequest] The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVouchergroup: async (voucherGroupRequest?: VoucherGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vouchergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voucherGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVouchergroups: async (take?: number, skip?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vouchergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchergroupId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVouchergroupId', 'id', id)
            const localVarPath = `/vouchergroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} [voucherGroupRequest] The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherGroup: async (id: number, voucherGroupRequest?: VoucherGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVoucherGroup', 'id', id)
            const localVarPath = `/vouchergroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voucherGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VouchergroupsApi - functional programming interface
 * @export
 */
export const VouchergroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VouchergroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new voucher group
         * @param {VoucherGroupRequest} [voucherGroupRequest] The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVouchergroup(voucherGroupRequest?: VoucherGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVouchergroup(voucherGroupRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VouchergroupsApi.createVouchergroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVouchergroups(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVouchergroups(take, skip, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VouchergroupsApi.getAllVouchergroups']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVouchergroupId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVouchergroupId(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VouchergroupsApi.getVouchergroupId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} [voucherGroupRequest] The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVoucherGroup(id: number, voucherGroupRequest?: VoucherGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoucherGroup(id, voucherGroupRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VouchergroupsApi.updateVoucherGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * VouchergroupsApi - factory interface
 * @export
 */
export const VouchergroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VouchergroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new voucher group
         * @param {VoucherGroupRequest} [voucherGroupRequest] The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVouchergroup(voucherGroupRequest?: VoucherGroupRequest, options?: any): AxiosPromise<VoucherGroupResponse> {
            return localVarFp.createVouchergroup(voucherGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVouchergroups(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedVoucherGroupResponse> {
            return localVarFp.getAllVouchergroups(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchergroupId(id: number, options?: any): AxiosPromise<VoucherGroupResponse> {
            return localVarFp.getVouchergroupId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} [voucherGroupRequest] The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherGroup(id: number, voucherGroupRequest?: VoucherGroupRequest, options?: any): AxiosPromise<VoucherGroupResponse> {
            return localVarFp.updateVoucherGroup(id, voucherGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VouchergroupsApi - object-oriented interface
 * @export
 * @class VouchergroupsApi
 * @extends {BaseAPI}
 */
export class VouchergroupsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new voucher group
     * @param {VoucherGroupRequest} [voucherGroupRequest] The voucher group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public createVouchergroup(voucherGroupRequest?: VoucherGroupRequest, options?: RawAxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).createVouchergroup(voucherGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all existing voucher groups
     * @param {number} [take] How many voucher groups the endpoint should return
     * @param {number} [skip] How many voucher groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public getAllVouchergroups(take?: number, skip?: number, options?: RawAxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).getAllVouchergroups(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the requested voucher group
     * @param {number} id The id of the voucher group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public getVouchergroupId(id: number, options?: RawAxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).getVouchergroupId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the requested voucher group
     * @param {number} id The id of the voucher group which should be updated
     * @param {VoucherGroupRequest} [voucherGroupRequest] The updated voucher group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    public updateVoucherGroup(id: number, voucherGroupRequest?: VoucherGroupRequest, options?: RawAxiosRequestConfig) {
        return VouchergroupsApiFp(this.configuration).updateVoucherGroup(id, voucherGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



