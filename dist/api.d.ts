/**
 * sudosos-back-end
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import type { RequestArgs } from './base';
import { BaseAPI } from './base';
/**
 *
 * @export
 * @interface AcceptTosRequest
 */
export interface AcceptTosRequest {
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof AcceptTosRequest
     */
    'extensiveDataProcessing': boolean;
}
/**
 *
 * @export
 * @interface ActionResponse
 */
export interface ActionResponse {
    /**
     * The name of the action performed on the entity.
     * @type {string}
     * @memberof ActionResponse
     */
    'action'?: string;
    /**
     *
     * @type {Array<RelationResponse>}
     * @memberof ActionResponse
     */
    'relations'?: Array<RelationResponse>;
}
/**
 *
 * @export
 * @interface AssignedRole
 */
export interface AssignedRole {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof AssignedRole
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof AssignedRole
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof AssignedRole
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof AssignedRole
     */
    'user': User;
    /**
     * The name of the role
     * @type {string}
     * @memberof AssignedRole
     */
    'role': string;
}
/**
 *
 * @export
 * @interface AssignedRoleAllOf
 */
export interface AssignedRoleAllOf {
    /**
     *
     * @type {User}
     * @memberof AssignedRoleAllOf
     */
    'user': User;
    /**
     * The name of the role
     * @type {string}
     * @memberof AssignedRoleAllOf
     */
    'role': string;
}
/**
 *
 * @export
 * @interface AuthenticationEanRequest
 */
export interface AuthenticationEanRequest {
    /**
     *
     * @type {string}
     * @memberof AuthenticationEanRequest
     */
    'eanCode': string;
}
/**
 *
 * @export
 * @interface AuthenticationKeyRequest
 */
export interface AuthenticationKeyRequest {
    /**
     *
     * @type {number}
     * @memberof AuthenticationKeyRequest
     */
    'userId': number;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationKeyRequest
     */
    'key': string;
}
/**
 *
 * @export
 * @interface AuthenticationLDAPRequest
 */
export interface AuthenticationLDAPRequest {
    /**
     * The AD account name to authenticate
     * @type {string}
     * @memberof AuthenticationLDAPRequest
     */
    'accountName': string;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationLDAPRequest
     */
    'password': string;
}
/**
 *
 * @export
 * @interface AuthenticationLocalRequest
 */
export interface AuthenticationLocalRequest {
    /**
     * The users mail to authenticate
     * @type {string}
     * @memberof AuthenticationLocalRequest
     */
    'accountMail': string;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationLocalRequest
     */
    'password': string;
}
/**
 *
 * @export
 * @interface AuthenticationMethod
 */
export interface AuthenticationMethod {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof AuthenticationMethod
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof AuthenticationMethod
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof AuthenticationMethod
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof AuthenticationMethod
     */
    'user': User;
}
/**
 *
 * @export
 * @interface AuthenticationMethodAllOf
 */
export interface AuthenticationMethodAllOf {
    /**
     *
     * @type {User}
     * @memberof AuthenticationMethodAllOf
     */
    'user': User;
}
/**
 *
 * @export
 * @interface AuthenticationMockRequest
 */
export interface AuthenticationMockRequest {
    /**
     *
     * @type {number}
     * @memberof AuthenticationMockRequest
     */
    'userId': number;
    /**
     *
     * @type {string}
     * @memberof AuthenticationMockRequest
     */
    'nonce': string;
}
/**
 *
 * @export
 * @interface AuthenticationNfcRequest
 */
export interface AuthenticationNfcRequest {
    /**
     *
     * @type {string}
     * @memberof AuthenticationNfcRequest
     */
    'nfcCode': string;
}
/**
 *
 * @export
 * @interface AuthenticationPinRequest
 */
export interface AuthenticationPinRequest {
    /**
     *
     * @type {number}
     * @memberof AuthenticationPinRequest
     */
    'userId': number;
    /**
     *
     * @type {string}
     * @memberof AuthenticationPinRequest
     */
    'pin': string;
}
/**
 *
 * @export
 * @interface AuthenticationResetTokenRequest
 */
export interface AuthenticationResetTokenRequest {
    /**
     * The mail of the user
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'accountMail': string;
    /**
     * The reset token passcode
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'token': string;
    /**
     * The new password to set
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'password': string;
}
/**
 *
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     *
     * @type {UserResponse}
     * @memberof AuthenticationResponse
     */
    'user': UserResponse;
    /**
     *
     * @type {Array<string>}
     * @memberof AuthenticationResponse
     */
    'roles': Array<string>;
    /**
     *
     * @type {Array<UserResponse>}
     * @memberof AuthenticationResponse
     */
    'organs': Array<UserResponse>;
    /**
     * The JWT token that can be used as Bearer token for authentication.
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'token': string;
    /**
     * Whether the related user has accepted the Terms of Service  or is not required to.
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'acceptedToS': string;
}
/**
 *
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Balance
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Balance
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Balance
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof Balance
     */
    'user': User;
    /**
     *
     * @type {Dinero}
     * @memberof Balance
     */
    'amount': Dinero;
    /**
     *
     * @type {Transaction}
     * @memberof Balance
     */
    'lastTransaction'?: Transaction;
    /**
     *
     * @type {Transfer}
     * @memberof Balance
     */
    'lastTransfer'?: Transfer;
}
/**
 *
 * @export
 * @interface BalanceAllOf
 */
export interface BalanceAllOf {
    /**
     *
     * @type {User}
     * @memberof BalanceAllOf
     */
    'user': User;
    /**
     *
     * @type {Dinero}
     * @memberof BalanceAllOf
     */
    'amount': Dinero;
    /**
     *
     * @type {Transaction}
     * @memberof BalanceAllOf
     */
    'lastTransaction'?: Transaction;
    /**
     *
     * @type {Transfer}
     * @memberof BalanceAllOf
     */
    'lastTransfer'?: Transfer;
}
/**
 *
 * @export
 * @interface BalanceResponse
 */
export interface BalanceResponse {
    /**
     * ID of the user this balance belongs to
     * @type {number}
     * @memberof BalanceResponse
     */
    'id': number;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof BalanceResponse
     */
    'amount': DineroObjectResponse;
    /**
     * The ID of the last transaction that was present when the balance was cached
     * @type {number}
     * @memberof BalanceResponse
     */
    'lastTransactionId': number;
    /**
     * The ID of the last transfer that was present when the balance was cached
     * @type {number}
     * @memberof BalanceResponse
     */
    'lastTransferId': number;
}
/**
 *
 * @export
 * @interface Banner
 */
export interface Banner {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Banner
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Banner
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Banner
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Banner
     */
    'id': number;
    /**
     * Name/label of the banner.
     * @type {string}
     * @memberof Banner
     */
    'name'?: string;
    /**
     * How long the banner should be shown (in seconds).
     * @type {number}
     * @memberof Banner
     */
    'duration'?: number;
    /**
     * Whether the banner is active. Overrides start and end date.
     * @type {boolean}
     * @memberof Banner
     */
    'active'?: boolean;
    /**
     * The starting date from which the banner should be shown.
     * @type {string}
     * @memberof Banner
     */
    'startDate'?: string;
    /**
     * The end date from which the banner should no longer be shown.
     * @type {string}
     * @memberof Banner
     */
    'endDate'?: string;
}
/**
 *
 * @export
 * @interface BannerAllOf
 */
export interface BannerAllOf {
    /**
     * Name/label of the banner.
     * @type {string}
     * @memberof BannerAllOf
     */
    'name'?: string;
    /**
     * How long the banner should be shown (in seconds).
     * @type {number}
     * @memberof BannerAllOf
     */
    'duration'?: number;
    /**
     * Whether the banner is active. Overrides start and end date.
     * @type {boolean}
     * @memberof BannerAllOf
     */
    'active'?: boolean;
    /**
     * The starting date from which the banner should be shown.
     * @type {string}
     * @memberof BannerAllOf
     */
    'startDate'?: string;
    /**
     * The end date from which the banner should no longer be shown.
     * @type {string}
     * @memberof BannerAllOf
     */
    'endDate'?: string;
}
/**
 *
 * @export
 * @interface BannerImage
 */
export interface BannerImage {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BannerImage
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BannerImage
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BannerImage
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof BannerImage
     */
    'id': number;
    /**
     * The filename when the file is downloaded
     * @type {string}
     * @memberof BannerImage
     */
    'downloadName': string;
    /**
     * The location of the file, including filename in storage
     * @type {string}
     * @memberof BannerImage
     */
    'location': string;
    /**
     *
     * @type {User}
     * @memberof BannerImage
     */
    'createdBy': User;
}
/**
 *
 * @export
 * @interface BannerRequest
 */
export interface BannerRequest {
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerRequest
     */
    'name'?: string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerRequest
     */
    'duration'?: number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerRequest
     */
    'active'?: boolean;
    /**
     * The starting date from which the advertisement should be shown
     * @type {string}
     * @memberof BannerRequest
     */
    'startDate'?: string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerRequest
     */
    'endDate'?: string;
}
/**
 *
 * @export
 * @interface BannerResponse
 */
export interface BannerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BannerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BannerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BannerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BannerResponse
     */
    'version'?: number;
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerResponse
     */
    'name': string;
    /**
     * Location of the image
     * @type {string}
     * @memberof BannerResponse
     */
    'image': string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerResponse
     */
    'duration': number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerResponse
     */
    'active': boolean;
    /**
     * The starting date from which the banner should be shown
     * @type {string}
     * @memberof BannerResponse
     */
    'startDate': string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerResponse
     */
    'endDate': string;
}
/**
 *
 * @export
 * @interface BannerResponseAllOf
 */
export interface BannerResponseAllOf {
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerResponseAllOf
     */
    'name': string;
    /**
     * Location of the image
     * @type {string}
     * @memberof BannerResponseAllOf
     */
    'image': string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerResponseAllOf
     */
    'duration': number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerResponseAllOf
     */
    'active': boolean;
    /**
     * The starting date from which the banner should be shown
     * @type {string}
     * @memberof BannerResponseAllOf
     */
    'startDate': string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerResponseAllOf
     */
    'endDate': string;
}
/**
 *
 * @export
 * @interface BaseContainer
 */
export interface BaseContainer {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BaseContainer
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BaseContainer
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BaseContainer
     */
    'version'?: number;
    /**
     * The unique name of the container.
     * @type {string}
     * @memberof BaseContainer
     */
    'name': string;
}
/**
 *
 * @export
 * @interface BaseContainerAllOf
 */
export interface BaseContainerAllOf {
    /**
     * The unique name of the container.
     * @type {string}
     * @memberof BaseContainerAllOf
     */
    'name': string;
}
/**
 *
 * @export
 * @interface BaseContainerResponse
 */
export interface BaseContainerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof BaseContainerResponse
     */
    'public': boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'revision': number;
}
/**
 *
 * @export
 * @interface BaseContainerResponseAllOf
 */
export interface BaseContainerResponseAllOf {
    /**
     * The name of the container.
     * @type {string}
     * @memberof BaseContainerResponseAllOf
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof BaseContainerResponseAllOf
     */
    'public': boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof BaseContainerResponseAllOf
     */
    'revision': number;
}
/**
 *
 * @export
 * @interface BaseEntity
 */
export interface BaseEntity {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BaseEntity
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BaseEntity
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BaseEntity
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof BaseEntity
     */
    'id': number;
}
/**
 *
 * @export
 * @interface BaseEntityAllOf
 */
export interface BaseEntityAllOf {
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof BaseEntityAllOf
     */
    'id': number;
}
/**
 *
 * @export
 * @interface BaseEntityWithoutId
 */
export interface BaseEntityWithoutId {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BaseEntityWithoutId
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BaseEntityWithoutId
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BaseEntityWithoutId
     */
    'version'?: number;
}
/**
 *
 * @export
 * @interface BaseFile
 */
export interface BaseFile {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BaseFile
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BaseFile
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BaseFile
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof BaseFile
     */
    'id': number;
    /**
     * The filename when the file is downloaded
     * @type {string}
     * @memberof BaseFile
     */
    'downloadName': string;
    /**
     * The location of the file, including filename in storage
     * @type {string}
     * @memberof BaseFile
     */
    'location': string;
    /**
     *
     * @type {User}
     * @memberof BaseFile
     */
    'createdBy': User;
}
/**
 *
 * @export
 * @interface BaseFileAllOf
 */
export interface BaseFileAllOf {
    /**
     * The filename when the file is downloaded
     * @type {string}
     * @memberof BaseFileAllOf
     */
    'downloadName': string;
    /**
     * The location of the file, including filename in storage
     * @type {string}
     * @memberof BaseFileAllOf
     */
    'location': string;
    /**
     *
     * @type {User}
     * @memberof BaseFileAllOf
     */
    'createdBy': User;
}
/**
 *
 * @export
 * @interface BaseInvoiceResponse
 */
export interface BaseInvoiceResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseInvoiceResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseInvoiceResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BaseInvoiceResponse
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'description': string;
    /**
     *
     * @type {InvoiceStatusResponse}
     * @memberof BaseInvoiceResponse
     */
    'currentState': InvoiceStatusResponse;
    /**
     *
     * @type {TransferResponse}
     * @memberof BaseInvoiceResponse
     */
    'transfer'?: TransferResponse;
}
/**
 *
 * @export
 * @interface BaseInvoiceResponseAllOf
 */
export interface BaseInvoiceResponseAllOf {
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BaseInvoiceResponseAllOf
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof BaseInvoiceResponseAllOf
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponseAllOf
     */
    'description': string;
    /**
     *
     * @type {InvoiceStatusResponse}
     * @memberof BaseInvoiceResponseAllOf
     */
    'currentState': InvoiceStatusResponse;
    /**
     *
     * @type {TransferResponse}
     * @memberof BaseInvoiceResponseAllOf
     */
    'transfer'?: TransferResponse;
}
/**
 *
 * @export
 * @interface BasePayoutRequestResponse
 */
export interface BasePayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BasePayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BasePayoutRequestResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BasePayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BasePayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof BasePayoutRequestResponse
     */
    'amount': DineroObjectResponse;
    /**
     * The current status of the payout request
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'status'?: string;
}
/**
 *
 * @export
 * @interface BasePayoutRequestResponseAllOf
 */
export interface BasePayoutRequestResponseAllOf {
    /**
     * The current status of the payout request
     * @type {string}
     * @memberof BasePayoutRequestResponseAllOf
     */
    'status'?: string;
}
/**
 *
 * @export
 * @interface BasePointOfSale
 */
export interface BasePointOfSale {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BasePointOfSale
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BasePointOfSale
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BasePointOfSale
     */
    'version'?: number;
    /**
     * The unique name of the pointOfSale.
     * @type {string}
     * @memberof BasePointOfSale
     */
    'name': string;
}
/**
 *
 * @export
 * @interface BasePointOfSaleAllOf
 */
export interface BasePointOfSaleAllOf {
    /**
     * The unique name of the pointOfSale.
     * @type {string}
     * @memberof BasePointOfSaleAllOf
     */
    'name': string;
}
/**
 *
 * @export
 * @interface BasePointOfSaleResponse
 */
export interface BasePointOfSaleResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BasePointOfSaleResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BasePointOfSaleResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'name': string;
}
/**
 *
 * @export
 * @interface BasePointOfSaleResponseAllOf
 */
export interface BasePointOfSaleResponseAllOf {
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof BasePointOfSaleResponseAllOf
     */
    'name': string;
}
/**
 *
 * @export
 * @interface BaseProduct
 */
export interface BaseProduct {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BaseProduct
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BaseProduct
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BaseProduct
     */
    'version'?: number;
    /**
     * The unique name of the product.
     * @type {string}
     * @memberof BaseProduct
     */
    'name': string;
    /**
     *
     * @type {Dinero}
     * @memberof BaseProduct
     */
    'price': Dinero;
}
/**
 *
 * @export
 * @interface BaseProductAllOf
 */
export interface BaseProductAllOf {
    /**
     * The unique name of the product.
     * @type {string}
     * @memberof BaseProductAllOf
     */
    'name': string;
    /**
     *
     * @type {Dinero}
     * @memberof BaseProductAllOf
     */
    'price': Dinero;
}
/**
 *
 * @export
 * @interface BaseProductResponse
 */
export interface BaseProductResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseProductResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseProductResponse
     */
    'version'?: number;
    /**
     * The name of the product.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'name': string;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof BaseProductResponse
     */
    'priceInclVat': DineroObjectResponse;
    /**
     *
     * @type {BaseVatGroupResponse}
     * @memberof BaseProductResponse
     */
    'vat': BaseVatGroupResponse;
}
/**
 *
 * @export
 * @interface BaseProductResponseAllOf
 */
export interface BaseProductResponseAllOf {
    /**
     * The name of the product.
     * @type {string}
     * @memberof BaseProductResponseAllOf
     */
    'name': string;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof BaseProductResponseAllOf
     */
    'priceInclVat': DineroObjectResponse;
    /**
     *
     * @type {BaseVatGroupResponse}
     * @memberof BaseProductResponseAllOf
     */
    'vat': BaseVatGroupResponse;
}
/**
 *
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseResponse
     */
    'version'?: number;
}
/**
 *
 * @export
 * @interface BaseTransactionResponse
 */
export interface BaseTransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseTransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseTransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseTransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseTransactionResponse
     */
    'version'?: number;
    /**
     *
     * @type {UserResponse}
     * @memberof BaseTransactionResponse
     */
    'from': UserResponse;
    /**
     *
     * @type {UserResponse}
     * @memberof BaseTransactionResponse
     */
    'createdBy'?: UserResponse;
    /**
     *
     * @type {BasePointOfSaleResponse}
     * @memberof BaseTransactionResponse
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     *
     * @type {Dinero}
     * @memberof BaseTransactionResponse
     */
    'value': Dinero;
}
/**
 *
 * @export
 * @interface BaseTransactionResponseAllOf
 */
export interface BaseTransactionResponseAllOf {
    /**
     *
     * @type {UserResponse}
     * @memberof BaseTransactionResponseAllOf
     */
    'from': UserResponse;
    /**
     *
     * @type {UserResponse}
     * @memberof BaseTransactionResponseAllOf
     */
    'createdBy'?: UserResponse;
    /**
     *
     * @type {BasePointOfSaleResponse}
     * @memberof BaseTransactionResponseAllOf
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     *
     * @type {Dinero}
     * @memberof BaseTransactionResponseAllOf
     */
    'value': Dinero;
}
/**
 *
 * @export
 * @interface BaseUserResponse
 */
export interface BaseUserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseUserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseUserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof BaseUserResponse
     */
    'lastName': string;
}
/**
 *
 * @export
 * @interface BaseUserResponseAllOf
 */
export interface BaseUserResponseAllOf {
    /**
     * The name of the user.
     * @type {string}
     * @memberof BaseUserResponseAllOf
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof BaseUserResponseAllOf
     */
    'lastName': string;
}
/**
 *
 * @export
 * @interface BaseVatGroupResponse
 */
export interface BaseVatGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseVatGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseVatGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'version'?: number;
    /**
     * Percentage of VAT
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'percentage': number;
    /**
     * Whether VAT should be hidden
     * @type {boolean}
     * @memberof BaseVatGroupResponse
     */
    'hidden': boolean;
}
/**
 *
 * @export
 * @interface BaseVatGroupResponseAllOf
 */
export interface BaseVatGroupResponseAllOf {
    /**
     * Percentage of VAT
     * @type {number}
     * @memberof BaseVatGroupResponseAllOf
     */
    'percentage': number;
    /**
     * Whether VAT should be hidden
     * @type {boolean}
     * @memberof BaseVatGroupResponseAllOf
     */
    'hidden': boolean;
}
/**
 *
 * @export
 * @interface BoilerPayoutRequestResponse
 */
export interface BoilerPayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BoilerPayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BoilerPayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BoilerPayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BoilerPayoutRequestResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'amount': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface BoilerPayoutRequestResponseAllOf
 */
export interface BoilerPayoutRequestResponseAllOf {
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponseAllOf
     */
    'requestedBy': BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponseAllOf
     */
    'approvedBy'?: BaseUserResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof BoilerPayoutRequestResponseAllOf
     */
    'amount': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface BorrelkaartGroup
 */
export interface BorrelkaartGroup {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof BorrelkaartGroup
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof BorrelkaartGroup
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof BorrelkaartGroup
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof BorrelkaartGroup
     */
    'id': number;
    /**
     * Name of the group.
     * @type {string}
     * @memberof BorrelkaartGroup
     */
    'name': string;
    /**
     * Date after which the included cards are active.
     * @type {string}
     * @memberof BorrelkaartGroup
     */
    'activeStartDate': string;
    /**
     * Date after which cards are no longer active.
     * @type {string}
     * @memberof BorrelkaartGroup
     */
    'activeEndDate'?: string;
    /**
     *
     * @type {Array<User>}
     * @memberof BorrelkaartGroup
     */
    'borrelkaarten': Array<User>;
}
/**
 *
 * @export
 * @interface BorrelkaartGroupAllOf
 */
export interface BorrelkaartGroupAllOf {
    /**
     * Name of the group.
     * @type {string}
     * @memberof BorrelkaartGroupAllOf
     */
    'name': string;
    /**
     * Date after which the included cards are active.
     * @type {string}
     * @memberof BorrelkaartGroupAllOf
     */
    'activeStartDate': string;
    /**
     * Date after which cards are no longer active.
     * @type {string}
     * @memberof BorrelkaartGroupAllOf
     */
    'activeEndDate'?: string;
    /**
     *
     * @type {Array<User>}
     * @memberof BorrelkaartGroupAllOf
     */
    'borrelkaarten': Array<User>;
}
/**
 *
 * @export
 * @interface BorrelkaartGroupRequest
 */
export interface BorrelkaartGroupRequest {
    /**
     * Name of the group
     * @type {string}
     * @memberof BorrelkaartGroupRequest
     */
    'name': string;
    /**
     * Date from which the included cards are active
     * @type {string}
     * @memberof BorrelkaartGroupRequest
     */
    'activeStartDate': string;
    /**
     * Date from which cards are no longer active
     * @type {string}
     * @memberof BorrelkaartGroupRequest
     */
    'activeEndDate': string;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof BorrelkaartGroupRequest
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the borrelkaart group
     * @type {number}
     * @memberof BorrelkaartGroupRequest
     */
    'amount': number;
}
/**
 *
 * @export
 * @interface BorrelkaartGroupResponse
 */
export interface BorrelkaartGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BorrelkaartGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BorrelkaartGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BorrelkaartGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BorrelkaartGroupResponse
     */
    'version'?: number;
    /**
     * Name of the borrelkaart group
     * @type {string}
     * @memberof BorrelkaartGroupResponse
     */
    'name': string;
    /**
     * Start date of the borrelkaart group
     * @type {string}
     * @memberof BorrelkaartGroupResponse
     */
    'activeStartDate'?: string;
    /**
     * End date of the borrelkaart group
     * @type {string}
     * @memberof BorrelkaartGroupResponse
     */
    'activeEndDate': string;
    /**
     *
     * @type {Array<UserResponse>}
     * @memberof BorrelkaartGroupResponse
     */
    'users': Array<UserResponse>;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof BorrelkaartGroupResponse
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the borrelkaart group
     * @type {number}
     * @memberof BorrelkaartGroupResponse
     */
    'amount': number;
}
/**
 *
 * @export
 * @interface BorrelkaartGroupResponseAllOf
 */
export interface BorrelkaartGroupResponseAllOf {
    /**
     * Name of the borrelkaart group
     * @type {string}
     * @memberof BorrelkaartGroupResponseAllOf
     */
    'name': string;
    /**
     * Start date of the borrelkaart group
     * @type {string}
     * @memberof BorrelkaartGroupResponseAllOf
     */
    'activeStartDate'?: string;
    /**
     * End date of the borrelkaart group
     * @type {string}
     * @memberof BorrelkaartGroupResponseAllOf
     */
    'activeEndDate': string;
    /**
     *
     * @type {Array<UserResponse>}
     * @memberof BorrelkaartGroupResponseAllOf
     */
    'users': Array<UserResponse>;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof BorrelkaartGroupResponseAllOf
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the borrelkaart group
     * @type {number}
     * @memberof BorrelkaartGroupResponseAllOf
     */
    'amount': number;
}
/**
 *
 * @export
 * @interface Container
 */
export interface Container {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Container
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Container
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Container
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Container
     */
    'id': number;
    /**
     * The current revision of the container. Can be null if no revision exists.
     * @type {number}
     * @memberof Container
     */
    'currentRevision'?: number;
    /**
     *
     * @type {User}
     * @memberof Container
     */
    'owner': User;
    /**
     * Whether the container can be added to pointOfSales by everyone.
     * @type {boolean}
     * @memberof Container
     */
    'public'?: boolean;
}
/**
 *
 * @export
 * @interface ContainerAllOf
 */
export interface ContainerAllOf {
    /**
     * The current revision of the container. Can be null if no revision exists.
     * @type {number}
     * @memberof ContainerAllOf
     */
    'currentRevision'?: number;
    /**
     *
     * @type {User}
     * @memberof ContainerAllOf
     */
    'owner': User;
    /**
     * Whether the container can be added to pointOfSales by everyone.
     * @type {boolean}
     * @memberof ContainerAllOf
     */
    'public'?: boolean;
}
/**
 *
 * @export
 * @interface ContainerResponse
 */
export interface ContainerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ContainerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ContainerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ContainerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ContainerResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof ContainerResponse
     */
    'public': boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof ContainerResponse
     */
    'revision': number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof ContainerResponse
     */
    'owner': BaseUserResponse;
}
/**
 *
 * @export
 * @interface ContainerResponseAllOf
 */
export interface ContainerResponseAllOf {
    /**
     *
     * @type {BaseUserResponse}
     * @memberof ContainerResponseAllOf
     */
    'owner': BaseUserResponse;
}
/**
 *
 * @export
 * @interface ContainerRevision
 */
export interface ContainerRevision {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof ContainerRevision
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof ContainerRevision
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof ContainerRevision
     */
    'version'?: number;
    /**
     * The unique name of the container.
     * @type {string}
     * @memberof ContainerRevision
     */
    'name': string;
    /**
     *
     * @type {Container}
     * @memberof ContainerRevision
     */
    'container': Container;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof ContainerRevision
     */
    'revision': number;
    /**
     *
     * @type {Array<ProductRevision>}
     * @memberof ContainerRevision
     */
    'products': Array<ProductRevision>;
}
/**
 *
 * @export
 * @interface ContainerRevisionAllOf
 */
export interface ContainerRevisionAllOf {
    /**
     *
     * @type {Container}
     * @memberof ContainerRevisionAllOf
     */
    'container': Container;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof ContainerRevisionAllOf
     */
    'revision': number;
    /**
     *
     * @type {Array<ProductRevision>}
     * @memberof ContainerRevisionAllOf
     */
    'products': Array<ProductRevision>;
}
/**
 *
 * @export
 * @interface ContainerWithProductsResponse
 */
export interface ContainerWithProductsResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof ContainerWithProductsResponse
     */
    'public': boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'revision': number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof ContainerWithProductsResponse
     */
    'owner': BaseUserResponse;
    /**
     *
     * @type {Array<ProductResponse>}
     * @memberof ContainerWithProductsResponse
     */
    'products': Array<ProductResponse>;
}
/**
 *
 * @export
 * @interface ContainerWithProductsResponseAllOf
 */
export interface ContainerWithProductsResponseAllOf {
    /**
     *
     * @type {Array<ProductResponse>}
     * @memberof ContainerWithProductsResponseAllOf
     */
    'products': Array<ProductResponse>;
}
/**
 *
 * @export
 * @interface CreateContainerRequest
 */
export interface CreateContainerRequest {
    /**
     * Name of the container
     * @type {string}
     * @memberof CreateContainerRequest
     */
    'name': string;
    /**
     *
     * @type {Array<number>}
     * @memberof CreateContainerRequest
     */
    'products': Array<number>;
    /**
     * Whether the container is public or not
     * @type {boolean}
     * @memberof CreateContainerRequest
     */
    'public': boolean;
    /**
     * Id of the user who will own the container, if undefined it will    default to the token ID.
     * @type {number}
     * @memberof CreateContainerRequest
     */
    'ownerId'?: number;
}
/**
 *
 * @export
 * @interface CreateInvoiceRequest
 */
export interface CreateInvoiceRequest {
    /**
     * The recipient of the Invoice.
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'forId': number;
    /**
     * The creator of the Invoice, defaults to the ID of the requester.
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'byId'?: number;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'addressee': string;
    /**
     * The description of the invoice.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'description': string;
    /**
     *
     * @type {Array<InvoiceEntryRequest>}
     * @memberof CreateInvoiceRequest
     */
    'customEntries'?: Array<InvoiceEntryRequest>;
    /**
     *
     * @type {Array<number>}
     * @memberof CreateInvoiceRequest
     */
    'transactionIDs'?: Array<number>;
    /**
     * For creating an Invoice for all transactions from a specific date.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'fromDate'?: string;
    /**
     * If the invoice is an credit Invoice
     * @type {boolean}
     * @memberof CreateInvoiceRequest
     */
    'isCreditInvoice': boolean;
}
/**
 *
 * @export
 * @interface CreatePointOfSaleRequest
 */
export interface CreatePointOfSaleRequest {
    /**
     * Name of the POS
     * @type {string}
     * @memberof CreatePointOfSaleRequest
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof CreatePointOfSaleRequest
     */
    'useAuthentication': boolean;
    /**
     *
     * @type {Array<number>}
     * @memberof CreatePointOfSaleRequest
     */
    'containers'?: Array<number>;
    /**
     * ID of the user who will own the POS, if undefined it will    default to the token ID.
     * @type {number}
     * @memberof CreatePointOfSaleRequest
     */
    'ownerId'?: number;
}
/**
 *
 * @export
 * @interface CreateProductRequest
 */
export interface CreateProductRequest {
    /**
     * Name of the product
     * @type {string}
     * @memberof CreateProductRequest
     */
    'name': string;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof CreateProductRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * VAT group ID of the product
     * @type {number}
     * @memberof CreateProductRequest
     */
    'vat': number;
    /**
     * Category of the product
     * @type {number}
     * @memberof CreateProductRequest
     */
    'category': number;
    /**
     * Alcohol percentage of the product in 2 decimals
     * @type {number}
     * @memberof CreateProductRequest
     */
    'alcoholPercentage': number;
    /**
     * ID of the owner
     * @type {number}
     * @memberof CreateProductRequest
     */
    'ownerId': number;
}
/**
 *
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'firstName': string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'lastName'?: string;
    /**
     *
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'active'?: boolean;
    /**
     *
     * @type {number}
     * @memberof CreateUserRequest
     */
    'type': number;
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email'?: string;
}
/**
 *
 * @export
 * @interface Dinero
 */
export interface Dinero {
    /**
     * The amount of money as integer in the given precision.
     * @type {number}
     * @memberof Dinero
     */
    'amount': number;
    /**
     * The precision of the amount, in decimal places.
     * @type {number}
     * @memberof Dinero
     */
    'precision': number;
    /**
     * The ISO 4217 currency code.
     * @type {string}
     * @memberof Dinero
     */
    'currency': string;
}
/**
 *
 * @export
 * @interface DineroObject
 */
export interface DineroObject {
    /**
     * amount
     * @type {number}
     * @memberof DineroObject
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObject
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObject
     */
    'precision': number;
}
/**
 *
 * @export
 * @interface DineroObjectRequest
 */
export interface DineroObjectRequest {
    /**
     * amount
     * @type {number}
     * @memberof DineroObjectRequest
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObjectRequest
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObjectRequest
     */
    'precision': number;
}
/**
 *
 * @export
 * @interface DineroObjectResponse
 */
export interface DineroObjectResponse {
    /**
     * amount
     * @type {number}
     * @memberof DineroObjectResponse
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObjectResponse
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObjectResponse
     */
    'precision': number;
}
/**
 *
 * @export
 * @interface EanAuthenticator
 */
export interface EanAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof EanAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof EanAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof EanAuthenticator
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof EanAuthenticator
     */
    'user': User;
    /**
     * The EAN code
     * @type {string}
     * @memberof EanAuthenticator
     */
    'eanCode': string;
}
/**
 *
 * @export
 * @interface EanAuthenticatorAllOf
 */
export interface EanAuthenticatorAllOf {
    /**
     * The EAN code
     * @type {string}
     * @memberof EanAuthenticatorAllOf
     */
    'eanCode': string;
}
/**
 *
 * @export
 * @interface EntityResponse
 */
export interface EntityResponse {
    /**
     * The name of the entity for which the permissions are.
     * @type {string}
     * @memberof EntityResponse
     */
    'entity'?: string;
    /**
     *
     * @type {Array<ActionResponse>}
     * @memberof EntityResponse
     */
    'actions'?: Array<ActionResponse>;
}
/**
 *
 * @export
 * @interface GEWISAuthenticationPinRequest
 */
export interface GEWISAuthenticationPinRequest {
    /**
     *
     * @type {number}
     * @memberof GEWISAuthenticationPinRequest
     */
    'gewisId': number;
    /**
     *
     * @type {string}
     * @memberof GEWISAuthenticationPinRequest
     */
    'pin': string;
}
/**
 *
 * @export
 * @interface GewisUser
 */
export interface GewisUser {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof GewisUser
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof GewisUser
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof GewisUser
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof GewisUser
     */
    'id': number;
    /**
     *
     * @type {User}
     * @memberof GewisUser
     */
    'user': User;
    /**
     * The id of the member.
     * @type {number}
     * @memberof GewisUser
     */
    'gewisId': number;
}
/**
 *
 * @export
 * @interface GewisUserAllOf
 */
export interface GewisUserAllOf {
    /**
     *
     * @type {User}
     * @memberof GewisUserAllOf
     */
    'user': User;
    /**
     * The id of the member.
     * @type {number}
     * @memberof GewisUserAllOf
     */
    'gewisId': number;
}
/**
 *
 * @export
 * @interface GewisUserResponse
 */
export interface GewisUserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof GewisUserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof GewisUserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'lastName': string;
    /**
     * Whether the user activated
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'active': boolean;
    /**
     * Whether the user is deleted
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'deleted': boolean;
    /**
     * The type of user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'type': string;
    /**
     * If local user, the e-mail of the user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'email'?: string;
    /**
     * Whether this user has accepted the TOS
     * @type {string}
     * @memberof GewisUserResponse
     */
    'acceptedToS'?: string;
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'extensiveDataProcessing'?: boolean;
    /**
     * Whether someone is old enough to drink beer
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'ofAge'?: boolean;
    /**
     * The m-Number of the user
     * @type {number}
     * @memberof GewisUserResponse
     */
    'gewisId'?: number;
}
/**
 *
 * @export
 * @interface GewisUserResponseAllOf
 */
export interface GewisUserResponseAllOf {
    /**
     * The m-Number of the user
     * @type {number}
     * @memberof GewisUserResponseAllOf
     */
    'gewisId'?: number;
}
/**
 *
 * @export
 * @interface GewiswebAuthenticationRequest
 */
export interface GewiswebAuthenticationRequest {
    /**
     * The gewisweb JWT token.
     * @type {string}
     * @memberof GewiswebAuthenticationRequest
     */
    'token': string;
    /**
     * The nonce used in the newly signed JWT token.
     * @type {string}
     * @memberof GewiswebAuthenticationRequest
     */
    'nonce': string;
}
/**
 *
 * @export
 * @interface HashBasedAuthenticationMethod
 */
export interface HashBasedAuthenticationMethod {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof HashBasedAuthenticationMethod
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof HashBasedAuthenticationMethod
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof HashBasedAuthenticationMethod
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof HashBasedAuthenticationMethod
     */
    'user': User;
    /**
     * The hash of the authentication
     * @type {string}
     * @memberof HashBasedAuthenticationMethod
     */
    'hash': string;
}
/**
 *
 * @export
 * @interface HashBasedAuthenticationMethodAllOf
 */
export interface HashBasedAuthenticationMethodAllOf {
    /**
     * The hash of the authentication
     * @type {string}
     * @memberof HashBasedAuthenticationMethodAllOf
     */
    'hash': string;
}
/**
 *
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Invoice
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Invoice
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Invoice
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Invoice
     */
    'id': number;
    /**
     *
     * @type {User}
     * @memberof Invoice
     */
    'to': User;
    /**
     *
     * @type {Transfer}
     * @memberof Invoice
     */
    'transfer': Transfer;
    /**
     *
     * @type {Array<InvoiceEntry>}
     * @memberof Invoice
     */
    'invoiceEntries': Array<InvoiceEntry>;
    /**
     *
     * @type {Array<InvoiceStatus>}
     * @memberof Invoice
     */
    'invoiceStatus': Array<InvoiceStatus>;
    /**
     * Name of the addressed
     * @type {string}
     * @memberof Invoice
     */
    'addressee': string;
    /**
     * The description of the invoice
     * @type {string}
     * @memberof Invoice
     */
    'description': string;
}
/**
 *
 * @export
 * @interface InvoiceAllOf
 */
export interface InvoiceAllOf {
    /**
     *
     * @type {User}
     * @memberof InvoiceAllOf
     */
    'to': User;
    /**
     *
     * @type {Transfer}
     * @memberof InvoiceAllOf
     */
    'transfer': Transfer;
    /**
     *
     * @type {Array<InvoiceEntry>}
     * @memberof InvoiceAllOf
     */
    'invoiceEntries': Array<InvoiceEntry>;
    /**
     *
     * @type {Array<InvoiceStatus>}
     * @memberof InvoiceAllOf
     */
    'invoiceStatus': Array<InvoiceStatus>;
    /**
     * Name of the addressed
     * @type {string}
     * @memberof InvoiceAllOf
     */
    'addressee': string;
    /**
     * The description of the invoice
     * @type {string}
     * @memberof InvoiceAllOf
     */
    'description': string;
}
/**
 *
 * @export
 * @interface InvoiceEntry
 */
export interface InvoiceEntry {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof InvoiceEntry
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof InvoiceEntry
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof InvoiceEntry
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof InvoiceEntry
     */
    'id': number;
    /**
     *
     * @type {Invoice}
     * @memberof InvoiceEntry
     */
    'invoice': Invoice;
    /**
     *
     * @type {Dinero}
     * @memberof InvoiceEntry
     */
    'priceInclVat': Dinero;
    /**
     * The amount of items in the invoice entry.
     * @type {number}
     * @memberof InvoiceEntry
     */
    'amount': number;
    /**
     * The description of the invoice entry item.
     * @type {string}
     * @memberof InvoiceEntry
     */
    'description': string;
    /**
     * The percentage of vat applied to this item.
     * @type {number}
     * @memberof InvoiceEntry
     */
    'vatPercentage': number;
}
/**
 *
 * @export
 * @interface InvoiceEntryAllOf
 */
export interface InvoiceEntryAllOf {
    /**
     *
     * @type {Invoice}
     * @memberof InvoiceEntryAllOf
     */
    'invoice': Invoice;
    /**
     *
     * @type {Dinero}
     * @memberof InvoiceEntryAllOf
     */
    'priceInclVat': Dinero;
    /**
     * The amount of items in the invoice entry.
     * @type {number}
     * @memberof InvoiceEntryAllOf
     */
    'amount': number;
    /**
     * The description of the invoice entry item.
     * @type {string}
     * @memberof InvoiceEntryAllOf
     */
    'description': string;
    /**
     * The percentage of vat applied to this item.
     * @type {number}
     * @memberof InvoiceEntryAllOf
     */
    'vatPercentage': number;
}
/**
 *
 * @export
 * @interface InvoiceEntryRequest
 */
export interface InvoiceEntryRequest {
    /**
     * The description of the entry
     * @type {string}
     * @memberof InvoiceEntryRequest
     */
    'description': string;
    /**
     * Amount of item sold.
     * @type {number}
     * @memberof InvoiceEntryRequest
     */
    'amount': number;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof InvoiceEntryRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * The percentage of VAT applied to this item
     * @type {number}
     * @memberof InvoiceEntryRequest
     */
    'vatPercentage': number;
}
/**
 *
 * @export
 * @interface InvoiceEntryResponse
 */
export interface InvoiceEntryResponse {
    /**
     * The description of the entry
     * @type {string}
     * @memberof InvoiceEntryResponse
     */
    'description': string;
    /**
     * Amount of products sold.
     * @type {number}
     * @memberof InvoiceEntryResponse
     */
    'amount': number;
    /**
     *
     * @type {DineroObject}
     * @memberof InvoiceEntryResponse
     */
    'priceInclVat': DineroObject;
    /**
     * The percentage of VAT applied to this entry
     * @type {number}
     * @memberof InvoiceEntryResponse
     */
    'vatPercentage': number;
}
/**
 *
 * @export
 * @interface InvoiceResponse
 */
export interface InvoiceResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof InvoiceResponse
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'description': string;
    /**
     *
     * @type {InvoiceStatusResponse}
     * @memberof InvoiceResponse
     */
    'currentState': InvoiceStatusResponse;
    /**
     *
     * @type {TransferResponse}
     * @memberof InvoiceResponse
     */
    'transfer'?: TransferResponse;
    /**
     *
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponse
     */
    'invoiceEntries': Array<InvoiceEntryResponse>;
}
/**
 *
 * @export
 * @interface InvoiceResponseAllOf
 */
export interface InvoiceResponseAllOf {
    /**
     *
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponseAllOf
     */
    'invoiceEntries': Array<InvoiceEntryResponse>;
}
/**
 *
 * @export
 * @interface InvoiceStatus
 */
export interface InvoiceStatus {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof InvoiceStatus
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof InvoiceStatus
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof InvoiceStatus
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof InvoiceStatus
     */
    'id': number;
    /**
     *
     * @type {Invoice}
     * @memberof InvoiceStatus
     */
    'invoice': Invoice;
    /**
     *
     * @type {User}
     * @memberof InvoiceStatus
     */
    'changedBy': User;
    /**
     * The state of the Invoice
     * @type {string}
     * @memberof InvoiceStatus
     */
    'state': string;
}
/**
 *
 * @export
 * @interface InvoiceStatusAllOf
 */
export interface InvoiceStatusAllOf {
    /**
     *
     * @type {Invoice}
     * @memberof InvoiceStatusAllOf
     */
    'invoice': Invoice;
    /**
     *
     * @type {User}
     * @memberof InvoiceStatusAllOf
     */
    'changedBy': User;
    /**
     * The state of the Invoice
     * @type {string}
     * @memberof InvoiceStatusAllOf
     */
    'state': string;
}
/**
 *
 * @export
 * @interface InvoiceStatusResponse
 */
export interface InvoiceStatusResponse {
    /**
     *
     * @type {BaseUserResponse}
     * @memberof InvoiceStatusResponse
     */
    'changedBy': BaseUserResponse;
    /**
     * The state of the invoice, can be either CREATED, SENT, PAID or DELETED.
     * @type {string}
     * @memberof InvoiceStatusResponse
     */
    'state': string;
}
/**
 *
 * @export
 * @interface InvoiceUser
 */
export interface InvoiceUser {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof InvoiceUser
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof InvoiceUser
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof InvoiceUser
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof InvoiceUser
     */
    'id': number;
    /**
     *
     * @type {User}
     * @memberof InvoiceUser
     */
    'user': User;
    /**
     * Whether the user gets automatic invoices
     * @type {boolean}
     * @memberof InvoiceUser
     */
    'automatic'?: boolean;
}
/**
 *
 * @export
 * @interface InvoiceUserAllOf
 */
export interface InvoiceUserAllOf {
    /**
     *
     * @type {User}
     * @memberof InvoiceUserAllOf
     */
    'user': User;
    /**
     * Whether the user gets automatic invoices
     * @type {boolean}
     * @memberof InvoiceUserAllOf
     */
    'automatic'?: boolean;
}
/**
 *
 * @export
 * @interface KeyAuthenticator
 */
export interface KeyAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof KeyAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof KeyAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof KeyAuthenticator
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof KeyAuthenticator
     */
    'user': User;
}
/**
 *
 * @export
 * @interface LDAPAuthenticator
 */
export interface LDAPAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof LDAPAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof LDAPAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof LDAPAuthenticator
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof LDAPAuthenticator
     */
    'user': User;
    /**
     * The associated AD account name
     * @type {string}
     * @memberof LDAPAuthenticator
     */
    'accountName': string;
}
/**
 *
 * @export
 * @interface LDAPAuthenticatorAllOf
 */
export interface LDAPAuthenticatorAllOf {
    /**
     * The associated AD account name
     * @type {string}
     * @memberof LDAPAuthenticatorAllOf
     */
    'accountName': string;
}
/**
 *
 * @export
 * @interface LocalAuthenticator
 */
export interface LocalAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof LocalAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof LocalAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof LocalAuthenticator
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof LocalAuthenticator
     */
    'user': User;
    /**
     * The Password code of this user (hashed)
     * @type {string}
     * @memberof LocalAuthenticator
     */
    'hash': string;
}
/**
 *
 * @export
 * @interface LocalAuthenticatorAllOf
 */
export interface LocalAuthenticatorAllOf {
    /**
     * The Password code of this user (hashed)
     * @type {string}
     * @memberof LocalAuthenticatorAllOf
     */
    'hash': string;
}
/**
 *
 * @export
 * @interface LocalUser
 */
export interface LocalUser {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof LocalUser
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof LocalUser
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof LocalUser
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof LocalUser
     */
    'id': number;
    /**
     *
     * @type {User}
     * @memberof LocalUser
     */
    'user': User;
    /**
     * The hashed password of the user.
     * @type {string}
     * @memberof LocalUser
     */
    'passwordHash': string;
}
/**
 *
 * @export
 * @interface LocalUserAllOf
 */
export interface LocalUserAllOf {
    /**
     *
     * @type {User}
     * @memberof LocalUserAllOf
     */
    'user': User;
    /**
     * The hashed password of the user.
     * @type {string}
     * @memberof LocalUserAllOf
     */
    'passwordHash': string;
}
/**
 *
 * @export
 * @interface MemberAuthenticator
 */
export interface MemberAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof MemberAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof MemberAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof MemberAuthenticator
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof MemberAuthenticator
     */
    'user': User;
    /**
     *
     * @type {User}
     * @memberof MemberAuthenticator
     */
    'authenticateAs': User;
}
/**
 *
 * @export
 * @interface MemberAuthenticatorAllOf
 */
export interface MemberAuthenticatorAllOf {
    /**
     *
     * @type {User}
     * @memberof MemberAuthenticatorAllOf
     */
    'authenticateAs': User;
}
/**
 *
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * The message response text.
     * @type {string}
     * @memberof MessageResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface NfcAuthenticator
 */
export interface NfcAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof NfcAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof NfcAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof NfcAuthenticator
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof NfcAuthenticator
     */
    'user': User;
    /**
     * The UID of the NFC chip
     * @type {string}
     * @memberof NfcAuthenticator
     */
    'nfcCode': string;
}
/**
 *
 * @export
 * @interface NfcAuthenticatorAllOf
 */
export interface NfcAuthenticatorAllOf {
    /**
     * The UID of the NFC chip
     * @type {string}
     * @memberof NfcAuthenticatorAllOf
     */
    'nfcCode': string;
}
/**
 *
 * @export
 * @interface PaginatedBalanceResponse
 */
export interface PaginatedBalanceResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedBalanceResponse
     */
    '_pagination'?: PaginationResult;
    /**
     *
     * @type {Array<BalanceResponse>}
     * @memberof PaginatedBalanceResponse
     */
    'records'?: Array<BalanceResponse>;
}
/**
 *
 * @export
 * @interface PaginatedBannerResponse
 */
export interface PaginatedBannerResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedBannerResponse
     */
    '_pagination'?: PaginationResult;
    /**
     *
     * @type {Array<BannerResponse>}
     * @memberof PaginatedBannerResponse
     */
    'records'?: Array<BannerResponse>;
}
/**
 *
 * @export
 * @interface PaginatedBasePayoutRequestResponse
 */
export interface PaginatedBasePayoutRequestResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedBasePayoutRequestResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<BasePayoutRequestResponse>}
     * @memberof PaginatedBasePayoutRequestResponse
     */
    'records': Array<BasePayoutRequestResponse>;
}
/**
 *
 * @export
 * @interface PaginatedBaseTransactionResponse
 */
export interface PaginatedBaseTransactionResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedBaseTransactionResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<BaseTransactionResponse>}
     * @memberof PaginatedBaseTransactionResponse
     */
    'records': Array<BaseTransactionResponse>;
}
/**
 *
 * @export
 * @interface PaginatedBorrelkaartGroupResponse
 */
export interface PaginatedBorrelkaartGroupResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedBorrelkaartGroupResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<BorrelkaartGroupResponse>}
     * @memberof PaginatedBorrelkaartGroupResponse
     */
    'records': Array<BorrelkaartGroupResponse>;
}
/**
 *
 * @export
 * @interface PaginatedContainerResponse
 */
export interface PaginatedContainerResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedContainerResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<ContainerResponse>}
     * @memberof PaginatedContainerResponse
     */
    'records': Array<ContainerResponse>;
}
/**
 *
 * @export
 * @interface PaginatedContainerWithProductResponse
 */
export interface PaginatedContainerWithProductResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedContainerWithProductResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PaginatedContainerWithProductResponse
     */
    'records': Array<ContainerWithProductsResponse>;
}
/**
 *
 * @export
 * @interface PaginatedFinancialMutationResponse
 */
export interface PaginatedFinancialMutationResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedFinancialMutationResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<PaginatedFinancialMutationResponse>}
     * @memberof PaginatedFinancialMutationResponse
     */
    'records': Array<PaginatedFinancialMutationResponse>;
}
/**
 *
 * @export
 * @interface PaginatedInvoiceResponse
 */
export interface PaginatedInvoiceResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedInvoiceResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<object>}
     * @memberof PaginatedInvoiceResponse
     */
    'records': Array<object>;
}
/**
 *
 * @export
 * @interface PaginatedPointOfSaleResponse
 */
export interface PaginatedPointOfSaleResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedPointOfSaleResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<PointOfSaleResponse>}
     * @memberof PaginatedPointOfSaleResponse
     */
    'records': Array<PointOfSaleResponse>;
}
/**
 *
 * @export
 * @interface PaginatedProductCategoryResponse
 */
export interface PaginatedProductCategoryResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedProductCategoryResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<ProductCategoryResponse>}
     * @memberof PaginatedProductCategoryResponse
     */
    'records': Array<ProductCategoryResponse>;
}
/**
 *
 * @export
 * @interface PaginatedProductResponse
 */
export interface PaginatedProductResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedProductResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<ProductResponse>}
     * @memberof PaginatedProductResponse
     */
    'records': Array<ProductResponse>;
}
/**
 *
 * @export
 * @interface PaginatedTransferResponse
 */
export interface PaginatedTransferResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedTransferResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<TransferResponse>}
     * @memberof PaginatedTransferResponse
     */
    'records': Array<TransferResponse>;
}
/**
 *
 * @export
 * @interface PaginatedUpdatedPointOfSaleResponse
 */
export interface PaginatedUpdatedPointOfSaleResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedUpdatedPointOfSaleResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<object>}
     * @memberof PaginatedUpdatedPointOfSaleResponse
     */
    'records': Array<object>;
}
/**
 *
 * @export
 * @interface PaginatedUserResponse
 */
export interface PaginatedUserResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedUserResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<UserResponse>}
     * @memberof PaginatedUserResponse
     */
    'records': Array<UserResponse>;
}
/**
 *
 * @export
 * @interface PaginatedVatGroupResponse
 */
export interface PaginatedVatGroupResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedVatGroupResponse
     */
    '_pagination': PaginationResult;
    /**
     *
     * @type {Array<VatGroup>}
     * @memberof PaginatedVatGroupResponse
     */
    'records': Array<VatGroup>;
}
/**
 *
 * @export
 * @interface PaginationResult
 */
export interface PaginationResult {
    /**
     * Number of records queried
     * @type {number}
     * @memberof PaginationResult
     */
    'take'?: number;
    /**
     * Number of skipped records
     * @type {number}
     * @memberof PaginationResult
     */
    'skip'?: number;
    /**
     * Total number of resulting records
     * @type {number}
     * @memberof PaginationResult
     */
    'count'?: number;
}
/**
 *
 * @export
 * @interface PayoutRequestRequest
 */
export interface PayoutRequestRequest {
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof PayoutRequestRequest
     */
    'amount': DineroObjectRequest;
    /**
     * The bank account number to transfer the money to
     * @type {string}
     * @memberof PayoutRequestRequest
     */
    'bankAccountNumber': string;
    /**
     * The name of the owner of the bank account
     * @type {string}
     * @memberof PayoutRequestRequest
     */
    'bankAccountName': string;
}
/**
 *
 * @export
 * @interface PayoutRequestResponse
 */
export interface PayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PayoutRequestResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof PayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof PayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof PayoutRequestResponse
     */
    'amount': DineroObjectResponse;
    /**
     *
     * @type {Array<PayoutRequestStatusResponse>}
     * @memberof PayoutRequestResponse
     */
    'status': Array<PayoutRequestStatusResponse>;
    /**
     * Bank account number
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'bankAccountNumber': string;
    /**
     * Name of the account owner
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'bankAccountName': string;
}
/**
 *
 * @export
 * @interface PayoutRequestResponseAllOf
 */
export interface PayoutRequestResponseAllOf {
    /**
     *
     * @type {Array<PayoutRequestStatusResponse>}
     * @memberof PayoutRequestResponseAllOf
     */
    'status': Array<PayoutRequestStatusResponse>;
    /**
     * Bank account number
     * @type {string}
     * @memberof PayoutRequestResponseAllOf
     */
    'bankAccountNumber': string;
    /**
     * Name of the account owner
     * @type {string}
     * @memberof PayoutRequestResponseAllOf
     */
    'bankAccountName': string;
}
/**
 *
 * @export
 * @interface PayoutRequestStatusRequest
 */
export interface PayoutRequestStatusRequest {
    /**
     * PayoutRequestState to change to, should be one of CREATED, APPROVED, DENIED, CANCELLED
     * @type {string}
     * @memberof PayoutRequestStatusRequest
     */
    'state'?: string;
}
/**
 *
 * @export
 * @interface PayoutRequestStatusResponse
 */
export interface PayoutRequestStatusResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PayoutRequestStatusResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PayoutRequestStatusResponse
     */
    'version'?: number;
    /**
     * The state of this status change
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'state': string;
}
/**
 *
 * @export
 * @interface PayoutRequestStatusResponseAllOf
 */
export interface PayoutRequestStatusResponseAllOf {
    /**
     * The state of this status change
     * @type {string}
     * @memberof PayoutRequestStatusResponseAllOf
     */
    'state': string;
}
/**
 *
 * @export
 * @interface PinAuthenticator
 */
export interface PinAuthenticator {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof PinAuthenticator
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof PinAuthenticator
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof PinAuthenticator
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof PinAuthenticator
     */
    'user': User;
    /**
     * The PIN code of this user (hashed)
     * @type {string}
     * @memberof PinAuthenticator
     */
    'hash': string;
}
/**
 *
 * @export
 * @interface PinAuthenticatorAllOf
 */
export interface PinAuthenticatorAllOf {
    /**
     * The PIN code of this user (hashed)
     * @type {string}
     * @memberof PinAuthenticatorAllOf
     */
    'hash': string;
}
/**
 *
 * @export
 * @interface PointOfSale
 */
export interface PointOfSale {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof PointOfSale
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof PointOfSale
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof PointOfSale
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof PointOfSale
     */
    'id': number;
    /**
     * The current revision of the pointOfSale. Can be null if no revision exists.
     * @type {number}
     * @memberof PointOfSale
     */
    'currentRevision'?: number;
    /**
     *
     * @type {User}
     * @memberof PointOfSale
     */
    'owner': User;
}
/**
 *
 * @export
 * @interface PointOfSaleAllOf
 */
export interface PointOfSaleAllOf {
    /**
     * The current revision of the pointOfSale. Can be null if no revision exists.
     * @type {number}
     * @memberof PointOfSaleAllOf
     */
    'currentRevision'?: number;
    /**
     *
     * @type {User}
     * @memberof PointOfSaleAllOf
     */
    'owner': User;
}
/**
 *
 * @export
 * @interface PointOfSaleResponse
 */
export interface PointOfSaleResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'name': string;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof PointOfSaleResponse
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleResponse
     */
    'useAuthentication': boolean;
}
/**
 *
 * @export
 * @interface PointOfSaleResponseAllOf
 */
export interface PointOfSaleResponseAllOf {
    /**
     *
     * @type {BaseUserResponse}
     * @memberof PointOfSaleResponseAllOf
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleResponseAllOf
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleResponseAllOf
     */
    'useAuthentication': boolean;
}
/**
 *
 * @export
 * @interface PointOfSaleRevision
 */
export interface PointOfSaleRevision {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof PointOfSaleRevision
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof PointOfSaleRevision
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof PointOfSaleRevision
     */
    'version'?: number;
    /**
     * The unique name of the pointOfSale.
     * @type {string}
     * @memberof PointOfSaleRevision
     */
    'name': string;
    /**
     *
     * @type {PointOfSale}
     * @memberof PointOfSaleRevision
     */
    'pointOfSale': PointOfSale;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof PointOfSaleRevision
     */
    'revision': number;
    /**
     *
     * @type {Array<ContainerRevision>}
     * @memberof PointOfSaleRevision
     */
    'containers': Array<ContainerRevision>;
}
/**
 *
 * @export
 * @interface PointOfSaleRevisionAllOf
 */
export interface PointOfSaleRevisionAllOf {
    /**
     *
     * @type {PointOfSale}
     * @memberof PointOfSaleRevisionAllOf
     */
    'pointOfSale': PointOfSale;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof PointOfSaleRevisionAllOf
     */
    'revision': number;
    /**
     *
     * @type {Array<ContainerRevision>}
     * @memberof PointOfSaleRevisionAllOf
     */
    'containers': Array<ContainerRevision>;
}
/**
 *
 * @export
 * @interface PointOfSaleWithContainersResponse
 */
export interface PointOfSaleWithContainersResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'name': string;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof PointOfSaleWithContainersResponse
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleWithContainersResponse
     */
    'useAuthentication': boolean;
    /**
     *
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PointOfSaleWithContainersResponse
     */
    'containers': Array<ContainerWithProductsResponse>;
}
/**
 *
 * @export
 * @interface PointOfSaleWithContainersResponseAllOf
 */
export interface PointOfSaleWithContainersResponseAllOf {
    /**
     *
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PointOfSaleWithContainersResponseAllOf
     */
    'containers': Array<ContainerWithProductsResponse>;
}
/**
 *
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Product
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Product
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Product
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Product
     */
    'id': number;
    /**
     * The current revision of the product. Can be null if no revision exists.
     * @type {number}
     * @memberof Product
     */
    'currentRevision'?: number;
    /**
     *
     * @type {User}
     * @memberof Product
     */
    'owner': User;
    /**
     *
     * @type {ProductImage}
     * @memberof Product
     */
    'image'?: ProductImage;
}
/**
 *
 * @export
 * @interface ProductAllOf
 */
export interface ProductAllOf {
    /**
     * The current revision of the product. Can be null if no revision exists.
     * @type {number}
     * @memberof ProductAllOf
     */
    'currentRevision'?: number;
    /**
     *
     * @type {User}
     * @memberof ProductAllOf
     */
    'owner': User;
    /**
     *
     * @type {ProductImage}
     * @memberof ProductAllOf
     */
    'image'?: ProductImage;
}
/**
 *
 * @export
 * @interface ProductCategory
 */
export interface ProductCategory {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof ProductCategory
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof ProductCategory
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof ProductCategory
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof ProductCategory
     */
    'id': number;
    /**
     * The unique name of the productCategory.
     * @type {string}
     * @memberof ProductCategory
     */
    'name': string;
}
/**
 *
 * @export
 * @interface ProductCategoryAllOf
 */
export interface ProductCategoryAllOf {
    /**
     * The unique name of the productCategory.
     * @type {string}
     * @memberof ProductCategoryAllOf
     */
    'name': string;
}
/**
 *
 * @export
 * @interface ProductCategoryRequest
 */
export interface ProductCategoryRequest {
    /**
     * Name/label of the productCategory
     * @type {string}
     * @memberof ProductCategoryRequest
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface ProductCategoryResponse
 */
export interface ProductCategoryResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ProductCategoryResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ProductCategoryResponse
     */
    'version'?: number;
    /**
     * The name of the productCategory.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'name': string;
}
/**
 *
 * @export
 * @interface ProductCategoryResponseAllOf
 */
export interface ProductCategoryResponseAllOf {
    /**
     * The name of the productCategory.
     * @type {string}
     * @memberof ProductCategoryResponseAllOf
     */
    'name': string;
}
/**
 *
 * @export
 * @interface ProductImage
 */
export interface ProductImage {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof ProductImage
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof ProductImage
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof ProductImage
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof ProductImage
     */
    'id': number;
    /**
     * The filename when the file is downloaded
     * @type {string}
     * @memberof ProductImage
     */
    'downloadName': string;
    /**
     * The location of the file, including filename in storage
     * @type {string}
     * @memberof ProductImage
     */
    'location': string;
    /**
     *
     * @type {User}
     * @memberof ProductImage
     */
    'createdBy': User;
}
/**
 *
 * @export
 * @interface ProductOrdering
 */
export interface ProductOrdering {
    /**
     *
     * @type {PointOfSale}
     * @memberof ProductOrdering
     */
    'pos': PointOfSale;
    /**
     *
     * @type {Product}
     * @memberof ProductOrdering
     */
    'product': Product;
    /**
     * The order number of the product in the pointOfSale.
     * @type {number}
     * @memberof ProductOrdering
     */
    'order': number;
}
/**
 *
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ProductResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ProductResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ProductResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ProductResponse
     */
    'version'?: number;
    /**
     * The name of the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'name': string;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof ProductResponse
     */
    'priceInclVat': DineroObjectResponse;
    /**
     *
     * @type {BaseVatGroupResponse}
     * @memberof ProductResponse
     */
    'vat': BaseVatGroupResponse;
    /**
     * The product revision ID
     * @type {number}
     * @memberof ProductResponse
     */
    'revision': number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof ProductResponse
     */
    'owner': BaseUserResponse;
    /**
     *
     * @type {ProductCategoryResponse}
     * @memberof ProductResponse
     */
    'category': ProductCategoryResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof ProductResponse
     */
    'priceExclVat': DineroObjectResponse;
    /**
     * The URL to the picture representing this product.
     * @type {string}
     * @memberof ProductResponse
     */
    'image': string;
    /**
     * The percentage of alcohol in this product.
     * @type {number}
     * @memberof ProductResponse
     */
    'alcoholPercentage': number;
}
/**
 *
 * @export
 * @interface ProductResponseAllOf
 */
export interface ProductResponseAllOf {
    /**
     * The product revision ID
     * @type {number}
     * @memberof ProductResponseAllOf
     */
    'revision': number;
}
/**
 *
 * @export
 * @interface ProductRevision
 */
export interface ProductRevision {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof ProductRevision
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof ProductRevision
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof ProductRevision
     */
    'version'?: number;
    /**
     * The unique name of the product.
     * @type {string}
     * @memberof ProductRevision
     */
    'name': string;
    /**
     *
     * @type {Dinero}
     * @memberof ProductRevision
     */
    'price': Dinero;
    /**
     *
     * @type {Product}
     * @memberof ProductRevision
     */
    'product': Product;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof ProductRevision
     */
    'revision': number;
}
/**
 *
 * @export
 * @interface ProductRevisionAllOf
 */
export interface ProductRevisionAllOf {
    /**
     *
     * @type {Product}
     * @memberof ProductRevisionAllOf
     */
    'product': Product;
    /**
     * The revision number of this revision.
     * @type {number}
     * @memberof ProductRevisionAllOf
     */
    'revision': number;
}
/**
 *
 * @export
 * @interface RelationResponse
 */
export interface RelationResponse {
    /**
     * The the ownership relation towards the entity.
     * @type {string}
     * @memberof RelationResponse
     */
    'relation'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof RelationResponse
     */
    'attributes'?: Array<string>;
}
/**
 *
 * @export
 * @interface ResetLocalRequest
 */
export interface ResetLocalRequest {
    /**
     * The mail of the user
     * @type {string}
     * @memberof ResetLocalRequest
     */
    'accountMail': string;
}
/**
 *
 * @export
 * @interface ResetToken
 */
export interface ResetToken {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof ResetToken
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof ResetToken
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof ResetToken
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof ResetToken
     */
    'user': User;
    /**
     * The hash of the authentication
     * @type {string}
     * @memberof ResetToken
     */
    'hash': string;
    /**
     * The end date from which the token is expired
     * @type {string}
     * @memberof ResetToken
     */
    'expires': string;
}
/**
 *
 * @export
 * @interface ResetTokenAllOf
 */
export interface ResetTokenAllOf {
    /**
     * The end date from which the token is expired
     * @type {string}
     * @memberof ResetTokenAllOf
     */
    'expires': string;
}
/**
 *
 * @export
 * @interface RevisionRequest
 */
export interface RevisionRequest {
    /**
     * revision id
     * @type {number}
     * @memberof RevisionRequest
     */
    'id'?: number;
    /**
     * revision number
     * @type {number}
     * @memberof RevisionRequest
     */
    'revision'?: number;
}
/**
 *
 * @export
 * @interface RoleResponse
 */
export interface RoleResponse {
    /**
     * The name of the role.
     * @type {string}
     * @memberof RoleResponse
     */
    'role': string;
    /**
     *
     * @type {Array<EntityResponse>}
     * @memberof RoleResponse
     */
    'entities'?: Array<EntityResponse>;
}
/**
 *
 * @export
 * @interface SimpleFileRequest
 */
export interface SimpleFileRequest {
    /**
     * Name of the file
     * @type {string}
     * @memberof SimpleFileRequest
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface SimpleFileResponse
 */
export interface SimpleFileResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SimpleFileResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SimpleFileResponse
     */
    'version'?: number;
    /**
     * The filename of the file
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'downloadName': string;
    /**
     * The location of the file in storage
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'location': string;
    /**
     *
     * @type {UserResponse}
     * @memberof SimpleFileResponse
     */
    'createdBy': UserResponse;
}
/**
 *
 * @export
 * @interface SimpleFileResponseAllOf
 */
export interface SimpleFileResponseAllOf {
    /**
     * The filename of the file
     * @type {string}
     * @memberof SimpleFileResponseAllOf
     */
    'downloadName': string;
    /**
     * The location of the file in storage
     * @type {string}
     * @memberof SimpleFileResponseAllOf
     */
    'location': string;
    /**
     *
     * @type {UserResponse}
     * @memberof SimpleFileResponseAllOf
     */
    'createdBy': UserResponse;
}
/**
 *
 * @export
 * @interface StripeDepositResponse
 */
export interface StripeDepositResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripeDepositResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripeDepositResponse
     */
    'version'?: number;
    /**
     * The ID of the payment intent in Stripe
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'stripeId': string;
    /**
     *
     * @type {Array<StripeDepositStatusResponse>}
     * @memberof StripeDepositResponse
     */
    'depositStatus': Array<StripeDepositStatusResponse>;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof StripeDepositResponse
     */
    'amount': DineroObjectResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof StripeDepositResponse
     */
    'to': BaseUserResponse;
}
/**
 *
 * @export
 * @interface StripeDepositResponseAllOf
 */
export interface StripeDepositResponseAllOf {
    /**
     * The ID of the payment intent in Stripe
     * @type {string}
     * @memberof StripeDepositResponseAllOf
     */
    'stripeId': string;
    /**
     *
     * @type {Array<StripeDepositStatusResponse>}
     * @memberof StripeDepositResponseAllOf
     */
    'depositStatus': Array<StripeDepositStatusResponse>;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof StripeDepositResponseAllOf
     */
    'amount': DineroObjectResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof StripeDepositResponseAllOf
     */
    'to': BaseUserResponse;
}
/**
 *
 * @export
 * @interface StripeDepositStatusResponse
 */
export interface StripeDepositStatusResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripeDepositStatusResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripeDepositStatusResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripeDepositStatusResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripeDepositStatusResponse
     */
    'version'?: number;
    /**
     *
     * @type {string}
     * @memberof StripeDepositStatusResponse
     */
    'depositStatus': string;
}
/**
 *
 * @export
 * @interface StripeDepositStatusResponseAllOf
 */
export interface StripeDepositStatusResponseAllOf {
    /**
     *
     * @type {string}
     * @memberof StripeDepositStatusResponseAllOf
     */
    'depositStatus': string;
}
/**
 *
 * @export
 * @interface StripePaymentIntentResponse
 */
export interface StripePaymentIntentResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripePaymentIntentResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripePaymentIntentResponse
     */
    'version'?: number;
    /**
     * ID of the intent in Stripe.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'stripeId': string;
    /**
     * The client secret of the created Payment Intent.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'clientSecret': string;
}
/**
 *
 * @export
 * @interface StripePaymentIntentResponseAllOf
 */
export interface StripePaymentIntentResponseAllOf {
    /**
     * ID of the intent in Stripe.
     * @type {string}
     * @memberof StripePaymentIntentResponseAllOf
     */
    'stripeId': string;
    /**
     * The client secret of the created Payment Intent.
     * @type {string}
     * @memberof StripePaymentIntentResponseAllOf
     */
    'clientSecret': string;
}
/**
 *
 * @export
 * @interface StripeRequest
 */
export interface StripeRequest {
    /**
     *
     * @type {Dinero}
     * @memberof StripeRequest
     */
    'amount'?: Dinero;
}
/**
 *
 * @export
 * @interface SubTransaction
 */
export interface SubTransaction {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof SubTransaction
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof SubTransaction
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof SubTransaction
     */
    'version'?: number;
    /**
     *
     * @type {User}
     * @memberof SubTransaction
     */
    'to': User;
    /**
     *
     * @type {Container}
     * @memberof SubTransaction
     */
    'container': Container;
    /**
     *
     * @type {Transaction}
     * @memberof SubTransaction
     */
    'transaction': Transaction;
    /**
     *
     * @type {Array<SubTransactionRow>}
     * @memberof SubTransaction
     */
    'subTransactionsRows': Array<SubTransactionRow>;
}
/**
 *
 * @export
 * @interface SubTransactionAllOf
 */
export interface SubTransactionAllOf {
    /**
     *
     * @type {User}
     * @memberof SubTransactionAllOf
     */
    'to': User;
    /**
     *
     * @type {Container}
     * @memberof SubTransactionAllOf
     */
    'container': Container;
    /**
     *
     * @type {Transaction}
     * @memberof SubTransactionAllOf
     */
    'transaction': Transaction;
    /**
     *
     * @type {Array<SubTransactionRow>}
     * @memberof SubTransactionAllOf
     */
    'subTransactionsRows': Array<SubTransactionRow>;
}
/**
 *
 * @export
 * @interface SubTransactionRequest
 */
export interface SubTransactionRequest {
    /**
     * to user id
     * @type {number}
     * @memberof SubTransactionRequest
     */
    'to': number;
    /**
     *
     * @type {RevisionRequest}
     * @memberof SubTransactionRequest
     */
    'container': RevisionRequest;
    /**
     *
     * @type {Array<SubTransactionRowRequest>}
     * @memberof SubTransactionRequest
     */
    'subTransactionRows': Array<SubTransactionRowRequest>;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof SubTransactionRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 *
 * @export
 * @interface SubTransactionResponse
 */
export interface SubTransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SubTransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SubTransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SubTransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SubTransactionResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof SubTransactionResponse
     */
    'to': BaseUserResponse;
    /**
     *
     * @type {BaseContainerResponse}
     * @memberof SubTransactionResponse
     */
    'container': BaseContainerResponse;
    /**
     *
     * @type {Array<SubTransactionRowResponse>}
     * @memberof SubTransactionResponse
     */
    'subTransactionsRows': Array<SubTransactionRowResponse>;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof SubTransactionResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface SubTransactionResponseAllOf
 */
export interface SubTransactionResponseAllOf {
    /**
     *
     * @type {BaseUserResponse}
     * @memberof SubTransactionResponseAllOf
     */
    'to': BaseUserResponse;
    /**
     *
     * @type {BaseContainerResponse}
     * @memberof SubTransactionResponseAllOf
     */
    'container': BaseContainerResponse;
    /**
     *
     * @type {Array<SubTransactionRowResponse>}
     * @memberof SubTransactionResponseAllOf
     */
    'subTransactionsRows': Array<SubTransactionRowResponse>;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof SubTransactionResponseAllOf
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface SubTransactionRow
 */
export interface SubTransactionRow {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof SubTransactionRow
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof SubTransactionRow
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof SubTransactionRow
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof SubTransactionRow
     */
    'id': number;
    /**
     *
     * @type {Product}
     * @memberof SubTransactionRow
     */
    'product': Product;
    /**
     * The amount that has been bought.
     * @type {number}
     * @memberof SubTransactionRow
     */
    'amount': number;
    /**
     *
     * @type {SubTransaction}
     * @memberof SubTransactionRow
     */
    'subTransaction'?: SubTransaction;
}
/**
 *
 * @export
 * @interface SubTransactionRowAllOf
 */
export interface SubTransactionRowAllOf {
    /**
     *
     * @type {Product}
     * @memberof SubTransactionRowAllOf
     */
    'product': Product;
    /**
     * The amount that has been bought.
     * @type {number}
     * @memberof SubTransactionRowAllOf
     */
    'amount': number;
    /**
     *
     * @type {SubTransaction}
     * @memberof SubTransactionRowAllOf
     */
    'subTransaction'?: SubTransaction;
}
/**
 *
 * @export
 * @interface SubTransactionRowRequest
 */
export interface SubTransactionRowRequest {
    /**
     *
     * @type {RevisionRequest}
     * @memberof SubTransactionRowRequest
     */
    'product'?: RevisionRequest;
    /**
     * amount of this product in subtransaction
     * @type {number}
     * @memberof SubTransactionRowRequest
     */
    'amount'?: number;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof SubTransactionRowRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 *
 * @export
 * @interface SubTransactionRowResponse
 */
export interface SubTransactionRowResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SubTransactionRowResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SubTransactionRowResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseProductResponse}
     * @memberof SubTransactionRowResponse
     */
    'product': BaseProductResponse;
    /**
     * The amount that has been bought
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'amount': number;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof SubTransactionRowResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface SubTransactionRowResponseAllOf
 */
export interface SubTransactionRowResponseAllOf {
    /**
     *
     * @type {BaseProductResponse}
     * @memberof SubTransactionRowResponseAllOf
     */
    'product': BaseProductResponse;
    /**
     * The amount that has been bought
     * @type {number}
     * @memberof SubTransactionRowResponseAllOf
     */
    'amount': number;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof SubTransactionRowResponseAllOf
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Transaction
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Transaction
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Transaction
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Transaction
     */
    'id': number;
    /**
     *
     * @type {User}
     * @memberof Transaction
     */
    'from': User;
    /**
     *
     * @type {User}
     * @memberof Transaction
     */
    'createdBy': User;
    /**
     *
     * @type {Array<SubTransaction>}
     * @memberof Transaction
     */
    'subTransactions': Array<SubTransaction>;
    /**
     *
     * @type {PointOfSaleRevision}
     * @memberof Transaction
     */
    'pointOfSale': PointOfSaleRevision;
}
/**
 *
 * @export
 * @interface TransactionAllOf
 */
export interface TransactionAllOf {
    /**
     *
     * @type {User}
     * @memberof TransactionAllOf
     */
    'from': User;
    /**
     *
     * @type {User}
     * @memberof TransactionAllOf
     */
    'createdBy': User;
    /**
     *
     * @type {Array<SubTransaction>}
     * @memberof TransactionAllOf
     */
    'subTransactions': Array<SubTransaction>;
    /**
     *
     * @type {PointOfSaleRevision}
     * @memberof TransactionAllOf
     */
    'pointOfSale': PointOfSaleRevision;
}
/**
 *
 * @export
 * @interface TransactionFilterParameters
 */
export interface TransactionFilterParameters {
    /**
     *
     * @type {Array<number>}
     * @memberof TransactionFilterParameters
     */
    'transactionId'?: Array<number>;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'fromId'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'createdById'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'toId'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'pointOfSaleId'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'pointOfSaleRevision'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'containerId'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'containerRevision'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'productId'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'productRevision'?: number;
    /**
     *
     * @type {string}
     * @memberof TransactionFilterParameters
     */
    'fromDate'?: string;
    /**
     *
     * @type {string}
     * @memberof TransactionFilterParameters
     */
    'tillDate'?: string;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'invoiceId'?: number;
}
/**
 *
 * @export
 * @interface TransactionReportCategoryEntryResponse
 */
export interface TransactionReportCategoryEntryResponse {
    /**
     *
     * @type {ProductCategoryResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'category': ProductCategoryResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface TransactionReportDataResponse
 */
export interface TransactionReportDataResponse {
    /**
     *
     * @type {Array<TransactionReportEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'entries': Array<TransactionReportEntryResponse>;
    /**
     *
     * @type {Array<TransactionReportCategoryEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'categories': Array<TransactionReportCategoryEntryResponse>;
    /**
     *
     * @type {Array<TransactionReportVatEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'vat': Array<TransactionReportVatEntryResponse>;
}
/**
 *
 * @export
 * @interface TransactionReportEntryResponse
 */
export interface TransactionReportEntryResponse {
    /**
     * The amount of times this product is in the report
     * @type {number}
     * @memberof TransactionReportEntryResponse
     */
    'count': number;
    /**
     *
     * @type {BaseProductResponse}
     * @memberof TransactionReportEntryResponse
     */
    'product': BaseProductResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface TransactionReportResponse
 */
export interface TransactionReportResponse {
    /**
     *
     * @type {TransactionFilterParameters}
     * @memberof TransactionReportResponse
     */
    'parameters': TransactionFilterParameters;
    /**
     *
     * @type {TransactionReportDataResponse}
     * @memberof TransactionReportResponse
     */
    'data': TransactionReportDataResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportResponse
     */
    'totalInclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface TransactionReportVatEntryResponse
 */
export interface TransactionReportVatEntryResponse {
    /**
     *
     * @type {BaseVatGroupResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'vat': BaseVatGroupResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface TransactionRequest
 */
export interface TransactionRequest {
    /**
     * from user id
     * @type {number}
     * @memberof TransactionRequest
     */
    'from': number;
    /**
     * createdBy user id
     * @type {number}
     * @memberof TransactionRequest
     */
    'createdBy'?: number;
    /**
     *
     * @type {Array<SubTransactionRequest>}
     * @memberof TransactionRequest
     */
    'subTransactions': Array<SubTransactionRequest>;
    /**
     *
     * @type {RevisionRequest}
     * @memberof TransactionRequest
     */
    'pointOfSale': RevisionRequest;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof TransactionRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 *
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof TransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof TransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof TransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof TransactionResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransactionResponse
     */
    'from': BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransactionResponse
     */
    'createdBy'?: BaseUserResponse;
    /**
     *
     * @type {Array<SubTransactionResponse>}
     * @memberof TransactionResponse
     */
    'subTransactions': Array<SubTransactionResponse>;
    /**
     *
     * @type {BasePointOfSaleResponse}
     * @memberof TransactionResponse
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface TransactionResponseAllOf
 */
export interface TransactionResponseAllOf {
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransactionResponseAllOf
     */
    'from': BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransactionResponseAllOf
     */
    'createdBy'?: BaseUserResponse;
    /**
     *
     * @type {Array<SubTransactionResponse>}
     * @memberof TransactionResponseAllOf
     */
    'subTransactions': Array<SubTransactionResponse>;
    /**
     *
     * @type {BasePointOfSaleResponse}
     * @memberof TransactionResponseAllOf
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionResponseAllOf
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof Transfer
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof Transfer
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof Transfer
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof Transfer
     */
    'id': number;
    /**
     *
     * @type {User}
     * @memberof Transfer
     */
    'from'?: User;
    /**
     *
     * @type {User}
     * @memberof Transfer
     */
    'to'?: User;
    /**
     *
     * @type {Dinero}
     * @memberof Transfer
     */
    'amount': Dinero;
    /**
     * The type of transfer.
     * @type {number}
     * @memberof Transfer
     */
    'type': number;
    /**
     * If the transfer is of type \'custom\', this contains a description of the transfer.
     * @type {string}
     * @memberof Transfer
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface TransferAllOf
 */
export interface TransferAllOf {
    /**
     *
     * @type {User}
     * @memberof TransferAllOf
     */
    'from'?: User;
    /**
     *
     * @type {User}
     * @memberof TransferAllOf
     */
    'to'?: User;
    /**
     *
     * @type {Dinero}
     * @memberof TransferAllOf
     */
    'amount': Dinero;
    /**
     * The type of transfer.
     * @type {number}
     * @memberof TransferAllOf
     */
    'type': number;
    /**
     * If the transfer is of type \'custom\', this contains a description of the transfer.
     * @type {string}
     * @memberof TransferAllOf
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface TransferRequest
 */
export interface TransferRequest {
    /**
     * Description of the transfer
     * @type {string}
     * @memberof TransferRequest
     */
    'description'?: string;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof TransferRequest
     */
    'amount'?: DineroObjectRequest;
    /**
     * Type of transfer
     * @type {number}
     * @memberof TransferRequest
     */
    'type'?: number;
    /**
     * from which user the money is being transferred
     * @type {number}
     * @memberof TransferRequest
     */
    'fromId'?: number;
    /**
     * to which user the money is being transferred.
     * @type {number}
     * @memberof TransferRequest
     */
    'toId'?: number;
}
/**
 *
 * @export
 * @interface TransferResponse
 */
export interface TransferResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof TransferResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof TransferResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof TransferResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof TransferResponse
     */
    'version'?: number;
    /**
     * Description of the transfer
     * @type {string}
     * @memberof TransferResponse
     */
    'description': string;
    /**
     *
     * @type {Dinero}
     * @memberof TransferResponse
     */
    'amount': Dinero;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransferResponse
     */
    'from'?: BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransferResponse
     */
    'to'?: BaseUserResponse;
    /**
     *
     * @type {BaseInvoiceResponse}
     * @memberof TransferResponse
     */
    'invoice'?: BaseInvoiceResponse;
    /**
     *
     * @type {StripeDepositResponse}
     * @memberof TransferResponse
     */
    'deposit'?: StripeDepositResponse;
    /**
     *
     * @type {BasePayoutRequestResponse}
     * @memberof TransferResponse
     */
    'payoutRequest'?: BasePayoutRequestResponse;
}
/**
 *
 * @export
 * @interface TransferResponseAllOf
 */
export interface TransferResponseAllOf {
    /**
     * Description of the transfer
     * @type {string}
     * @memberof TransferResponseAllOf
     */
    'description': string;
    /**
     *
     * @type {Dinero}
     * @memberof TransferResponseAllOf
     */
    'amount': Dinero;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransferResponseAllOf
     */
    'from'?: BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransferResponseAllOf
     */
    'to'?: BaseUserResponse;
    /**
     *
     * @type {BaseInvoiceResponse}
     * @memberof TransferResponseAllOf
     */
    'invoice'?: BaseInvoiceResponse;
    /**
     *
     * @type {StripeDepositResponse}
     * @memberof TransferResponseAllOf
     */
    'deposit'?: StripeDepositResponse;
    /**
     *
     * @type {BasePayoutRequestResponse}
     * @memberof TransferResponseAllOf
     */
    'payoutRequest'?: BasePayoutRequestResponse;
}
/**
 *
 * @export
 * @interface UpdateContainerRequest
 */
export interface UpdateContainerRequest {
    /**
     * Name of the container
     * @type {string}
     * @memberof UpdateContainerRequest
     */
    'name': string;
    /**
     *
     * @type {Array<number>}
     * @memberof UpdateContainerRequest
     */
    'products': Array<number>;
    /**
     * Whether the container is public or not
     * @type {boolean}
     * @memberof UpdateContainerRequest
     */
    'public': boolean;
}
/**
 *
 * @export
 * @interface UpdateInvoiceRequest
 */
export interface UpdateInvoiceRequest {
    /**
     * The user who updates the Invoice, defaults to the ID of the requester.
     * @type {number}
     * @memberof UpdateInvoiceRequest
     */
    'byId'?: number;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'addressee': string;
    /**
     * The description of the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'description': string;
    /**
     * The state to set of the invoice,    can be either CREATED, SENT, PAID or DELETED.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'state'?: string;
}
/**
 *
 * @export
 * @interface UpdateKeyResponse
 */
export interface UpdateKeyResponse {
    /**
     * The key to return
     * @type {string}
     * @memberof UpdateKeyResponse
     */
    'key': string;
}
/**
 *
 * @export
 * @interface UpdateLocalRequest
 */
export interface UpdateLocalRequest {
    /**
     * The password to set
     * @type {string}
     * @memberof UpdateLocalRequest
     */
    'password': string;
}
/**
 *
 * @export
 * @interface UpdateNfcRequest
 */
export interface UpdateNfcRequest {
    /**
     * The NFC code to set
     * @type {string}
     * @memberof UpdateNfcRequest
     */
    'nfcCode': string;
}
/**
 *
 * @export
 * @interface UpdatePinRequest
 */
export interface UpdatePinRequest {
    /**
     * The PIN code to set
     * @type {string}
     * @memberof UpdatePinRequest
     */
    'pin': string;
}
/**
 *
 * @export
 * @interface UpdatePointOfSaleRequest
 */
export interface UpdatePointOfSaleRequest {
    /**
     * Name of the POS
     * @type {string}
     * @memberof UpdatePointOfSaleRequest
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof UpdatePointOfSaleRequest
     */
    'useAuthentication': boolean;
    /**
     *
     * @type {Array<number>}
     * @memberof UpdatePointOfSaleRequest
     */
    'containers'?: Array<number>;
    /**
     * ID of the POS to update.
     * @type {number}
     * @memberof UpdatePointOfSaleRequest
     */
    'id': number;
}
/**
 *
 * @export
 * @interface UpdateProductRequest
 */
export interface UpdateProductRequest {
    /**
     * Name of the product
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'name': string;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof UpdateProductRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * VAT group ID of the product
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'vat': number;
    /**
     * Category of the product
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'category': number;
    /**
     * Alcohol percentage of the product in 2 decimals
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'alcoholPercentage': number;
}
/**
 *
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstName'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'lastName'?: string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'active'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'ofAge'?: boolean;
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'deleted'?: boolean;
}
/**
 *
 * @export
 * @interface UpdateVatGroupRequest
 */
export interface UpdateVatGroupRequest {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof UpdateVatGroupRequest
     */
    'name': string;
    /**
     * Whether this group should be hidden in the financial overviews when its value is zero
     * @type {boolean}
     * @memberof UpdateVatGroupRequest
     */
    'deleted': boolean;
    /**
     * Whether this group should be hidden from transactions
     * @type {boolean}
     * @memberof UpdateVatGroupRequest
     */
    'hidden': boolean;
}
/**
 *
 * @export
 * @interface UpdatedContainer
 */
export interface UpdatedContainer {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof UpdatedContainer
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof UpdatedContainer
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof UpdatedContainer
     */
    'version'?: number;
    /**
     * The unique name of the container.
     * @type {string}
     * @memberof UpdatedContainer
     */
    'name': string;
    /**
     *
     * @type {Container}
     * @memberof UpdatedContainer
     */
    'container': Container;
    /**
     *
     * @type {Array<Product>}
     * @memberof UpdatedContainer
     */
    'products': Array<Product>;
}
/**
 *
 * @export
 * @interface UpdatedContainerAllOf
 */
export interface UpdatedContainerAllOf {
    /**
     *
     * @type {Container}
     * @memberof UpdatedContainerAllOf
     */
    'container': Container;
    /**
     *
     * @type {Array<Product>}
     * @memberof UpdatedContainerAllOf
     */
    'products': Array<Product>;
}
/**
 *
 * @export
 * @interface UpdatedPointOfSale
 */
export interface UpdatedPointOfSale {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof UpdatedPointOfSale
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof UpdatedPointOfSale
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof UpdatedPointOfSale
     */
    'version'?: number;
    /**
     * The unique name of the pointOfSale.
     * @type {string}
     * @memberof UpdatedPointOfSale
     */
    'name': string;
    /**
     *
     * @type {PointOfSale}
     * @memberof UpdatedPointOfSale
     */
    'pointOfSale': PointOfSale;
    /**
     *
     * @type {Array<Container>}
     * @memberof UpdatedPointOfSale
     */
    'containers': Array<Container>;
}
/**
 *
 * @export
 * @interface UpdatedPointOfSaleAllOf
 */
export interface UpdatedPointOfSaleAllOf {
    /**
     *
     * @type {PointOfSale}
     * @memberof UpdatedPointOfSaleAllOf
     */
    'pointOfSale': PointOfSale;
    /**
     *
     * @type {Array<Container>}
     * @memberof UpdatedPointOfSaleAllOf
     */
    'containers': Array<Container>;
}
/**
 *
 * @export
 * @interface UpdatedPointOfSaleResponse
 */
export interface UpdatedPointOfSaleResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof UpdatedPointOfSaleResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof UpdatedPointOfSaleResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof UpdatedPointOfSaleResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof UpdatedPointOfSaleResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof UpdatedPointOfSaleResponse
     */
    'name': string;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof UpdatedPointOfSaleResponse
     */
    'owner': BaseUserResponse;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof UpdatedPointOfSaleResponse
     */
    'useAuthentication': boolean;
}
/**
 *
 * @export
 * @interface UpdatedPointOfSaleResponseAllOf
 */
export interface UpdatedPointOfSaleResponseAllOf {
    /**
     *
     * @type {BaseUserResponse}
     * @memberof UpdatedPointOfSaleResponseAllOf
     */
    'owner': BaseUserResponse;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof UpdatedPointOfSaleResponseAllOf
     */
    'useAuthentication': boolean;
}
/**
 *
 * @export
 * @interface UpdatedPointOfSaleWithContainersResponse
 */
export interface UpdatedPointOfSaleWithContainersResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof UpdatedPointOfSaleWithContainersResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof UpdatedPointOfSaleWithContainersResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof UpdatedPointOfSaleWithContainersResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof UpdatedPointOfSaleWithContainersResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof UpdatedPointOfSaleWithContainersResponse
     */
    'name': string;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof UpdatedPointOfSaleWithContainersResponse
     */
    'owner': BaseUserResponse;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof UpdatedPointOfSaleWithContainersResponse
     */
    'useAuthentication': boolean;
    /**
     *
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof UpdatedPointOfSaleWithContainersResponse
     */
    'containers': Array<ContainerWithProductsResponse>;
}
/**
 *
 * @export
 * @interface UpdatedProduct
 */
export interface UpdatedProduct {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof UpdatedProduct
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof UpdatedProduct
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof UpdatedProduct
     */
    'version'?: number;
    /**
     * The unique name of the product.
     * @type {string}
     * @memberof UpdatedProduct
     */
    'name': string;
    /**
     *
     * @type {Dinero}
     * @memberof UpdatedProduct
     */
    'price': Dinero;
    /**
     *
     * @type {Product}
     * @memberof UpdatedProduct
     */
    'product': Product;
}
/**
 *
 * @export
 * @interface UpdatedProductAllOf
 */
export interface UpdatedProductAllOf {
    /**
     *
     * @type {Product}
     * @memberof UpdatedProductAllOf
     */
    'product': Product;
}
/**
 *
 * @export
 * @interface UpdatedProductResponse
 */
export interface UpdatedProductResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof UpdatedProductResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof UpdatedProductResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof UpdatedProductResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof UpdatedProductResponse
     */
    'version'?: number;
    /**
     * The name of the product.
     * @type {string}
     * @memberof UpdatedProductResponse
     */
    'name': string;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof UpdatedProductResponse
     */
    'priceInclVat': DineroObjectResponse;
    /**
     *
     * @type {BaseVatGroupResponse}
     * @memberof UpdatedProductResponse
     */
    'vat': BaseVatGroupResponse;
    /**
     * The revision of the product.
     * @type {number}
     * @memberof UpdatedProductResponse
     */
    'revision': number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof UpdatedProductResponse
     */
    'owner': BaseUserResponse;
    /**
     *
     * @type {ProductCategoryResponse}
     * @memberof UpdatedProductResponse
     */
    'category': ProductCategoryResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof UpdatedProductResponse
     */
    'priceExclVat': DineroObjectResponse;
    /**
     * The URL to the picture representing this product.
     * @type {string}
     * @memberof UpdatedProductResponse
     */
    'image': string;
    /**
     * The percentage of alcohol in this product.
     * @type {number}
     * @memberof UpdatedProductResponse
     */
    'alcoholPercentage': number;
}
/**
 *
 * @export
 * @interface UpdatedProductResponseAllOf
 */
export interface UpdatedProductResponseAllOf {
    /**
     * The revision of the product.
     * @type {number}
     * @memberof UpdatedProductResponseAllOf
     */
    'revision': number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof UpdatedProductResponseAllOf
     */
    'owner': BaseUserResponse;
    /**
     *
     * @type {ProductCategoryResponse}
     * @memberof UpdatedProductResponseAllOf
     */
    'category': ProductCategoryResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof UpdatedProductResponseAllOf
     */
    'priceExclVat': DineroObjectResponse;
    /**
     * The URL to the picture representing this product.
     * @type {string}
     * @memberof UpdatedProductResponseAllOf
     */
    'image': string;
    /**
     * The percentage of alcohol in this product.
     * @type {number}
     * @memberof UpdatedProductResponseAllOf
     */
    'alcoholPercentage': number;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof User
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * First name of the user.
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * Last name of the user.
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * Whether the user has accepted the TOS. Defaults to false.
     * @type {boolean}
     * @memberof User
     */
    'active'?: boolean;
    /**
     * Whether the user is 18+ or not.
     * @type {boolean}
     * @memberof User
     */
    'ofAge'?: boolean;
    /**
     * The email of the user.
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * Whether the user was deleted. Defaults to false.
     * @type {boolean}
     * @memberof User
     */
    'deleted'?: boolean;
    /**
     * The type of user.
     * @type {string}
     * @memberof User
     */
    'type': string;
}
/**
 *
 * @export
 * @interface UserAllOf
 */
export interface UserAllOf {
    /**
     * First name of the user.
     * @type {string}
     * @memberof UserAllOf
     */
    'firstName': string;
    /**
     * Last name of the user.
     * @type {string}
     * @memberof UserAllOf
     */
    'lastName'?: string;
    /**
     * Whether the user has accepted the TOS. Defaults to false.
     * @type {boolean}
     * @memberof UserAllOf
     */
    'active'?: boolean;
    /**
     * Whether the user is 18+ or not.
     * @type {boolean}
     * @memberof UserAllOf
     */
    'ofAge'?: boolean;
    /**
     * The email of the user.
     * @type {string}
     * @memberof UserAllOf
     */
    'email'?: string;
    /**
     * Whether the user was deleted. Defaults to false.
     * @type {boolean}
     * @memberof UserAllOf
     */
    'deleted'?: boolean;
    /**
     * The type of user.
     * @type {string}
     * @memberof UserAllOf
     */
    'type': string;
}
/**
 *
 * @export
 * @interface UserBorrelkaartGroup
 */
export interface UserBorrelkaartGroup {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof UserBorrelkaartGroup
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof UserBorrelkaartGroup
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof UserBorrelkaartGroup
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof UserBorrelkaartGroup
     */
    'id': number;
    /**
     *
     * @type {User}
     * @memberof UserBorrelkaartGroup
     */
    'user': User;
    /**
     *
     * @type {BorrelkaartGroup}
     * @memberof UserBorrelkaartGroup
     */
    'borrelkaartGroup': BorrelkaartGroup;
}
/**
 *
 * @export
 * @interface UserBorrelkaartGroupAllOf
 */
export interface UserBorrelkaartGroupAllOf {
    /**
     *
     * @type {User}
     * @memberof UserBorrelkaartGroupAllOf
     */
    'user': User;
    /**
     *
     * @type {BorrelkaartGroup}
     * @memberof UserBorrelkaartGroupAllOf
     */
    'borrelkaartGroup': BorrelkaartGroup;
}
/**
 *
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof UserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof UserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof UserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof UserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof UserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof UserResponse
     */
    'lastName': string;
    /**
     * Whether the user activated
     * @type {boolean}
     * @memberof UserResponse
     */
    'active': boolean;
    /**
     * Whether the user is deleted
     * @type {boolean}
     * @memberof UserResponse
     */
    'deleted': boolean;
    /**
     * The type of user
     * @type {string}
     * @memberof UserResponse
     */
    'type': string;
    /**
     * If local user, the e-mail of the user
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * Whether this user has accepted the TOS
     * @type {string}
     * @memberof UserResponse
     */
    'acceptedToS'?: string;
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof UserResponse
     */
    'extensiveDataProcessing'?: boolean;
    /**
     * Whether someone is old enough to drink beer
     * @type {boolean}
     * @memberof UserResponse
     */
    'ofAge'?: boolean;
}
/**
 *
 * @export
 * @interface UserResponseAllOf
 */
export interface UserResponseAllOf {
    /**
     * Whether the user activated
     * @type {boolean}
     * @memberof UserResponseAllOf
     */
    'active': boolean;
    /**
     * Whether the user is deleted
     * @type {boolean}
     * @memberof UserResponseAllOf
     */
    'deleted': boolean;
    /**
     * The type of user
     * @type {string}
     * @memberof UserResponseAllOf
     */
    'type': string;
    /**
     * If local user, the e-mail of the user
     * @type {string}
     * @memberof UserResponseAllOf
     */
    'email'?: string;
    /**
     * Whether this user has accepted the TOS
     * @type {string}
     * @memberof UserResponseAllOf
     */
    'acceptedToS'?: string;
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof UserResponseAllOf
     */
    'extensiveDataProcessing'?: boolean;
    /**
     * Whether someone is old enough to drink beer
     * @type {boolean}
     * @memberof UserResponseAllOf
     */
    'ofAge'?: boolean;
}
/**
 *
 * @export
 * @interface VatDeclarationResponse
 */
export interface VatDeclarationResponse {
    /**
     * Calendar year of this result table
     * @type {number}
     * @memberof VatDeclarationResponse
     */
    'calendarYear': number;
    /**
     * The used VAT declaration period the rows below are based upon
     * @type {string}
     * @memberof VatDeclarationResponse
     */
    'period': string;
    /**
     *
     * @type {Array<VatDeclarationRow>}
     * @memberof VatDeclarationResponse
     */
    'rows': Array<VatDeclarationRow>;
}
/**
 *
 * @export
 * @interface VatDeclarationRow
 */
export interface VatDeclarationRow {
    /**
     * ID of the VAT group
     * @type {number}
     * @memberof VatDeclarationRow
     */
    'id': number;
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatDeclarationRow
     */
    'name': string;
    /**
     * Percentage of VAT in this group
     * @type {number}
     * @memberof VatDeclarationRow
     */
    'percentage': number;
    /**
     *
     * @type {Array<DineroObject>}
     * @memberof VatDeclarationRow
     */
    'values': Array<DineroObject>;
}
/**
 *
 * @export
 * @interface VatGroup
 */
export interface VatGroup {
    /**
     * The creation date of the object.
     * @type {string}
     * @memberof VatGroup
     */
    'createdAt'?: string;
    /**
     * The last update date of the object.
     * @type {string}
     * @memberof VatGroup
     */
    'updatedAt'?: string;
    /**
     * The current version of the object.
     * @type {number}
     * @memberof VatGroup
     */
    'version'?: number;
    /**
     * The auto-generated object id.
     * @type {number}
     * @memberof VatGroup
     */
    'id': number;
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroup
     */
    'name'?: string;
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroup
     */
    'percentage'?: number;
    /**
     * Whether this group is soft-deleted
     * @type {boolean}
     * @memberof VatGroup
     */
    'deleted'?: boolean;
    /**
     * Whether this group is hidden from transactions
     * @type {boolean}
     * @memberof VatGroup
     */
    'hidden'?: boolean;
}
/**
 *
 * @export
 * @interface VatGroupAllOf
 */
export interface VatGroupAllOf {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroupAllOf
     */
    'name'?: string;
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroupAllOf
     */
    'percentage'?: number;
    /**
     * Whether this group is soft-deleted
     * @type {boolean}
     * @memberof VatGroupAllOf
     */
    'deleted'?: boolean;
    /**
     * Whether this group is hidden from transactions
     * @type {boolean}
     * @memberof VatGroupAllOf
     */
    'hidden'?: boolean;
}
/**
 *
 * @export
 * @interface VatGroupRequest
 */
export interface VatGroupRequest {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroupRequest
     */
    'name': string;
    /**
     * Whether this group should be hidden in the financial overviews when its value is zero
     * @type {boolean}
     * @memberof VatGroupRequest
     */
    'deleted': boolean;
    /**
     * Whether this group should be hidden from transactions
     * @type {boolean}
     * @memberof VatGroupRequest
     */
    'hidden': boolean;
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroupRequest
     */
    'percentage': number;
}
/**
 *
 * @export
 * @interface VatGroupRequestAllOf
 */
export interface VatGroupRequestAllOf {
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroupRequestAllOf
     */
    'percentage': number;
}
/**
 * AuthenticateApi - axios parameter creator
 * @export
 */
export declare const AuthenticateApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  EAN login and hand out token
     * @param {AuthenticationEanRequest} req The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eanAuthentication: (req: AuthenticationEanRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisLDAPAuthentication: (req: AuthenticationLDAPRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisPinAuthentication: (req: GEWISAuthenticationPinRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisWebAuthentication: (req: GewiswebAuthenticationRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Key login and hand out token.
     * @param {AuthenticationKeyRequest} req The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyAuthentication: (req: AuthenticationKeyRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ldapAuthentication: (req: AuthenticationLDAPRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Local login and hand out token
     * @param {AuthenticationLocalRequest} req The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    localAuthentication: (req: AuthenticationLocalRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Mock login and hand out token.
     * @param {AuthenticationMockRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mockAuthentication: (req: AuthenticationMockRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  NFC login and hand out token
     * @param {AuthenticationNfcRequest} req The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfcAuthentication: (req: AuthenticationNfcRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  PIN login and hand out token
     * @param {AuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pinAuthentication: (req: AuthenticationPinRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Creates a reset token for the local authentication
     * @param {ResetLocalRequest} req The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocal: (req: ResetLocalRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} req The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocalWithToken: (req: AuthenticationResetTokenRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AuthenticateApi - functional programming interface
 * @export
 */
export declare const AuthenticateApiFp: (configuration?: Configuration) => {
    /**
     *  EAN login and hand out token
     * @param {AuthenticationEanRequest} req The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eanAuthentication(req: AuthenticationEanRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisLDAPAuthentication(req: AuthenticationLDAPRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisPinAuthentication(req: GEWISAuthenticationPinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisWebAuthentication(req: GewiswebAuthenticationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  Key login and hand out token.
     * @param {AuthenticationKeyRequest} req The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyAuthentication(req: AuthenticationKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ldapAuthentication(req: AuthenticationLDAPRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  Local login and hand out token
     * @param {AuthenticationLocalRequest} req The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    localAuthentication(req: AuthenticationLocalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  Mock login and hand out token.
     * @param {AuthenticationMockRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mockAuthentication(req: AuthenticationMockRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  NFC login and hand out token
     * @param {AuthenticationNfcRequest} req The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfcAuthentication(req: AuthenticationNfcRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  PIN login and hand out token
     * @param {AuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pinAuthentication(req: AuthenticationPinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  Creates a reset token for the local authentication
     * @param {ResetLocalRequest} req The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocal(req: ResetLocalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *  Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} req The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocalWithToken(req: AuthenticationResetTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * AuthenticateApi - factory interface
 * @export
 */
export declare const AuthenticateApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  EAN login and hand out token
     * @param {AuthenticationEanRequest} req The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eanAuthentication(req: AuthenticationEanRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisLDAPAuthentication(req: AuthenticationLDAPRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisPinAuthentication(req: GEWISAuthenticationPinRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisWebAuthentication(req: GewiswebAuthenticationRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  Key login and hand out token.
     * @param {AuthenticationKeyRequest} req The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyAuthentication(req: AuthenticationKeyRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ldapAuthentication(req: AuthenticationLDAPRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  Local login and hand out token
     * @param {AuthenticationLocalRequest} req The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    localAuthentication(req: AuthenticationLocalRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  Mock login and hand out token.
     * @param {AuthenticationMockRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mockAuthentication(req: AuthenticationMockRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  NFC login and hand out token
     * @param {AuthenticationNfcRequest} req The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfcAuthentication(req: AuthenticationNfcRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  PIN login and hand out token
     * @param {AuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pinAuthentication(req: AuthenticationPinRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  Creates a reset token for the local authentication
     * @param {ResetLocalRequest} req The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocal(req: ResetLocalRequest, options?: any): AxiosPromise<void>;
    /**
     *  Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} req The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocalWithToken(req: AuthenticationResetTokenRequest, options?: any): AxiosPromise<void>;
};
/**
 * AuthenticateApi - object-oriented interface
 * @export
 * @class AuthenticateApi
 * @extends {BaseAPI}
 */
export declare class AuthenticateApi extends BaseAPI {
    /**
     *  EAN login and hand out token
     * @param {AuthenticationEanRequest} req The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    eanAuthentication(req: AuthenticationEanRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisLDAPAuthentication(req: AuthenticationLDAPRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisPinAuthentication(req: GEWISAuthenticationPinRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisWebAuthentication(req: GewiswebAuthenticationRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  Key login and hand out token.
     * @param {AuthenticationKeyRequest} req The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    keyAuthentication(req: AuthenticationKeyRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    ldapAuthentication(req: AuthenticationLDAPRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  Local login and hand out token
     * @param {AuthenticationLocalRequest} req The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    localAuthentication(req: AuthenticationLocalRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  Mock login and hand out token.
     * @param {AuthenticationMockRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    mockAuthentication(req: AuthenticationMockRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  NFC login and hand out token
     * @param {AuthenticationNfcRequest} req The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    nfcAuthentication(req: AuthenticationNfcRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  PIN login and hand out token
     * @param {AuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    pinAuthentication(req: AuthenticationPinRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    refreshToken(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  Creates a reset token for the local authentication
     * @param {ResetLocalRequest} req The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    resetLocal(req: ResetLocalRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *  Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} req The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    resetLocalWithToken(req: AuthenticationResetTokenRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * BalanceApi - axios parameter creator
 * @export
 */
export declare const BalanceApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Get balance of the current user
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
     * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBalance: (date?: string, minBalance?: number, maxBalance?: number, orderBy?: 'id' | 'amount', orderDirection?: 'ASC' | 'DESC', take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceId: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalances: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BalanceApi - functional programming interface
 * @export
 */
export declare const BalanceApiFp: (configuration?: Configuration) => {
    /**
     *  Get balance of the current user
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
     * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBalance(date?: string, minBalance?: number, maxBalance?: number, orderBy?: 'id' | 'amount', orderDirection?: 'ASC' | 'DESC', take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceResponse>>>;
    /**
     *  Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>>;
    /**
     *  Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalances(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>>;
};
/**
 * BalanceApi - factory interface
 * @export
 */
export declare const BalanceApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Get balance of the current user
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
     * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBalance(date?: string, minBalance?: number, maxBalance?: number, orderBy?: 'id' | 'amount', orderDirection?: 'ASC' | 'DESC', take?: number, skip?: number, options?: any): AxiosPromise<Array<BalanceResponse>>;
    /**
     *  Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceId(id: number, options?: any): AxiosPromise<BalanceResponse>;
    /**
     *  Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalances(options?: any): AxiosPromise<BalanceResponse>;
};
/**
 * BalanceApi - object-oriented interface
 * @export
 * @class BalanceApi
 * @extends {BaseAPI}
 */
export declare class BalanceApi extends BaseAPI {
    /**
     *  Get balance of the current user
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
     * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getAllBalance(date?: string, minBalance?: number, maxBalance?: number, orderBy?: 'id' | 'amount', orderDirection?: 'ASC' | 'DESC', take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BalanceResponse[], any>>;
    /**
     *  Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getBalanceId(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BalanceResponse, any>>;
    /**
     *  Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getBalances(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BalanceResponse, any>>;
}
/**
 * BannersApi - axios parameter creator
 * @export
 */
export declare const BannersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Saves a banner to the database
     * @param {BannerRequest} banner The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: (banner: BannerRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActive: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBanners: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOpenBanners: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBanner: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} banner The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: (id: number, banner: BannerRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateImage: (id: number, file?: File, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BannersApi - functional programming interface
 * @export
 */
export declare const BannersApiFp: (configuration?: Configuration) => {
    /**
     *  Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>>;
    /**
     *  Saves a banner to the database
     * @param {BannerRequest} banner The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(banner: BannerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>>;
    /**
     *  Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActive(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>>;
    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBanners(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>>;
    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOpenBanners(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>>;
    /**
     *  Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBanner(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>>;
    /**
     *  Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} banner The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(id: number, banner: BannerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>>;
    /**
     *  Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateImage(id: number, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * BannersApi - factory interface
 * @export
 */
export declare const BannersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(id: number, options?: any): AxiosPromise<BannerResponse>;
    /**
     *  Saves a banner to the database
     * @param {BannerRequest} banner The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(banner: BannerRequest, options?: any): AxiosPromise<BannerResponse>;
    /**
     *  Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActive(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse>;
    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBanners(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse>;
    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOpenBanners(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse>;
    /**
     *  Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBanner(id: number, options?: any): AxiosPromise<BannerResponse>;
    /**
     *  Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} banner The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(id: number, banner: BannerRequest, options?: any): AxiosPromise<BannerResponse>;
    /**
     *  Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateImage(id: number, file?: File, options?: any): AxiosPromise<void>;
};
/**
 * BannersApi - object-oriented interface
 * @export
 * @class BannersApi
 * @extends {BaseAPI}
 */
export declare class BannersApi extends BaseAPI {
    /**
     *  Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    _delete(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BannerResponse, any>>;
    /**
     *  Saves a banner to the database
     * @param {BannerRequest} banner The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    create(banner: BannerRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BannerResponse, any>>;
    /**
     *  Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getActive(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBannerResponse, any>>;
    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getAllBanners(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBannerResponse, any>>;
    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getAllOpenBanners(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBannerResponse, any>>;
    /**
     *  Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getBanner(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BannerResponse, any>>;
    /**
     *  Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} banner The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    update(id: number, banner: BannerRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BannerResponse, any>>;
    /**
     *  Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    updateImage(id: number, file?: File, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * BorrelkaartgroupsApi - axios parameter creator
 * @export
 */
export declare const BorrelkaartgroupsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Creates a new borrelkaart group
     * @param {BorrelkaartGroupRequest} borrelkaartgroup The borrelkaart group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBorrelkaartgroup: (borrelkaartgroup: BorrelkaartGroupRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all existing borrelkaart groups
     * @param {number} [take] How many borrelkaart groups the endpoint should return
     * @param {number} [skip] How many borrelkaart groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getALlBorrelkaartgroups: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the requested borrelkaart group
     * @param {number} id The id of the borrelkaart group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBorrelkaartgroupId: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Updates the requested borrelkaart group
     * @param {number} id The id of the borrelkaart group which should be updated
     * @param {BorrelkaartGroupRequest} borrelkaartgroup The updated borrelkaart group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBorrelkaartGroup: (id: number, borrelkaartgroup: BorrelkaartGroupRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BorrelkaartgroupsApi - functional programming interface
 * @export
 */
export declare const BorrelkaartgroupsApiFp: (configuration?: Configuration) => {
    /**
     *  Creates a new borrelkaart group
     * @param {BorrelkaartGroupRequest} borrelkaartgroup The borrelkaart group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBorrelkaartgroup(borrelkaartgroup: BorrelkaartGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BorrelkaartGroupResponse>>;
    /**
     *  Returns all existing borrelkaart groups
     * @param {number} [take] How many borrelkaart groups the endpoint should return
     * @param {number} [skip] How many borrelkaart groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getALlBorrelkaartgroups(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBorrelkaartGroupResponse>>;
    /**
     *  Returns the requested borrelkaart group
     * @param {number} id The id of the borrelkaart group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBorrelkaartgroupId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BorrelkaartGroupResponse>>;
    /**
     *  Updates the requested borrelkaart group
     * @param {number} id The id of the borrelkaart group which should be updated
     * @param {BorrelkaartGroupRequest} borrelkaartgroup The updated borrelkaart group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBorrelkaartGroup(id: number, borrelkaartgroup: BorrelkaartGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BorrelkaartGroupResponse>>;
};
/**
 * BorrelkaartgroupsApi - factory interface
 * @export
 */
export declare const BorrelkaartgroupsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Creates a new borrelkaart group
     * @param {BorrelkaartGroupRequest} borrelkaartgroup The borrelkaart group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBorrelkaartgroup(borrelkaartgroup: BorrelkaartGroupRequest, options?: any): AxiosPromise<BorrelkaartGroupResponse>;
    /**
     *  Returns all existing borrelkaart groups
     * @param {number} [take] How many borrelkaart groups the endpoint should return
     * @param {number} [skip] How many borrelkaart groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getALlBorrelkaartgroups(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBorrelkaartGroupResponse>;
    /**
     *  Returns the requested borrelkaart group
     * @param {number} id The id of the borrelkaart group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBorrelkaartgroupId(id: number, options?: any): AxiosPromise<BorrelkaartGroupResponse>;
    /**
     *  Updates the requested borrelkaart group
     * @param {number} id The id of the borrelkaart group which should be updated
     * @param {BorrelkaartGroupRequest} borrelkaartgroup The updated borrelkaart group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBorrelkaartGroup(id: number, borrelkaartgroup: BorrelkaartGroupRequest, options?: any): AxiosPromise<BorrelkaartGroupResponse>;
};
/**
 * BorrelkaartgroupsApi - object-oriented interface
 * @export
 * @class BorrelkaartgroupsApi
 * @extends {BaseAPI}
 */
export declare class BorrelkaartgroupsApi extends BaseAPI {
    /**
     *  Creates a new borrelkaart group
     * @param {BorrelkaartGroupRequest} borrelkaartgroup The borrelkaart group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BorrelkaartgroupsApi
     */
    createBorrelkaartgroup(borrelkaartgroup: BorrelkaartGroupRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BorrelkaartGroupResponse, any>>;
    /**
     *  Returns all existing borrelkaart groups
     * @param {number} [take] How many borrelkaart groups the endpoint should return
     * @param {number} [skip] How many borrelkaart groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BorrelkaartgroupsApi
     */
    getALlBorrelkaartgroups(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBorrelkaartGroupResponse, any>>;
    /**
     *  Returns the requested borrelkaart group
     * @param {number} id The id of the borrelkaart group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BorrelkaartgroupsApi
     */
    getBorrelkaartgroupId(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BorrelkaartGroupResponse, any>>;
    /**
     *  Updates the requested borrelkaart group
     * @param {number} id The id of the borrelkaart group which should be updated
     * @param {BorrelkaartGroupRequest} borrelkaartgroup The updated borrelkaart group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BorrelkaartgroupsApi
     */
    updateBorrelkaartGroup(id: number, borrelkaartgroup: BorrelkaartGroupRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BorrelkaartGroupResponse, any>>;
}
/**
 * ContainersApi - axios parameter creator
 * @export
 */
export declare const ContainersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Approve a container update.
     * @param {number} id The id of the container update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveContainer: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Create a new container.
     * @param {CreateContainerRequest} container    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContainer: (container: CreateContainerRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllContainers: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductsContainer: (id: number, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicContainers: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleContainer: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the requested updated container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleUpdatedContainer: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all updated containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdatedContainers: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} container    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContainer: (id: number, container: UpdateContainerRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ContainersApi - functional programming interface
 * @export
 */
export declare const ContainersApiFp: (configuration?: Configuration) => {
    /**
     *  Approve a container update.
     * @param {number} id The id of the container update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveContainer(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>>;
    /**
     *  Create a new container.
     * @param {CreateContainerRequest} container    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContainer(container: CreateContainerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>>;
    /**
     *  Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllContainers(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>>;
    /**
     *  Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductsContainer(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>>;
    /**
     *  Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicContainers(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>>;
    /**
     *  Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleContainer(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>>;
    /**
     *  Returns the requested updated container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleUpdatedContainer(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>>;
    /**
     *  Returns all updated containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdatedContainers(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>>;
    /**
     *  Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} container    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContainer(id: number, container: UpdateContainerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>>;
};
/**
 * ContainersApi - factory interface
 * @export
 */
export declare const ContainersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Approve a container update.
     * @param {number} id The id of the container update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveContainer(id: number, options?: any): AxiosPromise<ContainerWithProductsResponse>;
    /**
     *  Create a new container.
     * @param {CreateContainerRequest} container    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContainer(container: CreateContainerRequest, options?: any): AxiosPromise<ContainerWithProductsResponse>;
    /**
     *  Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllContainers(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse>;
    /**
     *  Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductsContainer(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse>;
    /**
     *  Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicContainers(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse>;
    /**
     *  Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleContainer(id: number, options?: any): AxiosPromise<ContainerWithProductsResponse>;
    /**
     *  Returns the requested updated container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleUpdatedContainer(id: number, options?: any): AxiosPromise<ContainerWithProductsResponse>;
    /**
     *  Returns all updated containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdatedContainers(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse>;
    /**
     *  Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} container    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContainer(id: number, container: UpdateContainerRequest, options?: any): AxiosPromise<ContainerWithProductsResponse>;
};
/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export declare class ContainersApi extends BaseAPI {
    /**
     *  Approve a container update.
     * @param {number} id The id of the container update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    approveContainer(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ContainerWithProductsResponse, any>>;
    /**
     *  Create a new container.
     * @param {CreateContainerRequest} container    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    createContainer(container: CreateContainerRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ContainerWithProductsResponse, any>>;
    /**
     *  Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getAllContainers(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedContainerResponse, any>>;
    /**
     *  Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getProductsContainer(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductResponse, any>>;
    /**
     *  Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getPublicContainers(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedContainerResponse, any>>;
    /**
     *  Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getSingleContainer(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ContainerWithProductsResponse, any>>;
    /**
     *  Returns the requested updated container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getSingleUpdatedContainer(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ContainerWithProductsResponse, any>>;
    /**
     *  Returns all updated containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getUpdatedContainers(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedContainerResponse, any>>;
    /**
     *  Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} container    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    updateContainer(id: number, container: UpdateContainerRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ContainerWithProductsResponse, any>>;
}
/**
 * FilesApi - axios parameter creator
 * @export
 */
export declare const FilesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Upload a file with the given name.
     * @param {File} [file] null
     * @param {string} [name] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile: (file?: File, name?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FilesApi - functional programming interface
 * @export
 */
export declare const FilesApiFp: (configuration?: Configuration) => {
    /**
     *  Upload a file with the given name.
     * @param {File} [file] null
     * @param {string} [name] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile(file?: File, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleFileResponse>>;
    /**
     *  Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *  Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * FilesApi - factory interface
 * @export
 */
export declare const FilesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Upload a file with the given name.
     * @param {File} [file] null
     * @param {string} [name] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile(file?: File, name?: string, options?: any): AxiosPromise<SimpleFileResponse>;
    /**
     *  Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(id: number, options?: any): AxiosPromise<void>;
    /**
     *  Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(id: number, options?: any): AxiosPromise<void>;
};
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export declare class FilesApi extends BaseAPI {
    /**
     *  Upload a file with the given name.
     * @param {File} [file] null
     * @param {string} [name] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    createFile(file?: File, name?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SimpleFileResponse, any>>;
    /**
     *  Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteFile(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *  Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getFile(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export declare const InvoicesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Adds an invoice to the system.
     * @param {CreateInvoiceRequest} invoice The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInvoice: (invoice: CreateInvoiceRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoice: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInvoices: (toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleInvoice: (id: number, returnEntries?: boolean, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} invoice The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInvoice: (id: number, invoice: UpdateInvoiceRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * InvoicesApi - functional programming interface
 * @export
 */
export declare const InvoicesApiFp: (configuration?: Configuration) => {
    /**
     *  Adds an invoice to the system.
     * @param {CreateInvoiceRequest} invoice The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInvoice(invoice: CreateInvoiceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>>;
    /**
     *  Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoice(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseInvoiceResponse>>;
    /**
     *  Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInvoices(toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedInvoiceResponse>>;
    /**
     *  Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleInvoice(id: number, returnEntries?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>>;
    /**
     *  Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} invoice The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInvoice(id: number, invoice: UpdateInvoiceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseInvoiceResponse>>;
};
/**
 * InvoicesApi - factory interface
 * @export
 */
export declare const InvoicesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Adds an invoice to the system.
     * @param {CreateInvoiceRequest} invoice The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInvoice(invoice: CreateInvoiceRequest, options?: any): AxiosPromise<InvoiceResponse>;
    /**
     *  Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoice(id: number, options?: any): AxiosPromise<BaseInvoiceResponse>;
    /**
     *  Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInvoices(toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, options?: any): AxiosPromise<PaginatedInvoiceResponse>;
    /**
     *  Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleInvoice(id: number, returnEntries?: boolean, options?: any): AxiosPromise<InvoiceResponse>;
    /**
     *  Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} invoice The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInvoice(id: number, invoice: UpdateInvoiceRequest, options?: any): AxiosPromise<BaseInvoiceResponse>;
};
/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export declare class InvoicesApi extends BaseAPI {
    /**
     *  Adds an invoice to the system.
     * @param {CreateInvoiceRequest} invoice The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    createInvoice(invoice: CreateInvoiceRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InvoiceResponse, any>>;
    /**
     *  Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    deleteInvoice(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BaseInvoiceResponse, any>>;
    /**
     *  Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getAllInvoices(toId?: number, invoiceId?: number, state?: number, returnEntries?: boolean, fromDate?: string, tillDate?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedInvoiceResponse, any>>;
    /**
     *  Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getSingleInvoice(id: number, returnEntries?: boolean, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InvoiceResponse, any>>;
    /**
     *  Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} invoice The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    updateInvoice(id: number, invoice: UpdateInvoiceRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<BaseInvoiceResponse, any>>;
}
/**
 * PayoutRequestsApi - axios parameter creator
 * @export
 */
export declare const PayoutRequestsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Create a new payout request
     * @param {PayoutRequestRequest} payoutRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayoutRequest: (payoutRequest: PayoutRequestRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all payout requests given the filter parameters
     * @param {string} [requestedById] ID of user(s) who requested a payout
     * @param {string} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPayoutRequests: (requestedById?: string, approvedById?: string, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePayoutRequest: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} state New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPayoutRequestStatus: (id: number, state: PayoutRequestStatusRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * PayoutRequestsApi - functional programming interface
 * @export
 */
export declare const PayoutRequestsApiFp: (configuration?: Configuration) => {
    /**
     *  Create a new payout request
     * @param {PayoutRequestRequest} payoutRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayoutRequest(payoutRequest: PayoutRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>>;
    /**
     *  Returns all payout requests given the filter parameters
     * @param {string} [requestedById] ID of user(s) who requested a payout
     * @param {string} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPayoutRequests(requestedById?: string, approvedById?: string, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBasePayoutRequestResponse>>;
    /**
     *  Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePayoutRequest(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>>;
    /**
     *  Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} state New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPayoutRequestStatus(id: number, state: PayoutRequestStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>>;
};
/**
 * PayoutRequestsApi - factory interface
 * @export
 */
export declare const PayoutRequestsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Create a new payout request
     * @param {PayoutRequestRequest} payoutRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayoutRequest(payoutRequest: PayoutRequestRequest, options?: any): AxiosPromise<PayoutRequestResponse>;
    /**
     *  Returns all payout requests given the filter parameters
     * @param {string} [requestedById] ID of user(s) who requested a payout
     * @param {string} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPayoutRequests(requestedById?: string, approvedById?: string, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBasePayoutRequestResponse>;
    /**
     *  Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePayoutRequest(id: number, options?: any): AxiosPromise<PayoutRequestResponse>;
    /**
     *  Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} state New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPayoutRequestStatus(id: number, state: PayoutRequestStatusRequest, options?: any): AxiosPromise<PayoutRequestResponse>;
};
/**
 * PayoutRequestsApi - object-oriented interface
 * @export
 * @class PayoutRequestsApi
 * @extends {BaseAPI}
 */
export declare class PayoutRequestsApi extends BaseAPI {
    /**
     *  Create a new payout request
     * @param {PayoutRequestRequest} payoutRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    createPayoutRequest(payoutRequest: PayoutRequestRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PayoutRequestResponse, any>>;
    /**
     *  Returns all payout requests given the filter parameters
     * @param {string} [requestedById] ID of user(s) who requested a payout
     * @param {string} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    getAllPayoutRequests(requestedById?: string, approvedById?: string, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBasePayoutRequestResponse, any>>;
    /**
     *  Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    getSinglePayoutRequest(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PayoutRequestResponse, any>>;
    /**
     *  Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} state New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    setPayoutRequestStatus(id: number, state: PayoutRequestStatusRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PayoutRequestResponse, any>>;
}
/**
 * PointofsaleApi - axios parameter creator
 * @export
 */
export declare const PointofsaleApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Approve a Point of Sale update.
     * @param {number} id The id of the Point of Sale update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approvePointOfSale: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPointOfSale: (pointofsale: CreatePointOfSaleRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleContainers: (id: number, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleProducts: (id: number, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointsOfSale: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePointOfSale: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns a single Points of Sale update
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleUpdatedPointOfSale: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns a Point of Sale transactions
     * @param {number} id          The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions: (id: number, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all updated Points of Sale
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdated: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePointOfSale: (id: number, pointofsale: UpdatePointOfSaleRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * PointofsaleApi - functional programming interface
 * @export
 */
export declare const PointofsaleApiFp: (configuration?: Configuration) => {
    /**
     *  Approve a Point of Sale update.
     * @param {number} id The id of the Point of Sale update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approvePointOfSale(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleResponse>>;
    /**
     *  Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPointOfSale(pointofsale: CreatePointOfSaleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatedPointOfSaleResponse>>;
    /**
     *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>>;
    /**
     *  Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>>;
    /**
     *  Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointsOfSale(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPointOfSaleResponse>>;
    /**
     *  Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePointOfSale(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>>;
    /**
     *  Returns a single Points of Sale update
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleUpdatedPointOfSale(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatedPointOfSaleWithContainersResponse>>;
    /**
     *  Returns a Point of Sale transactions
     * @param {number} id          The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>>;
    /**
     *  Returns all updated Points of Sale
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdated(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUpdatedPointOfSaleResponse>>;
    /**
     *  Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePointOfSale(id: number, pointofsale: UpdatePointOfSaleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatedPointOfSaleResponse>>;
};
/**
 * PointofsaleApi - factory interface
 * @export
 */
export declare const PointofsaleApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Approve a Point of Sale update.
     * @param {number} id The id of the Point of Sale update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approvePointOfSale(id: number, options?: any): AxiosPromise<PointOfSaleResponse>;
    /**
     *  Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPointOfSale(pointofsale: CreatePointOfSaleRequest, options?: any): AxiosPromise<UpdatedPointOfSaleResponse>;
    /**
     *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse>;
    /**
     *  Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse>;
    /**
     *  Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointsOfSale(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedPointOfSaleResponse>;
    /**
     *  Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePointOfSale(id: number, options?: any): AxiosPromise<PointOfSaleWithContainersResponse>;
    /**
     *  Returns a single Points of Sale update
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleUpdatedPointOfSale(id: number, options?: any): AxiosPromise<UpdatedPointOfSaleWithContainersResponse>;
    /**
     *  Returns a Point of Sale transactions
     * @param {number} id          The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse>;
    /**
     *  Returns all updated Points of Sale
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdated(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedUpdatedPointOfSaleResponse>;
    /**
     *  Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePointOfSale(id: number, pointofsale: UpdatePointOfSaleRequest, options?: any): AxiosPromise<UpdatedPointOfSaleResponse>;
};
/**
 * PointofsaleApi - object-oriented interface
 * @export
 * @class PointofsaleApi
 * @extends {BaseAPI}
 */
export declare class PointofsaleApi extends BaseAPI {
    /**
     *  Approve a Point of Sale update.
     * @param {number} id The id of the Point of Sale update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    approvePointOfSale(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PointOfSaleResponse, any>>;
    /**
     *  Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    createPointOfSale(pointofsale: CreatePointOfSaleRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UpdatedPointOfSaleResponse, any>>;
    /**
     *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedContainerResponse, any>>;
    /**
     *  Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductResponse, any>>;
    /**
     *  Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointsOfSale(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedPointOfSaleResponse, any>>;
    /**
     *  Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getSinglePointOfSale(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PointOfSaleWithContainersResponse, any>>;
    /**
     *  Returns a single Points of Sale update
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getSingleUpdatedPointOfSale(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UpdatedPointOfSaleWithContainersResponse, any>>;
    /**
     *  Returns a Point of Sale transactions
     * @param {number} id          The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getTransactions(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBaseTransactionResponse, any>>;
    /**
     *  Returns all updated Points of Sale
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getUpdated(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedUpdatedPointOfSaleResponse, any>>;
    /**
     *  Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    updatePointOfSale(id: number, pointofsale: UpdatePointOfSaleRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UpdatedPointOfSaleResponse, any>>;
}
/**
 * ProductCategoriesApi - axios parameter creator
 * @export
 */
export declare const ProductCategoriesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Post a new productCategory.
     * @param {ProductCategoryRequest} productCategory The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProductCategory: (productCategory: ProductCategoryRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all existing productcategories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProductCategories: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProductCategory: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategory The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductCategory: (id: number, productCategory: ProductCategoryRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProductCategoriesApi - functional programming interface
 * @export
 */
export declare const ProductCategoriesApiFp: (configuration?: Configuration) => {
    /**
     *  Post a new productCategory.
     * @param {ProductCategoryRequest} productCategory The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProductCategory(productCategory: ProductCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>>;
    /**
     *  Returns all existing productcategories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProductCategories(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductCategoryResponse>>;
    /**
     *  Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProductCategory(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>>;
    /**
     *  Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategory The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductCategory(id: number, productCategory: ProductCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>>;
};
/**
 * ProductCategoriesApi - factory interface
 * @export
 */
export declare const ProductCategoriesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Post a new productCategory.
     * @param {ProductCategoryRequest} productCategory The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProductCategory(productCategory: ProductCategoryRequest, options?: any): AxiosPromise<ProductCategoryResponse>;
    /**
     *  Returns all existing productcategories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProductCategories(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductCategoryResponse>;
    /**
     *  Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProductCategory(id: number, options?: any): AxiosPromise<ProductCategoryResponse>;
    /**
     *  Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategory The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductCategory(id: number, productCategory: ProductCategoryRequest, options?: any): AxiosPromise<ProductCategoryResponse>;
};
/**
 * ProductCategoriesApi - object-oriented interface
 * @export
 * @class ProductCategoriesApi
 * @extends {BaseAPI}
 */
export declare class ProductCategoriesApi extends BaseAPI {
    /**
     *  Post a new productCategory.
     * @param {ProductCategoryRequest} productCategory The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    createProductCategory(productCategory: ProductCategoryRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductCategoryResponse, any>>;
    /**
     *  Returns all existing productcategories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    getAllProductCategories(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductCategoryResponse, any>>;
    /**
     *  Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    getSingleProductCategory(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductCategoryResponse, any>>;
    /**
     *  Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategory The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    updateProductCategory(id: number, productCategory: ProductCategoryRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductCategoryResponse, any>>;
}
/**
 * ProductsApi - axios parameter creator
 * @export
 */
export declare const ProductsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Approve a product update.
     * @param {number} id The id of the product update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveProduct: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Create a new product.
     * @param {CreateProductRequest} product The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProduct: (product: CreateProductRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProducts: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProduct: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the requested updated product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdateProduct: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all updated products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdatedProducts: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} product The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProduct: (id: number, product: UpdateProductRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductImage: (id: number, file?: File, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProductsApi - functional programming interface
 * @export
 */
export declare const ProductsApiFp: (configuration?: Configuration) => {
    /**
     *  Approve a product update.
     * @param {number} id The id of the product update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveProduct(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>>;
    /**
     *  Create a new product.
     * @param {CreateProductRequest} product The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProduct(product: CreateProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatedProductResponse>>;
    /**
     *  Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProducts(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>>;
    /**
     *  Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProduct(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>>;
    /**
     *  Returns the requested updated product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdateProduct(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>>;
    /**
     *  Returns all updated products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdatedProducts(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>>;
    /**
     *  Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} product The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProduct(id: number, product: UpdateProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>>;
    /**
     *  Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductImage(id: number, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * ProductsApi - factory interface
 * @export
 */
export declare const ProductsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Approve a product update.
     * @param {number} id The id of the product update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveProduct(id: number, options?: any): AxiosPromise<ProductResponse>;
    /**
     *  Create a new product.
     * @param {CreateProductRequest} product The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProduct(product: CreateProductRequest, options?: any): AxiosPromise<UpdatedProductResponse>;
    /**
     *  Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProducts(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse>;
    /**
     *  Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProduct(id: number, options?: any): AxiosPromise<ProductResponse>;
    /**
     *  Returns the requested updated product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdateProduct(id: number, options?: any): AxiosPromise<ProductResponse>;
    /**
     *  Returns all updated products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUpdatedProducts(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse>;
    /**
     *  Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} product The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProduct(id: number, product: UpdateProductRequest, options?: any): AxiosPromise<ProductResponse>;
    /**
     *  Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductImage(id: number, file?: File, options?: any): AxiosPromise<void>;
};
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export declare class ProductsApi extends BaseAPI {
    /**
     *  Approve a product update.
     * @param {number} id The id of the product update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    approveProduct(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductResponse, any>>;
    /**
     *  Create a new product.
     * @param {CreateProductRequest} product The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    createProduct(product: CreateProductRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UpdatedProductResponse, any>>;
    /**
     *  Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getAllProducts(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductResponse, any>>;
    /**
     *  Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getSingleProduct(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductResponse, any>>;
    /**
     *  Returns the requested updated product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getUpdateProduct(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductResponse, any>>;
    /**
     *  Returns all updated products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getUpdatedProducts(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductResponse, any>>;
    /**
     *  Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} product The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    updateProduct(id: number, product: UpdateProductRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductResponse, any>>;
    /**
     *  Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    updateProductImage(id: number, file?: File, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * RbacApi - axios parameter creator
 * @export
 */
export declare const RbacApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Returns all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRoles: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * RbacApi - functional programming interface
 * @export
 */
export declare const RbacApiFp: (configuration?: Configuration) => {
    /**
     *  Returns all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRoles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>>;
};
/**
 * RbacApi - factory interface
 * @export
 */
export declare const RbacApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Returns all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRoles(options?: any): AxiosPromise<Array<RoleResponse>>;
};
/**
 * RbacApi - object-oriented interface
 * @export
 * @class RbacApi
 * @extends {BaseAPI}
 */
export declare class RbacApi extends BaseAPI {
    /**
     *  Returns all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    getAllRoles(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<RoleResponse[], any>>;
}
/**
 * RootApi - axios parameter creator
 * @export
 */
export declare const RootApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Ping the backend to check whether everything is working correctly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * RootApi - functional programming interface
 * @export
 */
export declare const RootApiFp: (configuration?: Configuration) => {
    /**
     *  Ping the backend to check whether everything is working correctly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * RootApi - factory interface
 * @export
 */
export declare const RootApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Ping the backend to check whether everything is working correctly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<void>;
};
/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export declare class RootApi extends BaseAPI {
    /**
     *  Ping the backend to check whether everything is working correctly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    ping(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * StripeApi - axios parameter creator
 * @export
 */
export declare const StripeApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Start the stripe deposit flow
     * @param {StripeRequest} stripe The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deposit: (stripe: StripeRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Webhook for Stripe event updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhook: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * StripeApi - functional programming interface
 * @export
 */
export declare const StripeApiFp: (configuration?: Configuration) => {
    /**
     *  Start the stripe deposit flow
     * @param {StripeRequest} stripe The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deposit(stripe: StripeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentIntentResponse>>;
    /**
     *  Webhook for Stripe event updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * StripeApi - factory interface
 * @export
 */
export declare const StripeApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Start the stripe deposit flow
     * @param {StripeRequest} stripe The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deposit(stripe: StripeRequest, options?: any): AxiosPromise<StripePaymentIntentResponse>;
    /**
     *  Webhook for Stripe event updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhook(options?: any): AxiosPromise<void>;
};
/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export declare class StripeApi extends BaseAPI {
    /**
     *  Start the stripe deposit flow
     * @param {StripeRequest} stripe The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    deposit(stripe: StripeRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<StripePaymentIntentResponse, any>>;
    /**
     *  Webhook for Stripe event updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    webhook(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * TestApi - axios parameter creator
 * @export
 */
export declare const TestApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    helloworld: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TestApi - functional programming interface
 * @export
 */
export declare const TestApiFp: (configuration?: Configuration) => {
    /**
     *  Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    helloworld(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * TestApi - factory interface
 * @export
 */
export declare const TestApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    helloworld(options?: any): AxiosPromise<void>;
};
/**
 * TestApi - object-oriented interface
 * @export
 * @class TestApi
 * @extends {BaseAPI}
 */
export declare class TestApi extends BaseAPI {
    /**
     *  Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    helloworld(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export declare const TransactionsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Creates a new transaction
     * @param {TransactionRequest} transaction The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransaction: (transaction: TransactionRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransaction: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransactions: (fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransaction: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transaction The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTransaction: (id: number, transaction: TransactionRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transaction The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateTransaction: (transaction: TransactionRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TransactionsApi - functional programming interface
 * @export
 */
export declare const TransactionsApiFp: (configuration?: Configuration) => {
    /**
     *  Creates a new transaction
     * @param {TransactionRequest} transaction The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransaction(transaction: TransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>>;
    /**
     *  Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransaction(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>>;
    /**
     *  Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>>;
    /**
     *  Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransaction(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>>;
    /**
     *  Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transaction The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTransaction(id: number, transaction: TransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>>;
    /**
     *  Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transaction The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateTransaction(transaction: TransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * TransactionsApi - factory interface
 * @export
 */
export declare const TransactionsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Creates a new transaction
     * @param {TransactionRequest} transaction The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransaction(transaction: TransactionRequest, options?: any): AxiosPromise<TransactionResponse>;
    /**
     *  Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransaction(id: number, options?: any): AxiosPromise<TransactionResponse>;
    /**
     *  Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse>;
    /**
     *  Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransaction(id: number, options?: any): AxiosPromise<TransactionResponse>;
    /**
     *  Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transaction The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTransaction(id: number, transaction: TransactionRequest, options?: any): AxiosPromise<TransactionResponse>;
    /**
     *  Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transaction The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateTransaction(transaction: TransactionRequest, options?: any): AxiosPromise<void>;
};
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export declare class TransactionsApi extends BaseAPI {
    /**
     *  Creates a new transaction
     * @param {TransactionRequest} transaction The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    createTransaction(transaction: TransactionRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TransactionResponse, any>>;
    /**
     *  Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    deleteTransaction(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TransactionResponse, any>>;
    /**
     *  Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBaseTransactionResponse, any>>;
    /**
     *  Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getSingleTransaction(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TransactionResponse, any>>;
    /**
     *  Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transaction The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    updateTransaction(id: number, transaction: TransactionRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TransactionResponse, any>>;
    /**
     *  Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transaction The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    validateTransaction(transaction: TransactionRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * TransfersApi - axios parameter creator
 * @export
 */
export declare const TransfersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Post a new transfer.
     * @param {TransferRequest} transfer The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer: (transfer: TransferRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransfers: (take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransfer: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TransfersApi - functional programming interface
 * @export
 */
export declare const TransfersApiFp: (configuration?: Configuration) => {
    /**
     *  Post a new transfer.
     * @param {TransferRequest} transfer The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer(transfer: TransferRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferResponse>>;
    /**
     *  Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransfers(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransferResponse>>>;
    /**
     *  Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransfer(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferResponse>>;
};
/**
 * TransfersApi - factory interface
 * @export
 */
export declare const TransfersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Post a new transfer.
     * @param {TransferRequest} transfer The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer(transfer: TransferRequest, options?: any): AxiosPromise<TransferResponse>;
    /**
     *  Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransfers(take?: number, skip?: number, options?: any): AxiosPromise<Array<TransferResponse>>;
    /**
     *  Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransfer(id: number, options?: any): AxiosPromise<TransferResponse>;
};
/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export declare class TransfersApi extends BaseAPI {
    /**
     *  Post a new transfer.
     * @param {TransferRequest} transfer The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createTransfer(transfer: TransferRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TransferResponse, any>>;
    /**
     *  Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getAllTransfers(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TransferResponse[], any>>;
    /**
     *  Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getSingleTransfer(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TransferResponse, any>>;
}
/**
 * UsersApi - axios parameter creator
 * @export
 */
export declare const UsersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptTos: (params: AcceptTosRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticateAs: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Create a new user
     * @param {CreateUserRequest} user The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: (user: CreateUserRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserKey: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserNfc: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {number} [type] {1,2,3,4,5,6,7} - Filter based on user type. Possible values:      1 (MEMBER), 2 (ORGAN), 3 (BORRELKAART), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsers: (take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersOfUserType: (userType: string, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndividualUser: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get an organs members
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganMembers: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAuthenticatable: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserRoles: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersContainers: (id: number, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get all financial mutations of a user.
     * @param {number} id The id of the user to get the mutations from
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersFinancialMutations: (id: number, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersPointsOfSale: (id: number, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProcessingDeposits: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProducts: (id: number, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get an user\'s transactions (from, to or created)
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactions: (id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactionsReport: (id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get an user\'s transfers
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransfers: (id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the user\'s updated containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersUpdatedContainers: (id: number, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the user\'s updated Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersUpdatedPointsOfSale: (id: number, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get an user\'s updated products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersUpdatedProducts: (id: number, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} user The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: (id: number, user: UpdateUserRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserKey: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} update    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserLocalPassword: (id: number, update: UpdateLocalRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} update    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserNfc: (id: number, update: UpdateNfcRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} update    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPin: (id: number, update: UpdatePinRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UsersApi - functional programming interface
 * @export
 */
export declare const UsersApiFp: (configuration?: Configuration) => {
    /**
     *  Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptTos(params: AcceptTosRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *  Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticateAs(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *  Create a new user
     * @param {CreateUserRequest} user The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(user: CreateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>>;
    /**
     *  Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *  Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *  Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserNfc(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *  Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {number} [type] {1,2,3,4,5,6,7} - Filter based on user type. Possible values:      1 (MEMBER), 2 (ORGAN), 3 (BORRELKAART), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>>;
    /**
     *  Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>>;
    /**
     *  Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndividualUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>>;
    /**
     *  Get an organs members
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganMembers(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>>;
    /**
     *  Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAuthenticatable(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>>;
    /**
     *  Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserRoles(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>>;
    /**
     *  Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersContainers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>>;
    /**
     *  Get all financial mutations of a user.
     * @param {number} id The id of the user to get the mutations from
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFinancialMutationResponse>>;
    /**
     *  Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPointOfSaleResponse>>;
    /**
     *  Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProcessingDeposits(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>>;
    /**
     *  Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProducts(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>>;
    /**
     *  Get an user\'s transactions (from, to or created)
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>>;
    /**
     *  Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionReportResponse>>>;
    /**
     *  Get an user\'s transfers
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTransferResponse>>;
    /**
     *  Returns the user\'s updated containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersUpdatedContainers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>>;
    /**
     *  Returns the user\'s updated Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersUpdatedPointsOfSale(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUpdatedPointOfSaleResponse>>;
    /**
     *  Get an user\'s updated products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersUpdatedProducts(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>>;
    /**
     *  Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} user The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(id: number, user: UpdateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserRequest>>;
    /**
     *  POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateKeyResponse>>;
    /**
     *  Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} update    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserLocalPassword(id: number, update: UpdateLocalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *  Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} update    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserNfc(id: number, update: UpdateNfcRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *  Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} update    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPin(id: number, update: UpdatePinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UsersApi - factory interface
 * @export
 */
export declare const UsersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptTos(params: AcceptTosRequest, options?: any): AxiosPromise<void>;
    /**
     *  Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticateAs(id: number, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *  Create a new user
     * @param {CreateUserRequest} user The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(user: CreateUserRequest, options?: any): AxiosPromise<User>;
    /**
     *  Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(id: number, options?: any): AxiosPromise<void>;
    /**
     *  Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserKey(id: number, options?: any): AxiosPromise<void>;
    /**
     *  Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserNfc(id: number, options?: any): AxiosPromise<void>;
    /**
     *  Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {number} [type] {1,2,3,4,5,6,7} - Filter based on user type. Possible values:      1 (MEMBER), 2 (ORGAN), 3 (BORRELKAART), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: number, options?: any): AxiosPromise<PaginatedUserResponse>;
    /**
     *  Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedUserResponse>;
    /**
     *  Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndividualUser(id: number, options?: any): AxiosPromise<UserResponse>;
    /**
     *  Get an organs members
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganMembers(id: number, options?: any): AxiosPromise<PaginatedUserResponse>;
    /**
     *  Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAuthenticatable(id: number, options?: any): AxiosPromise<Array<UserResponse>>;
    /**
     *  Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserRoles(id: number, options?: any): AxiosPromise<Array<RoleResponse>>;
    /**
     *  Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersContainers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse>;
    /**
     *  Get all financial mutations of a user.
     * @param {number} id The id of the user to get the mutations from
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedFinancialMutationResponse>;
    /**
     *  Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedPointOfSaleResponse>;
    /**
     *  Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProcessingDeposits(id: number, options?: any): AxiosPromise<Array<RoleResponse>>;
    /**
     *  Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProducts(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse>;
    /**
     *  Get an user\'s transactions (from, to or created)
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse>;
    /**
     *  Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, options?: any): AxiosPromise<Array<TransactionReportResponse>>;
    /**
     *  Get an user\'s transfers
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: any): AxiosPromise<PaginatedTransferResponse>;
    /**
     *  Returns the user\'s updated containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersUpdatedContainers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse>;
    /**
     *  Returns the user\'s updated Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersUpdatedPointsOfSale(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedUpdatedPointOfSaleResponse>;
    /**
     *  Get an user\'s updated products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersUpdatedProducts(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse>;
    /**
     *  Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} user The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(id: number, user: UpdateUserRequest, options?: any): AxiosPromise<UpdateUserRequest>;
    /**
     *  POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserKey(id: number, options?: any): AxiosPromise<UpdateKeyResponse>;
    /**
     *  Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} update    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserLocalPassword(id: number, update: UpdateLocalRequest, options?: any): AxiosPromise<void>;
    /**
     *  Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} update    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserNfc(id: number, update: UpdateNfcRequest, options?: any): AxiosPromise<void>;
    /**
     *  Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} update    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPin(id: number, update: UpdatePinRequest, options?: any): AxiosPromise<void>;
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export declare class UsersApi extends BaseAPI {
    /**
     *  Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    acceptTos(params: AcceptTosRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *  Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    authenticateAs(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *  Create a new user
     * @param {CreateUserRequest} user The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    createUser(user: CreateUserRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<User, any>>;
    /**
     *  Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUser(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *  Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUserKey(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *  Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUserNfc(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *  Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {number} [type] {1,2,3,4,5,6,7} - Filter based on user type. Possible values:      1 (MEMBER), 2 (ORGAN), 3 (BORRELKAART), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedUserResponse, any>>;
    /**
     *  Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedUserResponse, any>>;
    /**
     *  Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getIndividualUser(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UserResponse, any>>;
    /**
     *  Get an organs members
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getOrganMembers(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedUserResponse, any>>;
    /**
     *  Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserAuthenticatable(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UserResponse[], any>>;
    /**
     *  Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserRoles(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<RoleResponse[], any>>;
    /**
     *  Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersContainers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedContainerResponse, any>>;
    /**
     *  Get all financial mutations of a user.
     * @param {number} id The id of the user to get the mutations from
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedFinancialMutationResponse, any>>;
    /**
     *  Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedPointOfSaleResponse, any>>;
    /**
     *  Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersProcessingDeposits(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<RoleResponse[], any>>;
    /**
     *  Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersProducts(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductResponse, any>>;
    /**
     *  Get an user\'s transactions (from, to or created)
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBaseTransactionResponse, any>>;
    /**
     *  Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<TransactionReportResponse[], any>>;
    /**
     *  Get an user\'s transfers
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedTransferResponse, any>>;
    /**
     *  Returns the user\'s updated containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersUpdatedContainers(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedContainerResponse, any>>;
    /**
     *  Returns the user\'s updated Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersUpdatedPointsOfSale(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedUpdatedPointOfSaleResponse, any>>;
    /**
     *  Get an user\'s updated products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersUpdatedProducts(id: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductResponse, any>>;
    /**
     *  Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} user The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUser(id: number, user: UpdateUserRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UpdateUserRequest, any>>;
    /**
     *  POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserKey(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UpdateKeyResponse, any>>;
    /**
     *  Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} update    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserLocalPassword(id: number, update: UpdateLocalRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *  Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} update    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserNfc(id: number, update: UpdateNfcRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *  Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} update    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserPin(id: number, update: UpdatePinRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * VatGroupsApi - axios parameter creator
 * @export
 */
export declare const VatGroupsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  Create a new VAT group
     * @param {VatGroupRequest} vatGroup The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVatGroup: (vatGroup: VatGroupRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVatGroups: (vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleVatGroup: (id: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVatDeclarationAmounts: (year: number, period: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *  Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} vatGroup The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVatGroup: (id: number, vatGroup: UpdateVatGroupRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * VatGroupsApi - functional programming interface
 * @export
 */
export declare const VatGroupsApiFp: (configuration?: Configuration) => {
    /**
     *  Create a new VAT group
     * @param {VatGroupRequest} vatGroup The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVatGroup(vatGroup: VatGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroup>>;
    /**
     *  Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVatGroupResponse>>;
    /**
     *  Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleVatGroup(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroup>>;
    /**
     *  Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVatDeclarationAmounts(year: number, period: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVatGroupResponse>>;
    /**
     *  Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} vatGroup The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVatGroup(id: number, vatGroup: UpdateVatGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroup>>;
};
/**
 * VatGroupsApi - factory interface
 * @export
 */
export declare const VatGroupsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  Create a new VAT group
     * @param {VatGroupRequest} vatGroup The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVatGroup(vatGroup: VatGroupRequest, options?: any): AxiosPromise<VatGroup>;
    /**
     *  Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedVatGroupResponse>;
    /**
     *  Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleVatGroup(id: number, options?: any): AxiosPromise<VatGroup>;
    /**
     *  Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVatDeclarationAmounts(year: number, period: string, options?: any): AxiosPromise<PaginatedVatGroupResponse>;
    /**
     *  Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} vatGroup The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVatGroup(id: number, vatGroup: UpdateVatGroupRequest, options?: any): AxiosPromise<VatGroup>;
};
/**
 * VatGroupsApi - object-oriented interface
 * @export
 * @class VatGroupsApi
 * @extends {BaseAPI}
 */
export declare class VatGroupsApi extends BaseAPI {
    /**
     *  Create a new VAT group
     * @param {VatGroupRequest} vatGroup The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    createVatGroup(vatGroup: VatGroupRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<VatGroup, any>>;
    /**
     *  Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedVatGroupResponse, any>>;
    /**
     *  Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getSingleVatGroup(id: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<VatGroup, any>>;
    /**
     *  Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getVatDeclarationAmounts(year: number, period: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedVatGroupResponse, any>>;
    /**
     *  Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} vatGroup The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    updateVatGroup(id: number, vatGroup: UpdateVatGroupRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<VatGroup, any>>;
}
