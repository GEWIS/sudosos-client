/**
 * sudosos-back-end
 * SudoSOS
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import type { RequestArgs } from './base';
import { BaseAPI } from './base';
/**
 *
 * @export
 * @interface AcceptTosRequest
 */
export interface AcceptTosRequest {
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof AcceptTosRequest
     */
    'extensiveDataProcessing': boolean;
}
/**
 *
 * @export
 * @interface ActionResponse
 */
export interface ActionResponse {
    /**
     * The name of the action performed on the entity.
     * @type {string}
     * @memberof ActionResponse
     */
    'action': string;
    /**
     * The ownership relations with permissions.
     * @type {Array<RelationResponse>}
     * @memberof ActionResponse
     */
    'relations': Array<RelationResponse>;
}
/**
 *
 * @export
 * @interface AuthenticationEanRequest
 */
export interface AuthenticationEanRequest {
    /**
     *
     * @type {string}
     * @memberof AuthenticationEanRequest
     */
    'eanCode': string;
}
/**
 *
 * @export
 * @interface AuthenticationKeyRequest
 */
export interface AuthenticationKeyRequest {
    /**
     *
     * @type {number}
     * @memberof AuthenticationKeyRequest
     */
    'userId': number;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationKeyRequest
     */
    'key': string;
}
/**
 *
 * @export
 * @interface AuthenticationLDAPRequest
 */
export interface AuthenticationLDAPRequest {
    /**
     * The AD account name to authenticate
     * @type {string}
     * @memberof AuthenticationLDAPRequest
     */
    'accountName': string;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationLDAPRequest
     */
    'password': string;
}
/**
 *
 * @export
 * @interface AuthenticationLocalRequest
 */
export interface AuthenticationLocalRequest {
    /**
     * The users mail to authenticate
     * @type {string}
     * @memberof AuthenticationLocalRequest
     */
    'accountMail': string;
    /**
     * The password
     * @type {string}
     * @memberof AuthenticationLocalRequest
     */
    'password': string;
}
/**
 *
 * @export
 * @interface AuthenticationMockRequest
 */
export interface AuthenticationMockRequest {
    /**
     *
     * @type {number}
     * @memberof AuthenticationMockRequest
     */
    'userId': number;
    /**
     *
     * @type {string}
     * @memberof AuthenticationMockRequest
     */
    'nonce': string;
}
/**
 *
 * @export
 * @interface AuthenticationNfcRequest
 */
export interface AuthenticationNfcRequest {
    /**
     *
     * @type {string}
     * @memberof AuthenticationNfcRequest
     */
    'nfcCode': string;
}
/**
 *
 * @export
 * @interface AuthenticationPinRequest
 */
export interface AuthenticationPinRequest {
    /**
     *
     * @type {number}
     * @memberof AuthenticationPinRequest
     */
    'userId': number;
    /**
     *
     * @type {string}
     * @memberof AuthenticationPinRequest
     */
    'pin': string;
}
/**
 *
 * @export
 * @interface AuthenticationResetTokenRequest
 */
export interface AuthenticationResetTokenRequest {
    /**
     * The mail of the user
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'accountMail': string;
    /**
     * The reset token passcode
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'token': string;
    /**
     * The new password to set
     * @type {string}
     * @memberof AuthenticationResetTokenRequest
     */
    'password': string;
}
/**
 *
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     *
     * @type {UserResponse}
     * @memberof AuthenticationResponse
     */
    'user': UserResponse;
    /**
     * The RBAC roles that the user has.
     * @type {Array<string>}
     * @memberof AuthenticationResponse
     */
    'roles': Array<string>;
    /**
     * The organs that the user is a member of.
     * @type {Array<UserResponse>}
     * @memberof AuthenticationResponse
     */
    'organs': Array<UserResponse>;
    /**
     * The JWT token that can be used as Bearer token for authentication.
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'token': string;
    /**
     * Whether the related user has accepted the Terms of Service  or is not required to.
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'acceptedToS': string;
}
/**
 *
 * @export
 * @interface BalanceResponse
 */
export interface BalanceResponse {
    /**
     * ID of the user this balance belongs to
     * @type {number}
     * @memberof BalanceResponse
     */
    'id': number;
    /**
     * Date at which this user had this balance
     * @type {string}
     * @memberof BalanceResponse
     */
    'date': string;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof BalanceResponse
     */
    'amount': DineroObjectResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof BalanceResponse
     */
    'fine'?: DineroObjectResponse;
    /**
     * Timestamp of the first fine
     * @type {string}
     * @memberof BalanceResponse
     */
    'fineSince'?: string;
    /**
     * The ID of the last transaction that was present when the balance was cached
     * @type {number}
     * @memberof BalanceResponse
     */
    'lastTransactionId'?: number;
    /**
     * The ID of the last transfer that was present when the balance was cached
     * @type {number}
     * @memberof BalanceResponse
     */
    'lastTransferId'?: number;
}
/**
 *
 * @export
 * @interface BannerRequest
 */
export interface BannerRequest {
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerRequest
     */
    'name'?: string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerRequest
     */
    'duration'?: number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerRequest
     */
    'active'?: boolean;
    /**
     * The starting date from which the advertisement should be shown
     * @type {string}
     * @memberof BannerRequest
     */
    'startDate'?: string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerRequest
     */
    'endDate'?: string;
}
/**
 *
 * @export
 * @interface BannerResponse
 */
export interface BannerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BannerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BannerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BannerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BannerResponse
     */
    'version'?: number;
    /**
     * Name/label of the banner
     * @type {string}
     * @memberof BannerResponse
     */
    'name': string;
    /**
     * Location of the image
     * @type {string}
     * @memberof BannerResponse
     */
    'image'?: string;
    /**
     * How long the banner should be shown (in seconds)
     * @type {number}
     * @memberof BannerResponse
     */
    'duration': number;
    /**
     * Whether the banner is active. Overrides start and end date
     * @type {boolean}
     * @memberof BannerResponse
     */
    'active': boolean;
    /**
     * The starting date from which the banner should be shown
     * @type {string}
     * @memberof BannerResponse
     */
    'startDate': string;
    /**
     * The end date from which the banner should no longer be shown
     * @type {string}
     * @memberof BannerResponse
     */
    'endDate': string;
}
/**
 *
 * @export
 * @interface BaseContainerResponse
 */
export interface BaseContainerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof BaseContainerResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof BaseContainerResponse
     */
    'public'?: boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof BaseContainerResponse
     */
    'revision'?: number;
}
/**
 *
 * @export
 * @interface BaseEventAnswerResponse
 */
export interface BaseEventAnswerResponse {
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BaseEventAnswerResponse
     */
    'user': BaseUserResponse;
    /**
     * Filled in availability per slot.
     * @type {string}
     * @memberof BaseEventAnswerResponse
     */
    'availability'?: string;
    /**
     * Whether this user is selected for the shift in the event
     * @type {boolean}
     * @memberof BaseEventAnswerResponse
     */
    'selected': boolean;
}
/**
 *
 * @export
 * @interface BaseEventResponse
 */
export interface BaseEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseEventResponse
     */
    'version'?: number;
    /**
     * Name of the borrel.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'name': string;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BaseEventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'endDate': string;
    /**
     * The tpye of event.
     * @type {string}
     * @memberof BaseEventResponse
     */
    'type': string;
}
/**
 *
 * @export
 * @interface BaseEventShiftResponse
 */
export interface BaseEventShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseEventShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseEventShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof BaseEventShiftResponse
     */
    'name': string;
}
/**
 *
 * @export
 * @interface BaseFineHandoutEventResponse
 */
export interface BaseFineHandoutEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseFineHandoutEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseFineHandoutEventResponse
     */
    'version'?: number;
    /**
     * Reference date of fines
     * @type {string}
     * @memberof BaseFineHandoutEventResponse
     */
    'referenceDate': string;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BaseFineHandoutEventResponse
     */
    'createdBy': BaseUserResponse;
}
/**
 *
 * @export
 * @interface BaseInvoiceResponse
 */
export interface BaseInvoiceResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseInvoiceResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseInvoiceResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BaseInvoiceResponse
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'description': string;
    /**
     * Street of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'street': string;
    /**
     * Postal code of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'postalCode': string;
    /**
     *  City of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'city': string;
    /**
     *  Country of the invoice.
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'country': string;
    /**
     *
     * @type {InvoiceStatusResponse}
     * @memberof BaseInvoiceResponse
     */
    'currentState': InvoiceStatusResponse;
    /**
     *
     * @type {TransferResponse}
     * @memberof BaseInvoiceResponse
     */
    'transfer'?: TransferResponse;
    /**
     * Pdf url path linked to the invoice
     * @type {string}
     * @memberof BaseInvoiceResponse
     */
    'pdf'?: string;
}
/**
 *
 * @export
 * @interface BasePayoutRequestResponse
 */
export interface BasePayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BasePayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BasePayoutRequestResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BasePayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BasePayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof BasePayoutRequestResponse
     */
    'amount': DineroObjectResponse;
    /**
     * The current status of the payout request
     * @type {string}
     * @memberof BasePayoutRequestResponse
     */
    'status'?: string;
}
/**
 *
 * @export
 * @interface BasePointOfSaleResponse
 */
export interface BasePointOfSaleResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BasePointOfSaleResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BasePointOfSaleResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof BasePointOfSaleResponse
     */
    'name': string;
}
/**
 *
 * @export
 * @interface BaseProductResponse
 */
export interface BaseProductResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseProductResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseProductResponse
     */
    'version'?: number;
    /**
     * The name of the product.
     * @type {string}
     * @memberof BaseProductResponse
     */
    'name': string;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof BaseProductResponse
     */
    'priceInclVat': DineroObjectResponse;
    /**
     *
     * @type {BaseVatGroupResponse}
     * @memberof BaseProductResponse
     */
    'vat': BaseVatGroupResponse;
}
/**
 *
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseResponse
     */
    'version'?: number;
}
/**
 *
 * @export
 * @interface BaseTransactionResponse
 */
export interface BaseTransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseTransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseTransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseTransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseTransactionResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BaseTransactionResponse
     */
    'from': BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BaseTransactionResponse
     */
    'createdBy'?: BaseUserResponse;
    /**
     *
     * @type {BasePointOfSaleResponse}
     * @memberof BaseTransactionResponse
     */
    'pointOfSale': BasePointOfSaleResponse;
    /**
     *
     * @type {Dinero}
     * @memberof BaseTransactionResponse
     */
    'value': Dinero;
}
/**
 *
 * @export
 * @interface BaseUserResponse
 */
export interface BaseUserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseUserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseUserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof BaseUserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof BaseUserResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof BaseUserResponse
     */
    'nickname'?: string;
}
/**
 *
 * @export
 * @interface BaseVatGroupResponse
 */
export interface BaseVatGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BaseVatGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BaseVatGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'version'?: number;
    /**
     * Percentage of VAT
     * @type {number}
     * @memberof BaseVatGroupResponse
     */
    'percentage': number;
    /**
     * Whether VAT should be hidden
     * @type {boolean}
     * @memberof BaseVatGroupResponse
     */
    'hidden': boolean;
}
/**
 *
 * @export
 * @interface BoilerPayoutRequestResponse
 */
export interface BoilerPayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof BoilerPayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof BoilerPayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof BoilerPayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof BoilerPayoutRequestResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof BoilerPayoutRequestResponse
     */
    'amount': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface ContainerResponse
 */
export interface ContainerResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ContainerResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ContainerResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ContainerResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ContainerResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof ContainerResponse
     */
    'public'?: boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof ContainerResponse
     */
    'revision'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof ContainerResponse
     */
    'owner': BaseUserResponse;
}
/**
 *
 * @export
 * @interface ContainerWithProductsResponse
 */
export interface ContainerWithProductsResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'version'?: number;
    /**
     * The name of the container.
     * @type {string}
     * @memberof ContainerWithProductsResponse
     */
    'name': string;
    /**
     * Public status of the container.
     * @type {boolean}
     * @memberof ContainerWithProductsResponse
     */
    'public'?: boolean;
    /**
     * The container revision.
     * @type {number}
     * @memberof ContainerWithProductsResponse
     */
    'revision'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof ContainerWithProductsResponse
     */
    'owner': BaseUserResponse;
    /**
     * The products in the container.
     * @type {Array<ProductResponse>}
     * @memberof ContainerWithProductsResponse
     */
    'products': Array<ProductResponse>;
}
/**
 *
 * @export
 * @interface CreateContainerRequest
 */
export interface CreateContainerRequest {
    /**
     * Name of the container
     * @type {string}
     * @memberof CreateContainerRequest
     */
    'name': string;
    /**
     *    IDs or requests of the products to add to the container
     * @type {Array<number>}
     * @memberof CreateContainerRequest
     */
    'products': Array<number>;
    /**
     * Whether the container is public or not
     * @type {boolean}
     * @memberof CreateContainerRequest
     */
    'public': boolean;
    /**
     * Id of the user who will own the container, if undefined it will    default to the token ID.
     * @type {number}
     * @memberof CreateContainerRequest
     */
    'ownerId'?: number;
}
/**
 *
 * @export
 * @interface CreateEventRequest
 */
export interface CreateEventRequest {
    /**
     * Name of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'name': string;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'endDate': string;
    /**
     * The type of the event.
     * @type {string}
     * @memberof CreateEventRequest
     */
    'type'?: string;
    /**
     * IDs of shifts that are in this event per participant per borrel.
     * @type {Array<number>}
     * @memberof CreateEventRequest
     */
    'shiftIds': Array<number>;
}
/**
 *
 * @export
 * @interface CreateInvoiceRequest
 */
export interface CreateInvoiceRequest {
    /**
     * The recipient of the Invoice.
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'forId': number;
    /**
     * The creator of the Invoice, defaults to the ID of the requester.
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'byId'?: number;
    /**
     * Name of the addressed, defaults to the fullname of the person being invoiced.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'addressee'?: string;
    /**
     * The description of the invoice.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'description'?: string;
    /**
     * The reference of the invoice.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'reference': string;
    /**
     * Custom entries to be added to the invoice
     * @type {Array<InvoiceEntryRequest>}
     * @memberof CreateInvoiceRequest
     */
    'customEntries'?: Array<InvoiceEntryRequest>;
    /**
     * IDs of the transactions to add to the Invoice.
     * @type {Array<number>}
     * @memberof CreateInvoiceRequest
     */
    'transactionIDs'?: Array<number>;
    /**
     * For creating an Invoice for all transactions from a specific date.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'fromDate'?: string;
    /**
     * If the invoice is an credit Invoice  If an invoice is a credit invoice the relevant subtransactions are defined as all the sub transactions which have `subTransaction.toId == forId`.
     * @type {boolean}
     * @memberof CreateInvoiceRequest
     */
    'isCreditInvoice': boolean;
    /**
     * Street to use on the invoice, overwrites the users default.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'street'?: string;
    /**
     * Postal code to use on the invoice, overwrites the users default.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'postalCode'?: string;
    /**
     * City to use on the invoice, overwrites the users default.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'city'?: string;
    /**
     * Country to use on the invoice, overwrites the users default.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'country'?: string;
}
/**
 *
 * @export
 * @interface CreatePointOfSaleRequest
 */
export interface CreatePointOfSaleRequest {
    /**
     * Name of the POS
     * @type {string}
     * @memberof CreatePointOfSaleRequest
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof CreatePointOfSaleRequest
     */
    'useAuthentication': boolean;
    /**
     * IDs or Requests of the containers to add to the POS
     * @type {Array<number>}
     * @memberof CreatePointOfSaleRequest
     */
    'containers'?: Array<number>;
    /**
     * ID of the user who will own the POS, if undefined it will    default to the token ID.
     * @type {number}
     * @memberof CreatePointOfSaleRequest
     */
    'ownerId'?: number;
}
/**
 *
 * @export
 * @interface CreateProductRequest
 */
export interface CreateProductRequest {
    /**
     * Name of the product
     * @type {string}
     * @memberof CreateProductRequest
     */
    'name': string;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof CreateProductRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * VAT group ID of the product
     * @type {number}
     * @memberof CreateProductRequest
     */
    'vat': number;
    /**
     * Category of the product
     * @type {number}
     * @memberof CreateProductRequest
     */
    'category': number;
    /**
     * Alcohol percentage of the product in 2 decimals
     * @type {number}
     * @memberof CreateProductRequest
     */
    'alcoholPercentage': number;
    /**
     * If product is featured
     * @type {boolean}
     * @memberof CreateProductRequest
     */
    'featured'?: boolean;
    /**
     * If product is preferred
     * @type {boolean}
     * @memberof CreateProductRequest
     */
    'preferred'?: boolean;
    /**
     * If product is shown on narrowcasting screens
     * @type {boolean}
     * @memberof CreateProductRequest
     */
    'priceList'?: boolean;
    /**
     * ID of the owner
     * @type {number}
     * @memberof CreateProductRequest
     */
    'ownerId': number;
}
/**
 *
 * @export
 * @interface CreateShiftRequest
 */
export interface CreateShiftRequest {
    /**
     * Name of the event
     * @type {string}
     * @memberof CreateShiftRequest
     */
    'name': string;
    /**
     * Roles that (can) have this shift
     * @type {Array<string>}
     * @memberof CreateShiftRequest
     */
    'roles': Array<string>;
}
/**
 *
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'firstName': string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'lastName'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'nickname'?: string;
    /**
     *
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'canGoIntoDebt': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CreateUserRequest
     */
    'ofAge': boolean;
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
    /**
     *
     * @type {number}
     * @memberof CreateUserRequest
     */
    'type': number;
}
/**
 *
 * @export
 * @interface Dinero
 */
export interface Dinero {
    /**
     * The amount of money as integer in the given precision.
     * @type {number}
     * @memberof Dinero
     */
    'amount': number;
    /**
     * The precision of the amount, in decimal places.
     * @type {number}
     * @memberof Dinero
     */
    'precision': number;
    /**
     * The ISO 4217 currency code.
     * @type {string}
     * @memberof Dinero
     */
    'currency': string;
}
/**
 *
 * @export
 * @interface DineroObject
 */
export interface DineroObject {
    /**
     * amount
     * @type {number}
     * @memberof DineroObject
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObject
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObject
     */
    'precision': number;
}
/**
 *
 * @export
 * @interface DineroObjectRequest
 */
export interface DineroObjectRequest {
    /**
     * amount
     * @type {number}
     * @memberof DineroObjectRequest
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObjectRequest
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObjectRequest
     */
    'precision': number;
}
/**
 *
 * @export
 * @interface DineroObjectResponse
 */
export interface DineroObjectResponse {
    /**
     * amount
     * @type {number}
     * @memberof DineroObjectResponse
     */
    'amount': number;
    /**
     * currency
     * @type {string}
     * @memberof DineroObjectResponse
     */
    'currency': string;
    /**
     * precision
     * @type {number}
     * @memberof DineroObjectResponse
     */
    'precision': number;
}
/**
 *
 * @export
 * @interface EntityResponse
 */
export interface EntityResponse {
    /**
     * The name of the entity for which the permissions are.
     * @type {string}
     * @memberof EntityResponse
     */
    'entity': string;
    /**
     * The permissions per action.
     * @type {Array<ActionResponse>}
     * @memberof EntityResponse
     */
    'actions': Array<ActionResponse>;
}
/**
 *
 * @export
 * @interface EventAnswerAssignmentRequest
 */
export interface EventAnswerAssignmentRequest {
    /**
     * Whether this user is selected for the given shift at the given event
     * @type {boolean}
     * @memberof EventAnswerAssignmentRequest
     */
    'selected': boolean;
}
/**
 *
 * @export
 * @interface EventAnswerAvailabilityRequest
 */
export interface EventAnswerAvailabilityRequest {
    /**
     * New availability of the given user for the given event (YES, NO, LATER, NA)
     * @type {string}
     * @memberof EventAnswerAvailabilityRequest
     */
    'availability': string;
}
/**
 *
 * @export
 * @interface EventInShiftResponse
 */
export interface EventInShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventInShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventInShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof EventInShiftResponse
     */
    'name': string;
    /**
     * Which roles can fill in this shift.
     * @type {Array<string>}
     * @memberof EventInShiftResponse
     */
    'roles': Array<string>;
    /**
     * Answers for this shift.
     * @type {Array<BaseEventAnswerResponse>}
     * @memberof EventInShiftResponse
     */
    'answers'?: Array<BaseEventAnswerResponse>;
}
/**
 *
 * @export
 * @interface EventPlanningSelectedCount
 */
export interface EventPlanningSelectedCount {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof EventPlanningSelectedCount
     */
    'nickname'?: string;
    /**
     * Number of times this user was selected for this shift
     * @type {number}
     * @memberof EventPlanningSelectedCount
     */
    'count': number;
}
/**
 *
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventResponse
     */
    'version'?: number;
    /**
     * Name of the borrel.
     * @type {string}
     * @memberof EventResponse
     */
    'name': string;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof EventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof EventResponse
     */
    'startDate': string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof EventResponse
     */
    'endDate': string;
    /**
     * The tpye of event.
     * @type {string}
     * @memberof EventResponse
     */
    'type': string;
    /**
     * Shifts for this event
     * @type {Array<EventInShiftResponse>}
     * @memberof EventResponse
     */
    'shifts': Array<EventInShiftResponse>;
}
/**
 *
 * @export
 * @interface EventShiftResponse
 */
export interface EventShiftResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof EventShiftResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof EventShiftResponse
     */
    'version'?: number;
    /**
     * Name of the shift.
     * @type {string}
     * @memberof EventShiftResponse
     */
    'name': string;
    /**
     * Which roles can fill in this shift.
     * @type {Array<string>}
     * @memberof EventShiftResponse
     */
    'roles': Array<string>;
}
/**
 *
 * @export
 * @interface FinancialMutationResponse
 */
export interface FinancialMutationResponse {
    /**
     * Type of mutation (\'transfer\' or \'transaction\') (Optional)
     * @type {string}
     * @memberof FinancialMutationResponse
     */
    'type': FinancialMutationResponseTypeEnum;
    /**
     *
     * @type {FinancialMutationResponseMutation}
     * @memberof FinancialMutationResponse
     */
    'mutation'?: FinancialMutationResponseMutation;
}
export declare const FinancialMutationResponseTypeEnum: {
    readonly Transfer: "transfer";
    readonly Transaction: "transaction";
};
export type FinancialMutationResponseTypeEnum = typeof FinancialMutationResponseTypeEnum[keyof typeof FinancialMutationResponseTypeEnum];
/**
 * @type FinancialMutationResponseMutation
 * Details of mutation, this can be either of type TransferResponse or BaseTransactionResponse
 * @export
 */
export type FinancialMutationResponseMutation = BaseTransactionResponse | TransferResponse;
/**
 *
 * @export
 * @interface FineHandoutEventResponse
 */
export interface FineHandoutEventResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof FineHandoutEventResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof FineHandoutEventResponse
     */
    'version'?: number;
    /**
     * Reference date of fines
     * @type {string}
     * @memberof FineHandoutEventResponse
     */
    'referenceDate': string;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof FineHandoutEventResponse
     */
    'createdBy': BaseUserResponse;
    /**
     * Fines that have been handed out
     * @type {Array<FineResponse>}
     * @memberof FineHandoutEventResponse
     */
    'fines': Array<FineResponse>;
}
/**
 *
 * @export
 * @interface FineResponse
 */
export interface FineResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof FineResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof FineResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof FineResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof FineResponse
     */
    'version'?: number;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof FineResponse
     */
    'amount': DineroObjectResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof FineResponse
     */
    'user': BaseUserResponse;
}
/**
 *
 * @export
 * @interface GEWISAuthenticationPinRequest
 */
export interface GEWISAuthenticationPinRequest {
    /**
     *
     * @type {number}
     * @memberof GEWISAuthenticationPinRequest
     */
    'gewisId': number;
    /**
     *
     * @type {string}
     * @memberof GEWISAuthenticationPinRequest
     */
    'pin': string;
}
/**
 *
 * @export
 * @interface GetAllBalanceUserTypesParameterInner
 */
export interface GetAllBalanceUserTypesParameterInner {
}
/**
 * @type GetAllPayoutRequestsRequestedByIdParameter
 * @export
 */
export type GetAllPayoutRequestsRequestedByIdParameter = Array<number> | number;
/**
 *
 * @export
 * @interface GewisUserResponse
 */
export interface GewisUserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof GewisUserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof GewisUserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof GewisUserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'nickname'?: string;
    /**
     * Whether the user activated
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'active': boolean;
    /**
     * Whether the user is deleted
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'deleted': boolean;
    /**
     * The type of user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'type': string;
    /**
     * If local user, the e-mail of the user
     * @type {string}
     * @memberof GewisUserResponse
     */
    'email'?: string;
    /**
     * Whether this user has accepted the TOS
     * @type {string}
     * @memberof GewisUserResponse
     */
    'acceptedToS'?: string;
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'extensiveDataProcessing'?: boolean;
    /**
     * Whether someone is old enough to drink beer
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'ofAge'?: boolean;
    /**
     * Whether this user can get a negative balance
     * @type {boolean}
     * @memberof GewisUserResponse
     */
    'canGoIntoDebt': boolean;
    /**
     * The m-Number of the user
     * @type {number}
     * @memberof GewisUserResponse
     */
    'gewisId'?: number;
}
/**
 *
 * @export
 * @interface GewiswebAuthenticationRequest
 */
export interface GewiswebAuthenticationRequest {
    /**
     * The gewisweb JWT token.
     * @type {string}
     * @memberof GewiswebAuthenticationRequest
     */
    'token': string;
    /**
     * The nonce used in the newly signed JWT token.
     * @type {string}
     * @memberof GewiswebAuthenticationRequest
     */
    'nonce': string;
}
/**
 *
 * @export
 * @interface HandoutFinesRequest
 */
export interface HandoutFinesRequest {
    /**
     * Users to fine. If a user is not eligible for a fine, a fine of 0,00 will be handed out.
     * @type {Array<number>}
     * @memberof HandoutFinesRequest
     */
    'userIds': Array<number>;
    /**
     * Reference date to calculate the balance and thus the height of the fine for.
     * @type {string}
     * @memberof HandoutFinesRequest
     */
    'referenceDate': string;
}
/**
 *
 * @export
 * @interface InvoiceEntryRequest
 */
export interface InvoiceEntryRequest {
    /**
     * The description of the entry
     * @type {string}
     * @memberof InvoiceEntryRequest
     */
    'description': string;
    /**
     * Amount of item sold.
     * @type {number}
     * @memberof InvoiceEntryRequest
     */
    'amount': number;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof InvoiceEntryRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * The percentage of VAT applied to this item
     * @type {number}
     * @memberof InvoiceEntryRequest
     */
    'vatPercentage': number;
}
/**
 *
 * @export
 * @interface InvoiceEntryResponse
 */
export interface InvoiceEntryResponse {
    /**
     * The description of the entry
     * @type {string}
     * @memberof InvoiceEntryResponse
     */
    'description': string;
    /**
     * Amount of products sold.
     * @type {number}
     * @memberof InvoiceEntryResponse
     */
    'amount': number;
    /**
     *
     * @type {DineroObject}
     * @memberof InvoiceEntryResponse
     */
    'priceInclVat': DineroObject;
    /**
     * The percentage of VAT applied to this entry
     * @type {number}
     * @memberof InvoiceEntryResponse
     */
    'vatPercentage': number;
}
/**
 *
 * @export
 * @interface InvoiceResponse
 */
export interface InvoiceResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof InvoiceResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof InvoiceResponse
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'description': string;
    /**
     * Street of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'street': string;
    /**
     * Postal code of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'postalCode': string;
    /**
     *  City of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'city': string;
    /**
     *  Country of the invoice.
     * @type {string}
     * @memberof InvoiceResponse
     */
    'country': string;
    /**
     *
     * @type {InvoiceStatusResponse}
     * @memberof InvoiceResponse
     */
    'currentState': InvoiceStatusResponse;
    /**
     *
     * @type {TransferResponse}
     * @memberof InvoiceResponse
     */
    'transfer'?: TransferResponse;
    /**
     * Pdf url path linked to the invoice
     * @type {string}
     * @memberof InvoiceResponse
     */
    'pdf'?: string;
    /**
     * The entries of the invoice
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponse
     */
    'invoiceEntries': Array<InvoiceEntryResponse>;
}
/**
 *
 * @export
 * @interface InvoiceResponseTypes
 */
export interface InvoiceResponseTypes {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof InvoiceResponseTypes
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof InvoiceResponseTypes
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof InvoiceResponseTypes
     */
    'to': BaseUserResponse;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'addressee': string;
    /**
     * Description of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'description': string;
    /**
     * Street of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'street': string;
    /**
     * Postal code of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'postalCode': string;
    /**
     *  City of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'city': string;
    /**
     *  Country of the invoice.
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'country': string;
    /**
     *
     * @type {InvoiceStatusResponse}
     * @memberof InvoiceResponseTypes
     */
    'currentState': InvoiceStatusResponse;
    /**
     *
     * @type {TransferResponse}
     * @memberof InvoiceResponseTypes
     */
    'transfer'?: TransferResponse;
    /**
     * Pdf url path linked to the invoice
     * @type {string}
     * @memberof InvoiceResponseTypes
     */
    'pdf'?: string;
    /**
     * The entries of the invoice
     * @type {Array<InvoiceEntryResponse>}
     * @memberof InvoiceResponseTypes
     */
    'invoiceEntries'?: Array<InvoiceEntryResponse>;
}
/**
 *
 * @export
 * @interface InvoiceStatusResponse
 */
export interface InvoiceStatusResponse {
    /**
     *
     * @type {BaseUserResponse}
     * @memberof InvoiceStatusResponse
     */
    'changedBy': BaseUserResponse;
    /**
     * The state of the invoice
     * @type {string}
     * @memberof InvoiceStatusResponse
     */
    'state': InvoiceStatusResponseStateEnum;
}
export declare const InvoiceStatusResponseStateEnum: {
    readonly Created: "CREATED";
    readonly Sent: "SENT";
    readonly Paid: "PAID";
    readonly Deleted: "DELETED";
};
export type InvoiceStatusResponseStateEnum = typeof InvoiceStatusResponseStateEnum[keyof typeof InvoiceStatusResponseStateEnum];
/**
 *
 * @export
 * @interface InvoiceUserResponse
 */
export interface InvoiceUserResponse {
    /**
     *
     * @type {BaseUserResponse}
     * @memberof InvoiceUserResponse
     */
    'user': BaseUserResponse;
    /**
     * Default street to use for invoices.
     * @type {string}
     * @memberof InvoiceUserResponse
     */
    'street': string;
    /**
     * Default postal code to use for invoices.
     * @type {string}
     * @memberof InvoiceUserResponse
     */
    'postalCode': string;
    /**
     * Default city to use for invoices.
     * @type {string}
     * @memberof InvoiceUserResponse
     */
    'city': string;
    /**
     * Default country to use for invoices.
     * @type {string}
     * @memberof InvoiceUserResponse
     */
    'country': string;
    /**
     * Whether invoices should be automatically generated
     * @type {boolean}
     * @memberof InvoiceUserResponse
     */
    'automatic': boolean;
}
/**
 *
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * The message response text.
     * @type {string}
     * @memberof MessageResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface PaginatedBalanceResponse
 */
export interface PaginatedBalanceResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedBalanceResponse
     */
    '_pagination'?: PaginationResult;
    /**
     * Returned balance responses
     * @type {Array<BalanceResponse>}
     * @memberof PaginatedBalanceResponse
     */
    'records'?: Array<BalanceResponse>;
}
/**
 *
 * @export
 * @interface PaginatedBannerResponse
 */
export interface PaginatedBannerResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedBannerResponse
     */
    '_pagination'?: PaginationResult;
    /**
     * Returned banners
     * @type {Array<BannerResponse>}
     * @memberof PaginatedBannerResponse
     */
    'records'?: Array<BannerResponse>;
}
/**
 *
 * @export
 * @interface PaginatedBaseEventResponse
 */
export interface PaginatedBaseEventResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedBaseEventResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned borrel Schemas
     * @type {Array<BaseEventResponse>}
     * @memberof PaginatedBaseEventResponse
     */
    'records': Array<BaseEventResponse>;
}
/**
 *
 * @export
 * @interface PaginatedBasePayoutRequestResponse
 */
export interface PaginatedBasePayoutRequestResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedBasePayoutRequestResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned payout requests
     * @type {Array<BasePayoutRequestResponse>}
     * @memberof PaginatedBasePayoutRequestResponse
     */
    'records': Array<BasePayoutRequestResponse>;
}
/**
 *
 * @export
 * @interface PaginatedBaseTransactionResponse
 */
export interface PaginatedBaseTransactionResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedBaseTransactionResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned banners
     * @type {Array<BaseTransactionResponse>}
     * @memberof PaginatedBaseTransactionResponse
     */
    'records': Array<BaseTransactionResponse>;
}
/**
 *
 * @export
 * @interface PaginatedContainerResponse
 */
export interface PaginatedContainerResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedContainerResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned containers
     * @type {Array<ContainerResponse>}
     * @memberof PaginatedContainerResponse
     */
    'records': Array<ContainerResponse>;
}
/**
 *
 * @export
 * @interface PaginatedContainerWithProductResponse
 */
export interface PaginatedContainerWithProductResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedContainerWithProductResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned containers
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PaginatedContainerWithProductResponse
     */
    'records': Array<ContainerWithProductsResponse>;
}
/**
 *
 * @export
 * @interface PaginatedEventShiftResponse
 */
export interface PaginatedEventShiftResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedEventShiftResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned event shifts
     * @type {Array<EventShiftResponse>}
     * @memberof PaginatedEventShiftResponse
     */
    'records': Array<EventShiftResponse>;
}
/**
 *
 * @export
 * @interface PaginatedFinancialMutationResponse
 */
export interface PaginatedFinancialMutationResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedFinancialMutationResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned mutations
     * @type {Array<FinancialMutationResponse>}
     * @memberof PaginatedFinancialMutationResponse
     */
    'records': Array<FinancialMutationResponse>;
}
/**
 *
 * @export
 * @interface PaginatedFineHandoutEventResponse
 */
export interface PaginatedFineHandoutEventResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedFineHandoutEventResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned fine handout events
     * @type {Array<BaseFineHandoutEventResponse>}
     * @memberof PaginatedFineHandoutEventResponse
     */
    'records': Array<BaseFineHandoutEventResponse>;
}
/**
 *
 * @export
 * @interface PaginatedInvoiceResponse
 */
export interface PaginatedInvoiceResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedInvoiceResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned Invoices
     * @type {Array<InvoiceResponseTypes>}
     * @memberof PaginatedInvoiceResponse
     */
    'records': Array<InvoiceResponseTypes>;
}
/**
 *
 * @export
 * @interface PaginatedPointOfSaleResponse
 */
export interface PaginatedPointOfSaleResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedPointOfSaleResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned points of sale
     * @type {Array<PointOfSaleResponse>}
     * @memberof PaginatedPointOfSaleResponse
     */
    'records': Array<PointOfSaleResponse>;
}
/**
 *
 * @export
 * @interface PaginatedProductCategoryResponse
 */
export interface PaginatedProductCategoryResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedProductCategoryResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned product categories
     * @type {Array<ProductCategoryResponse>}
     * @memberof PaginatedProductCategoryResponse
     */
    'records': Array<ProductCategoryResponse>;
}
/**
 *
 * @export
 * @interface PaginatedProductResponse
 */
export interface PaginatedProductResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedProductResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned products
     * @type {Array<ProductResponse>}
     * @memberof PaginatedProductResponse
     */
    'records': Array<ProductResponse>;
}
/**
 *
 * @export
 * @interface PaginatedTransferResponse
 */
export interface PaginatedTransferResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedTransferResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned transfers
     * @type {Array<TransferResponse>}
     * @memberof PaginatedTransferResponse
     */
    'records': Array<TransferResponse>;
}
/**
 *
 * @export
 * @interface PaginatedUserResponse
 */
export interface PaginatedUserResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedUserResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned users
     * @type {Array<UserResponse>}
     * @memberof PaginatedUserResponse
     */
    'records': Array<UserResponse>;
}
/**
 *
 * @export
 * @interface PaginatedVatGroupResponse
 */
export interface PaginatedVatGroupResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedVatGroupResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned VAT groups
     * @type {Array<VatGroupResponse>}
     * @memberof PaginatedVatGroupResponse
     */
    'records': Array<VatGroupResponse>;
}
/**
 *
 * @export
 * @interface PaginatedVoucherGroupResponse
 */
export interface PaginatedVoucherGroupResponse {
    /**
     *
     * @type {PaginationResult}
     * @memberof PaginatedVoucherGroupResponse
     */
    '_pagination': PaginationResult;
    /**
     * Returned voucher groups
     * @type {Array<VoucherGroupResponse>}
     * @memberof PaginatedVoucherGroupResponse
     */
    'records': Array<VoucherGroupResponse>;
}
/**
 *
 * @export
 * @interface PaginationResult
 */
export interface PaginationResult {
    /**
     * Number of records queried
     * @type {number}
     * @memberof PaginationResult
     */
    'take': number;
    /**
     * Number of skipped records
     * @type {number}
     * @memberof PaginationResult
     */
    'skip': number;
    /**
     * Total number of resulting records
     * @type {number}
     * @memberof PaginationResult
     */
    'count': number;
}
/**
 *
 * @export
 * @interface PayoutRequestRequest
 */
export interface PayoutRequestRequest {
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof PayoutRequestRequest
     */
    'amount': DineroObjectRequest;
    /**
     * The bank account number to transfer the money to
     * @type {string}
     * @memberof PayoutRequestRequest
     */
    'bankAccountNumber': string;
    /**
     * The name of the owner of the bank account
     * @type {string}
     * @memberof PayoutRequestRequest
     */
    'bankAccountName': string;
}
/**
 *
 * @export
 * @interface PayoutRequestResponse
 */
export interface PayoutRequestResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PayoutRequestResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PayoutRequestResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof PayoutRequestResponse
     */
    'requestedBy': BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof PayoutRequestResponse
     */
    'approvedBy'?: BaseUserResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof PayoutRequestResponse
     */
    'amount': DineroObjectResponse;
    /**
     * Statuses of this payout response over time
     * @type {Array<PayoutRequestStatusResponse>}
     * @memberof PayoutRequestResponse
     */
    'status': Array<PayoutRequestStatusResponse>;
    /**
     * Bank account number
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'bankAccountNumber': string;
    /**
     * Name of the account owner
     * @type {string}
     * @memberof PayoutRequestResponse
     */
    'bankAccountName': string;
}
/**
 *
 * @export
 * @interface PayoutRequestStatusRequest
 */
export interface PayoutRequestStatusRequest {
    /**
     * PayoutRequestState to change to.
     * @type {string}
     * @memberof PayoutRequestStatusRequest
     */
    'state'?: PayoutRequestStatusRequestStateEnum;
}
export declare const PayoutRequestStatusRequestStateEnum: {
    readonly Created: "CREATED";
    readonly Approved: "APPROVED";
    readonly Denied: "DENIED";
    readonly Cancelled: "CANCELLED";
};
export type PayoutRequestStatusRequestStateEnum = typeof PayoutRequestStatusRequestStateEnum[keyof typeof PayoutRequestStatusRequestStateEnum];
/**
 *
 * @export
 * @interface PayoutRequestStatusResponse
 */
export interface PayoutRequestStatusResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PayoutRequestStatusResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PayoutRequestStatusResponse
     */
    'version'?: number;
    /**
     * The state of this status change
     * @type {string}
     * @memberof PayoutRequestStatusResponse
     */
    'state': string;
}
/**
 *
 * @export
 * @interface PointOfSaleResponse
 */
export interface PointOfSaleResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof PointOfSaleResponse
     */
    'name': string;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof PointOfSaleResponse
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleResponse
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleResponse
     */
    'useAuthentication': boolean;
}
/**
 *
 * @export
 * @interface PointOfSaleWithContainersResponse
 */
export interface PointOfSaleWithContainersResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'version'?: number;
    /**
     * The name of the point-of-sale.
     * @type {string}
     * @memberof PointOfSaleWithContainersResponse
     */
    'name': string;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof PointOfSaleWithContainersResponse
     */
    'owner'?: BaseUserResponse;
    /**
     * Revision of the POS
     * @type {number}
     * @memberof PointOfSaleWithContainersResponse
     */
    'revision': number;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof PointOfSaleWithContainersResponse
     */
    'useAuthentication': boolean;
    /**
     * The containers in the point-of-sale.
     * @type {Array<ContainerWithProductsResponse>}
     * @memberof PointOfSaleWithContainersResponse
     */
    'containers': Array<ContainerWithProductsResponse>;
}
/**
 *
 * @export
 * @interface ProductCategoryRequest
 */
export interface ProductCategoryRequest {
    /**
     * Name/label of the productCategory
     * @type {string}
     * @memberof ProductCategoryRequest
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface ProductCategoryResponse
 */
export interface ProductCategoryResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ProductCategoryResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ProductCategoryResponse
     */
    'version'?: number;
    /**
     * The name of the productCategory.
     * @type {string}
     * @memberof ProductCategoryResponse
     */
    'name': string;
}
/**
 *
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof ProductResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof ProductResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof ProductResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof ProductResponse
     */
    'version'?: number;
    /**
     * The name of the product.
     * @type {string}
     * @memberof ProductResponse
     */
    'name': string;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof ProductResponse
     */
    'priceInclVat': DineroObjectResponse;
    /**
     *
     * @type {BaseVatGroupResponse}
     * @memberof ProductResponse
     */
    'vat': BaseVatGroupResponse;
    /**
     * The product revision ID
     * @type {number}
     * @memberof ProductResponse
     */
    'revision': number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof ProductResponse
     */
    'owner': BaseUserResponse;
    /**
     *
     * @type {ProductCategoryResponse}
     * @memberof ProductResponse
     */
    'category': ProductCategoryResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof ProductResponse
     */
    'priceExclVat': DineroObjectResponse;
    /**
     * The URL to the picture representing this product.
     * @type {string}
     * @memberof ProductResponse
     */
    'image'?: string;
    /**
     * The percentage of alcohol in this product.
     * @type {number}
     * @memberof ProductResponse
     */
    'alcoholPercentage': number;
    /**
     * If product is featured
     * @type {boolean}
     * @memberof ProductResponse
     */
    'featured': boolean;
    /**
     * If product is preferred
     * @type {boolean}
     * @memberof ProductResponse
     */
    'preferred': boolean;
    /**
     * If product is shown on narrow casting screens
     * @type {boolean}
     * @memberof ProductResponse
     */
    'priceList': boolean;
}
/**
 *
 * @export
 * @interface RelationResponse
 */
export interface RelationResponse {
    /**
     * The the ownership relation towards the entity.
     * @type {string}
     * @memberof RelationResponse
     */
    'relation': string;
    /**
     * The attributes of the entity for which there is access.
     * @type {Array<string>}
     * @memberof RelationResponse
     */
    'attributes': Array<string>;
}
/**
 *
 * @export
 * @interface ResetLocalRequest
 */
export interface ResetLocalRequest {
    /**
     * The mail of the user
     * @type {string}
     * @memberof ResetLocalRequest
     */
    'accountMail': string;
}
/**
 *
 * @export
 * @interface RevisionRequest
 */
export interface RevisionRequest {
    /**
     * revision id
     * @type {number}
     * @memberof RevisionRequest
     */
    'id': number;
    /**
     * revision number
     * @type {number}
     * @memberof RevisionRequest
     */
    'revision': number;
}
/**
 *
 * @export
 * @interface RoleResponse
 */
export interface RoleResponse {
    /**
     * The name of the role.
     * @type {string}
     * @memberof RoleResponse
     */
    'role': string;
    /**
     * The permissions with regards to the entity.
     * @type {Array<EntityResponse>}
     * @memberof RoleResponse
     */
    'entities': Array<EntityResponse>;
}
/**
 *
 * @export
 * @interface SimpleFileRequest
 */
export interface SimpleFileRequest {
    /**
     * Name of the file
     * @type {string}
     * @memberof SimpleFileRequest
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface SimpleFileResponse
 */
export interface SimpleFileResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SimpleFileResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SimpleFileResponse
     */
    'version'?: number;
    /**
     * The filename of the file
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'downloadName': string;
    /**
     * The location of the file in storage
     * @type {string}
     * @memberof SimpleFileResponse
     */
    'location': string;
    /**
     *
     * @type {UserResponse}
     * @memberof SimpleFileResponse
     */
    'createdBy': UserResponse;
}
/**
 *
 * @export
 * @interface StripeDepositResponse
 */
export interface StripeDepositResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripeDepositResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripeDepositResponse
     */
    'version'?: number;
    /**
     * The ID of the payment intent in Stripe
     * @type {string}
     * @memberof StripeDepositResponse
     */
    'stripeId': string;
    /**
     * Current status of the deposit
     * @type {Array<StripeDepositStatusResponse>}
     * @memberof StripeDepositResponse
     */
    'depositStatus': Array<StripeDepositStatusResponse>;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof StripeDepositResponse
     */
    'amount': DineroObjectResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof StripeDepositResponse
     */
    'to': BaseUserResponse;
}
/**
 *
 * @export
 * @interface StripeDepositStatusResponse
 */
export interface StripeDepositStatusResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripeDepositStatusResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripeDepositStatusResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripeDepositStatusResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripeDepositStatusResponse
     */
    'version'?: number;
    /**
     * State of the Stripe deposit. It can be 1 (\'CREATED\'), 2 (\'PROCESSING\'), 3 (\'SUCCEEDED\'), or 4 (\'FAILED\')
     * @type {number}
     * @memberof StripeDepositStatusResponse
     */
    'state': number;
}
/**
 *
 * @export
 * @interface StripePaymentIntentResponse
 */
export interface StripePaymentIntentResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof StripePaymentIntentResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof StripePaymentIntentResponse
     */
    'version'?: number;
    /**
     * ID of the intent in Stripe.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'stripeId': string;
    /**
     * The client secret of the created Payment Intent.
     * @type {string}
     * @memberof StripePaymentIntentResponse
     */
    'clientSecret': string;
}
/**
 *
 * @export
 * @interface StripeRequest
 */
export interface StripeRequest {
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof StripeRequest
     */
    'amount'?: DineroObjectRequest;
}
/**
 *
 * @export
 * @interface SubTransactionRequest
 */
export interface SubTransactionRequest {
    /**
     * to user id
     * @type {number}
     * @memberof SubTransactionRequest
     */
    'to': number;
    /**
     *
     * @type {RevisionRequest}
     * @memberof SubTransactionRequest
     */
    'container': RevisionRequest;
    /**
     * subtransaction rows
     * @type {Array<SubTransactionRowRequest>}
     * @memberof SubTransactionRequest
     */
    'subTransactionRows': Array<SubTransactionRowRequest>;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof SubTransactionRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 *
 * @export
 * @interface SubTransactionResponse
 */
export interface SubTransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SubTransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SubTransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SubTransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SubTransactionResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof SubTransactionResponse
     */
    'to': BaseUserResponse;
    /**
     *
     * @type {BaseContainerResponse}
     * @memberof SubTransactionResponse
     */
    'container': BaseContainerResponse;
    /**
     * The rows of this     SubTransaction
     * @type {Array<SubTransactionRowResponse>}
     * @memberof SubTransactionResponse
     */
    'subTransactionRows': Array<SubTransactionRowResponse>;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof SubTransactionResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface SubTransactionRowRequest
 */
export interface SubTransactionRowRequest {
    /**
     *
     * @type {RevisionRequest}
     * @memberof SubTransactionRowRequest
     */
    'product'?: RevisionRequest;
    /**
     * amount of this product in subtransaction
     * @type {number}
     * @memberof SubTransactionRowRequest
     */
    'amount'?: number;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof SubTransactionRowRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 *
 * @export
 * @interface SubTransactionRowResponse
 */
export interface SubTransactionRowResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof SubTransactionRowResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof SubTransactionRowResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseProductResponse}
     * @memberof SubTransactionRowResponse
     */
    'product': BaseProductResponse;
    /**
     * The amount that has been bought
     * @type {number}
     * @memberof SubTransactionRowResponse
     */
    'amount': number;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof SubTransactionRowResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface TransactionFilterParameters
 */
export interface TransactionFilterParameters {
    /**
     *
     * @type {Array<number>}
     * @memberof TransactionFilterParameters
     */
    'transactionId'?: Array<number>;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'fromId'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'createdById'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'toId'?: number;
    /**
     *
     * @type {boolean}
     * @memberof TransactionFilterParameters
     */
    'exclusiveToId'?: boolean;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'pointOfSaleId'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'pointOfSaleRevision'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'containerId'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'containerRevision'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'productId'?: number;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'productRevision'?: number;
    /**
     *
     * @type {string}
     * @memberof TransactionFilterParameters
     */
    'fromDate'?: string;
    /**
     *
     * @type {string}
     * @memberof TransactionFilterParameters
     */
    'tillDate'?: string;
    /**
     *
     * @type {number}
     * @memberof TransactionFilterParameters
     */
    'invoiceId'?: number;
}
/**
 *
 * @export
 * @interface TransactionReportCategoryEntryResponse
 */
export interface TransactionReportCategoryEntryResponse {
    /**
     *
     * @type {ProductCategoryResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'category': ProductCategoryResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportCategoryEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface TransactionReportDataResponse
 */
export interface TransactionReportDataResponse {
    /**
     * The entries grouped by product
     * @type {Array<TransactionReportEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'entries': Array<TransactionReportEntryResponse>;
    /**
     * The entries grouped by category
     * @type {Array<TransactionReportCategoryEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'categories': Array<TransactionReportCategoryEntryResponse>;
    /**
     * The entries grouped by vat
     * @type {Array<TransactionReportVatEntryResponse>}
     * @memberof TransactionReportDataResponse
     */
    'vat': Array<TransactionReportVatEntryResponse>;
}
/**
 *
 * @export
 * @interface TransactionReportEntryResponse
 */
export interface TransactionReportEntryResponse {
    /**
     * The amount of times this product is in the report
     * @type {number}
     * @memberof TransactionReportEntryResponse
     */
    'count': number;
    /**
     *
     * @type {BaseProductResponse}
     * @memberof TransactionReportEntryResponse
     */
    'product': BaseProductResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface TransactionReportResponse
 */
export interface TransactionReportResponse {
    /**
     *
     * @type {TransactionFilterParameters}
     * @memberof TransactionReportResponse
     */
    'parameters': TransactionFilterParameters;
    /**
     *
     * @type {TransactionReportDataResponse}
     * @memberof TransactionReportResponse
     */
    'data': TransactionReportDataResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportResponse
     */
    'totalExclVat': DineroObjectResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportResponse
     */
    'totalInclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface TransactionReportVatEntryResponse
 */
export interface TransactionReportVatEntryResponse {
    /**
     *
     * @type {BaseVatGroupResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'vat': BaseVatGroupResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'totalInclVat': DineroObjectResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionReportVatEntryResponse
     */
    'totalExclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface TransactionRequest
 */
export interface TransactionRequest {
    /**
     * from user id
     * @type {number}
     * @memberof TransactionRequest
     */
    'from': number;
    /**
     * createdBy user id
     * @type {number}
     * @memberof TransactionRequest
     */
    'createdBy'?: number;
    /**
     * subtransactions
     * @type {Array<SubTransactionRequest>}
     * @memberof TransactionRequest
     */
    'subTransactions': Array<SubTransactionRequest>;
    /**
     *
     * @type {RevisionRequest}
     * @memberof TransactionRequest
     */
    'pointOfSale': RevisionRequest;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof TransactionRequest
     */
    'totalPriceInclVat': DineroObjectRequest;
}
/**
 *
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof TransactionResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof TransactionResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof TransactionResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof TransactionResponse
     */
    'version'?: number;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransactionResponse
     */
    'from': BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransactionResponse
     */
    'createdBy'?: BaseUserResponse;
    /**
     * The subtransactions belonging to this transaction.
     * @type {Array<SubTransactionResponse>}
     * @memberof TransactionResponse
     */
    'subTransactions': Array<SubTransactionResponse>;
    /**
     *
     * @type {PointOfSaleResponse}
     * @memberof TransactionResponse
     */
    'pointOfSale': PointOfSaleResponse;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof TransactionResponse
     */
    'totalPriceInclVat': DineroObjectResponse;
}
/**
 *
 * @export
 * @interface TransferRequest
 */
export interface TransferRequest {
    /**
     * Description of the transfer
     * @type {string}
     * @memberof TransferRequest
     */
    'description'?: string;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof TransferRequest
     */
    'amount'?: DineroObjectRequest;
    /**
     * Type of transfer
     * @type {number}
     * @memberof TransferRequest
     */
    'type'?: number;
    /**
     * from which user the money is being transferred
     * @type {number}
     * @memberof TransferRequest
     */
    'fromId'?: number;
    /**
     * to which user the money is being transferred.
     * @type {number}
     * @memberof TransferRequest
     */
    'toId'?: number;
}
/**
 *
 * @export
 * @interface TransferResponse
 */
export interface TransferResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof TransferResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof TransferResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof TransferResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof TransferResponse
     */
    'version'?: number;
    /**
     * Description of the transfer
     * @type {string}
     * @memberof TransferResponse
     */
    'description': string;
    /**
     *
     * @type {Dinero}
     * @memberof TransferResponse
     */
    'amount': Dinero;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransferResponse
     */
    'from'?: BaseUserResponse;
    /**
     *
     * @type {BaseUserResponse}
     * @memberof TransferResponse
     */
    'to'?: BaseUserResponse;
    /**
     *
     * @type {BaseInvoiceResponse}
     * @memberof TransferResponse
     */
    'invoice'?: BaseInvoiceResponse;
    /**
     *
     * @type {StripeDepositResponse}
     * @memberof TransferResponse
     */
    'deposit'?: StripeDepositResponse;
    /**
     *
     * @type {BasePayoutRequestResponse}
     * @memberof TransferResponse
     */
    'payoutRequest'?: BasePayoutRequestResponse;
    /**
     *
     * @type {FineResponse}
     * @memberof TransferResponse
     */
    'fine'?: FineResponse;
    /**
     *
     * @type {UserFineGroupResponse}
     * @memberof TransferResponse
     */
    'waivedFines'?: UserFineGroupResponse;
}
/**
 *
 * @export
 * @interface UpdateContainerRequest
 */
export interface UpdateContainerRequest {
    /**
     * Name of the container
     * @type {string}
     * @memberof UpdateContainerRequest
     */
    'name': string;
    /**
     *    IDs or requests of the products to add to the container
     * @type {Array<number>}
     * @memberof UpdateContainerRequest
     */
    'products': Array<number>;
    /**
     * Whether the container is public or not
     * @type {boolean}
     * @memberof UpdateContainerRequest
     */
    'public': boolean;
}
/**
 *
 * @export
 * @interface UpdateEventRequest
 */
export interface UpdateEventRequest {
    /**
     * Name of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'name'?: string;
    /**
     * The starting date of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'startDate'?: string;
    /**
     * The end date of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'endDate'?: string;
    /**
     * The type of the event.
     * @type {string}
     * @memberof UpdateEventRequest
     */
    'type'?: string;
    /**
     * IDs of shifts that are in this event per participant per borrel.
     * @type {Array<number>}
     * @memberof UpdateEventRequest
     */
    'shiftIds'?: Array<number>;
}
/**
 *
 * @export
 * @interface UpdateInvoiceRequest
 */
export interface UpdateInvoiceRequest {
    /**
     * The user who updates the Invoice, defaults to the ID of the requester.
     * @type {number}
     * @memberof UpdateInvoiceRequest
     */
    'byId'?: number;
    /**
     * Name of the addressed.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'addressee'?: string;
    /**
     * The description of the invoice.
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'description'?: string;
    /**
     * The state to set of the invoice,
     * @type {string}
     * @memberof UpdateInvoiceRequest
     */
    'state'?: UpdateInvoiceRequestStateEnum;
}
export declare const UpdateInvoiceRequestStateEnum: {
    readonly Created: "CREATED";
    readonly Sent: "SENT";
    readonly Paid: "PAID";
    readonly Deleted: "DELETED";
};
export type UpdateInvoiceRequestStateEnum = typeof UpdateInvoiceRequestStateEnum[keyof typeof UpdateInvoiceRequestStateEnum];
/**
 *
 * @export
 * @interface UpdateInvoiceUserRequest
 */
export interface UpdateInvoiceUserRequest {
    /**
     * Default street to use for invoices.
     * @type {string}
     * @memberof UpdateInvoiceUserRequest
     */
    'street': string;
    /**
     * Default postal code to use for invoices.
     * @type {string}
     * @memberof UpdateInvoiceUserRequest
     */
    'postalCode': string;
    /**
     * Default city to use for invoices.
     * @type {string}
     * @memberof UpdateInvoiceUserRequest
     */
    'city': string;
    /**
     * Default country to use for invoices.
     * @type {string}
     * @memberof UpdateInvoiceUserRequest
     */
    'country': string;
    /**
     * Whether invoices should be automatically generated
     * @type {boolean}
     * @memberof UpdateInvoiceUserRequest
     */
    'automatic': boolean;
}
/**
 *
 * @export
 * @interface UpdateKeyResponse
 */
export interface UpdateKeyResponse {
    /**
     * The key to return
     * @type {string}
     * @memberof UpdateKeyResponse
     */
    'key': string;
}
/**
 *
 * @export
 * @interface UpdateLocalRequest
 */
export interface UpdateLocalRequest {
    /**
     * The password to set
     * @type {string}
     * @memberof UpdateLocalRequest
     */
    'password': string;
}
/**
 *
 * @export
 * @interface UpdateNfcRequest
 */
export interface UpdateNfcRequest {
    /**
     * The NFC code to set
     * @type {string}
     * @memberof UpdateNfcRequest
     */
    'nfcCode': string;
}
/**
 *
 * @export
 * @interface UpdatePinRequest
 */
export interface UpdatePinRequest {
    /**
     * The PIN code to set
     * @type {string}
     * @memberof UpdatePinRequest
     */
    'pin': string;
}
/**
 *
 * @export
 * @interface UpdatePointOfSaleRequest
 */
export interface UpdatePointOfSaleRequest {
    /**
     * Name of the POS
     * @type {string}
     * @memberof UpdatePointOfSaleRequest
     */
    'name': string;
    /**
     * Whether this POS requires users to authenticate themselves before making a transaction
     * @type {boolean}
     * @memberof UpdatePointOfSaleRequest
     */
    'useAuthentication': boolean;
    /**
     * IDs or Requests of the containers to add to the POS
     * @type {Array<number>}
     * @memberof UpdatePointOfSaleRequest
     */
    'containers'?: Array<number>;
    /**
     * ID of the POS to update.
     * @type {number}
     * @memberof UpdatePointOfSaleRequest
     */
    'id': number;
}
/**
 *
 * @export
 * @interface UpdateProductRequest
 */
export interface UpdateProductRequest {
    /**
     * Name of the product
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'name': string;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof UpdateProductRequest
     */
    'priceInclVat': DineroObjectRequest;
    /**
     * VAT group ID of the product
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'vat': number;
    /**
     * Category of the product
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'category': number;
    /**
     * Alcohol percentage of the product in 2 decimals
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'alcoholPercentage': number;
    /**
     * If product is featured
     * @type {boolean}
     * @memberof UpdateProductRequest
     */
    'featured'?: boolean;
    /**
     * If product is required
     * @type {boolean}
     * @memberof UpdateProductRequest
     */
    'preferred'?: boolean;
    /**
     * If product should be shown on narrowcasting screens
     * @type {boolean}
     * @memberof UpdateProductRequest
     */
    'priceList'?: boolean;
}
/**
 *
 * @export
 * @interface UpdateShiftRequest
 */
export interface UpdateShiftRequest {
    /**
     * Name of the event
     * @type {string}
     * @memberof UpdateShiftRequest
     */
    'name'?: string;
    /**
     * Roles that (can) have this shift
     * @type {Array<string>}
     * @memberof UpdateShiftRequest
     */
    'roles'?: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstName'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'lastName'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'nickname'?: string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'canGoIntoDebt'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'ofAge'?: boolean;
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'deleted'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'active'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'extensiveDataProcessing'?: boolean;
}
/**
 *
 * @export
 * @interface UpdateVatGroupRequest
 */
export interface UpdateVatGroupRequest {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof UpdateVatGroupRequest
     */
    'name': string;
    /**
     * Whether this group should be hidden in the financial overviews when its value is zero
     * @type {boolean}
     * @memberof UpdateVatGroupRequest
     */
    'deleted': boolean;
    /**
     * Whether this group should be hidden from transactions
     * @type {boolean}
     * @memberof UpdateVatGroupRequest
     */
    'hidden': boolean;
}
/**
 *
 * @export
 * @interface UserFineGroupResponse
 */
export interface UserFineGroupResponse {
    /**
     * Fines that have been handed out
     * @type {Array<FineResponse>}
     * @memberof UserFineGroupResponse
     */
    'fines': Array<FineResponse>;
}
/**
 *
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof UserResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof UserResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof UserResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof UserResponse
     */
    'version'?: number;
    /**
     * The name of the user.
     * @type {string}
     * @memberof UserResponse
     */
    'firstName': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof UserResponse
     */
    'lastName': string;
    /**
     * The nickname of the user
     * @type {string}
     * @memberof UserResponse
     */
    'nickname'?: string;
    /**
     * Whether the user activated
     * @type {boolean}
     * @memberof UserResponse
     */
    'active': boolean;
    /**
     * Whether the user is deleted
     * @type {boolean}
     * @memberof UserResponse
     */
    'deleted': boolean;
    /**
     * The type of user
     * @type {string}
     * @memberof UserResponse
     */
    'type': string;
    /**
     * If local user, the e-mail of the user
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * Whether this user has accepted the TOS
     * @type {string}
     * @memberof UserResponse
     */
    'acceptedToS'?: string;
    /**
     * Whether data about this user can be used (non-anonymously) for more data science!
     * @type {boolean}
     * @memberof UserResponse
     */
    'extensiveDataProcessing'?: boolean;
    /**
     * Whether someone is old enough to drink beer
     * @type {boolean}
     * @memberof UserResponse
     */
    'ofAge'?: boolean;
    /**
     * Whether this user can get a negative balance
     * @type {boolean}
     * @memberof UserResponse
     */
    'canGoIntoDebt': boolean;
}
/**
 *
 * @export
 * @interface UserToFineResponse
 */
export interface UserToFineResponse {
    /**
     * User ID
     * @type {number}
     * @memberof UserToFineResponse
     */
    'id': number;
    /**
     *
     * @type {DineroObjectResponse}
     * @memberof UserToFineResponse
     */
    'fineAmount': DineroObjectResponse;
    /**
     * Balances at the given reference dates
     * @type {Array<BalanceResponse>}
     * @memberof UserToFineResponse
     */
    'balances': Array<BalanceResponse>;
}
/**
 *
 * @export
 * @interface VatDeclarationResponse
 */
export interface VatDeclarationResponse {
    /**
     * Calendar year of this result table
     * @type {number}
     * @memberof VatDeclarationResponse
     */
    'calendarYear': number;
    /**
     * The used VAT declaration period the rows below are based upon
     * @type {string}
     * @memberof VatDeclarationResponse
     */
    'period': string;
    /**
     * The rows of the result table
     * @type {Array<VatDeclarationRow>}
     * @memberof VatDeclarationResponse
     */
    'rows': Array<VatDeclarationRow>;
}
/**
 *
 * @export
 * @interface VatDeclarationRow
 */
export interface VatDeclarationRow {
    /**
     * ID of the VAT group
     * @type {number}
     * @memberof VatDeclarationRow
     */
    'id': number;
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatDeclarationRow
     */
    'name': string;
    /**
     * Percentage of VAT in this group
     * @type {number}
     * @memberof VatDeclarationRow
     */
    'percentage': number;
    /**
     * Amount of VAT to be paid to the tax administration per period
     * @type {Array<DineroObject>}
     * @memberof VatDeclarationRow
     */
    'values': Array<DineroObject>;
}
/**
 *
 * @export
 * @interface VatGroupRequest
 */
export interface VatGroupRequest {
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroupRequest
     */
    'name': string;
    /**
     * Whether this group should be hidden in the financial overviews when its value is zero
     * @type {boolean}
     * @memberof VatGroupRequest
     */
    'deleted': boolean;
    /**
     * Whether this group should be hidden from transactions
     * @type {boolean}
     * @memberof VatGroupRequest
     */
    'hidden': boolean;
    /**
     * VAT percentage
     * @type {number}
     * @memberof VatGroupRequest
     */
    'percentage': number;
}
/**
 *
 * @export
 * @interface VatGroupResponse
 */
export interface VatGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof VatGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof VatGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof VatGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof VatGroupResponse
     */
    'version'?: number;
    /**
     * Percentage of VAT
     * @type {number}
     * @memberof VatGroupResponse
     */
    'percentage': number;
    /**
     * Whether VAT should be hidden
     * @type {boolean}
     * @memberof VatGroupResponse
     */
    'hidden': boolean;
    /**
     * Name of the VAT group
     * @type {string}
     * @memberof VatGroupResponse
     */
    'name'?: string;
    /**
     * Whether this group is soft-deleted
     * @type {boolean}
     * @memberof VatGroupResponse
     */
    'deleted': boolean;
}
/**
 *
 * @export
 * @interface VoucherGroupRequest
 */
export interface VoucherGroupRequest {
    /**
     * Name of the group
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'name': string;
    /**
     * Date from which the included cards are active
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'activeStartDate': string;
    /**
     * Date from which cards are no longer active
     * @type {string}
     * @memberof VoucherGroupRequest
     */
    'activeEndDate': string;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof VoucherGroupRequest
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the voucher group
     * @type {number}
     * @memberof VoucherGroupRequest
     */
    'amount': number;
}
/**
 *
 * @export
 * @interface VoucherGroupResponse
 */
export interface VoucherGroupResponse {
    /**
     * The unique id of the entity.
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'id': number;
    /**
     * The creation Date of the entity.
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'createdAt'?: string;
    /**
     * The last update Date of the entity.
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'updatedAt'?: string;
    /**
     * The version of the entity.
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'version'?: number;
    /**
     * Name of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'name': string;
    /**
     * Start date of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'activeStartDate'?: string;
    /**
     * End date of the voucher group
     * @type {string}
     * @memberof VoucherGroupResponse
     */
    'activeEndDate': string;
    /**
     * Users in the voucher group
     * @type {Array<UserResponse>}
     * @memberof VoucherGroupResponse
     */
    'users': Array<UserResponse>;
    /**
     *
     * @type {DineroObjectRequest}
     * @memberof VoucherGroupResponse
     */
    'balance': DineroObjectRequest;
    /**
     * Amount of users to be assigned to the voucher group
     * @type {number}
     * @memberof VoucherGroupResponse
     */
    'amount': number;
}
/**
 * AuthenticateApi - axios parameter creator
 * @export
 */
export declare const AuthenticateApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary EAN login and hand out token
     * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eanAuthentication: (authenticationEanRequest: AuthenticationEanRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisLDAPAuthentication: (authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisPinAuthentication: (gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisWebAuthentication: (gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Key login and hand out token.
     * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyAuthentication: (authenticationKeyRequest: AuthenticationKeyRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ldapAuthentication: (authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Local login and hand out token
     * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    localAuthentication: (authenticationLocalRequest: AuthenticationLocalRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Mock login and hand out token.
     * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mockAuthentication: (authenticationMockRequest: AuthenticationMockRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary NFC login and hand out token
     * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfcAuthentication: (authenticationNfcRequest: AuthenticationNfcRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary PIN login and hand out token
     * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pinAuthentication: (authenticationPinRequest: AuthenticationPinRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Creates a reset token for the local authentication
     * @param {ResetLocalRequest} resetLocalRequest The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocal: (resetLocalRequest: ResetLocalRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocalWithToken: (authenticationResetTokenRequest: AuthenticationResetTokenRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AuthenticateApi - functional programming interface
 * @export
 */
export declare const AuthenticateApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary EAN login and hand out token
     * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eanAuthentication(authenticationEanRequest: AuthenticationEanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisLDAPAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisPinAuthentication(gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisWebAuthentication(gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary Key login and hand out token.
     * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyAuthentication(authenticationKeyRequest: AuthenticationKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ldapAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary Local login and hand out token
     * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    localAuthentication(authenticationLocalRequest: AuthenticationLocalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary Mock login and hand out token.
     * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mockAuthentication(authenticationMockRequest: AuthenticationMockRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary NFC login and hand out token
     * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfcAuthentication(authenticationNfcRequest: AuthenticationNfcRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary PIN login and hand out token
     * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pinAuthentication(authenticationPinRequest: AuthenticationPinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary Creates a reset token for the local authentication
     * @param {ResetLocalRequest} resetLocalRequest The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocal(resetLocalRequest: ResetLocalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocalWithToken(authenticationResetTokenRequest: AuthenticationResetTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * AuthenticateApi - factory interface
 * @export
 */
export declare const AuthenticateApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary EAN login and hand out token
     * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eanAuthentication(authenticationEanRequest: AuthenticationEanRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisLDAPAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisPinAuthentication(gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gewisWebAuthentication(gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary Key login and hand out token.
     * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyAuthentication(authenticationKeyRequest: AuthenticationKeyRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ldapAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary Local login and hand out token
     * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    localAuthentication(authenticationLocalRequest: AuthenticationLocalRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary Mock login and hand out token.
     * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mockAuthentication(authenticationMockRequest: AuthenticationMockRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary NFC login and hand out token
     * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfcAuthentication(authenticationNfcRequest: AuthenticationNfcRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary PIN login and hand out token
     * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pinAuthentication(authenticationPinRequest: AuthenticationPinRequest, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary Creates a reset token for the local authentication
     * @param {ResetLocalRequest} resetLocalRequest The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocal(resetLocalRequest: ResetLocalRequest, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetLocalWithToken(authenticationResetTokenRequest: AuthenticationResetTokenRequest, options?: any): AxiosPromise<void>;
};
/**
 * AuthenticateApi - object-oriented interface
 * @export
 * @class AuthenticateApi
 * @extends {BaseAPI}
 */
export declare class AuthenticateApi extends BaseAPI {
    /**
     *
     * @summary EAN login and hand out token
     * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    eanAuthentication(authenticationEanRequest: AuthenticationEanRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisLDAPAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisPinAuthentication(gEWISAuthenticationPinRequest: GEWISAuthenticationPinRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisWebAuthentication(gewiswebAuthenticationRequest: GewiswebAuthenticationRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary Key login and hand out token.
     * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    keyAuthentication(authenticationKeyRequest: AuthenticationKeyRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    ldapAuthentication(authenticationLDAPRequest: AuthenticationLDAPRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary Local login and hand out token
     * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    localAuthentication(authenticationLocalRequest: AuthenticationLocalRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary Mock login and hand out token.
     * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    mockAuthentication(authenticationMockRequest: AuthenticationMockRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary NFC login and hand out token
     * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    nfcAuthentication(authenticationNfcRequest: AuthenticationNfcRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary PIN login and hand out token
     * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    pinAuthentication(authenticationPinRequest: AuthenticationPinRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    refreshToken(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary Creates a reset token for the local authentication
     * @param {ResetLocalRequest} resetLocalRequest The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    resetLocal(resetLocalRequest: ResetLocalRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    resetLocalWithToken(authenticationResetTokenRequest: AuthenticationResetTokenRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * BalanceApi - axios parameter creator
 * @export
 */
export declare const BalanceApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Get balance of the current user
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {boolean} [hasFine] Only users with(out) fines
     * @param {number} [minFine] Minimum fine
     * @param {number} [maxFine] Maximum fine
     * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
     * @param {string} [orderBy] Column to order balance by - eg: id,amount
     * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBalance: (date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userTypes?: GetAllBalanceUserTypesEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceId: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalances: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BalanceApi - functional programming interface
 * @export
 */
export declare const BalanceApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Get balance of the current user
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {boolean} [hasFine] Only users with(out) fines
     * @param {number} [minFine] Minimum fine
     * @param {number} [maxFine] Maximum fine
     * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
     * @param {string} [orderBy] Column to order balance by - eg: id,amount
     * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userTypes?: GetAllBalanceUserTypesEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceResponse>>>;
    /**
     *
     * @summary Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>>;
    /**
     *
     * @summary Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalances(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResponse>>;
};
/**
 * BalanceApi - factory interface
 * @export
 */
export declare const BalanceApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Get balance of the current user
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {boolean} [hasFine] Only users with(out) fines
     * @param {number} [minFine] Minimum fine
     * @param {number} [maxFine] Maximum fine
     * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
     * @param {string} [orderBy] Column to order balance by - eg: id,amount
     * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userTypes?: GetAllBalanceUserTypesEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, take?: number, skip?: number, options?: any): AxiosPromise<Array<BalanceResponse>>;
    /**
     *
     * @summary Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceId(id: number, options?: any): AxiosPromise<BalanceResponse>;
    /**
     *
     * @summary Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalances(options?: any): AxiosPromise<BalanceResponse>;
};
/**
 * BalanceApi - object-oriented interface
 * @export
 * @class BalanceApi
 * @extends {BaseAPI}
 */
export declare class BalanceApi extends BaseAPI {
    /**
     *
     * @summary Get balance of the current user
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {boolean} [hasFine] Only users with(out) fines
     * @param {number} [minFine] Minimum fine
     * @param {number} [maxFine] Maximum fine
     * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
     * @param {string} [orderBy] Column to order balance by - eg: id,amount
     * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getAllBalance(date?: string, minBalance?: number, maxBalance?: number, hasFine?: boolean, minFine?: number, maxFine?: number, userTypes?: GetAllBalanceUserTypesEnum, orderBy?: string, orderDirection?: GetAllBalanceOrderDirectionEnum, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<BalanceResponse[], any>>;
    /**
     *
     * @summary Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getBalanceId(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<BalanceResponse, any>>;
    /**
     *
     * @summary Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getBalances(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<BalanceResponse, any>>;
}
/**
 * @export
 */
export declare const GetAllBalanceUserTypesEnum: {};
export type GetAllBalanceUserTypesEnum = typeof GetAllBalanceUserTypesEnum[keyof typeof GetAllBalanceUserTypesEnum];
/**
 * @export
 */
export declare const GetAllBalanceOrderDirectionEnum: {
    readonly Asc: "ASC";
    readonly Desc: "DESC";
};
export type GetAllBalanceOrderDirectionEnum = typeof GetAllBalanceOrderDirectionEnum[keyof typeof GetAllBalanceOrderDirectionEnum];
/**
 * BannersApi - axios parameter creator
 * @export
 */
export declare const BannersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Saves a banner to the database
     * @param {BannerRequest} bannerRequest The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: (bannerRequest: BannerRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActive: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBanners: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOpenBanners: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBanner: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} bannerRequest The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: (id: number, bannerRequest: BannerRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateImage: (id: number, file?: File, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BannersApi - functional programming interface
 * @export
 */
export declare const BannersApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Saves a banner to the database
     * @param {BannerRequest} bannerRequest The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(bannerRequest: BannerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>>;
    /**
     *
     * @summary Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActive(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>>;
    /**
     *
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>>;
    /**
     *
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOpenBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBannerResponse>>;
    /**
     *
     * @summary Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBanner(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>>;
    /**
     *
     * @summary Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} bannerRequest The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(id: number, bannerRequest: BannerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BannerResponse>>;
    /**
     *
     * @summary Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateImage(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * BannersApi - factory interface
 * @export
 */
export declare const BannersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(id: number, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Saves a banner to the database
     * @param {BannerRequest} bannerRequest The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(bannerRequest: BannerRequest, options?: any): AxiosPromise<BannerResponse>;
    /**
     *
     * @summary Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActive(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse>;
    /**
     *
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBanners(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse>;
    /**
     *
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOpenBanners(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBannerResponse>;
    /**
     *
     * @summary Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBanner(id: number, options?: any): AxiosPromise<BannerResponse>;
    /**
     *
     * @summary Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} bannerRequest The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(id: number, bannerRequest: BannerRequest, options?: any): AxiosPromise<BannerResponse>;
    /**
     *
     * @summary Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateImage(id: number, file?: File, options?: any): AxiosPromise<void>;
};
/**
 * BannersApi - object-oriented interface
 * @export
 * @class BannersApi
 * @extends {BaseAPI}
 */
export declare class BannersApi extends BaseAPI {
    /**
     *
     * @summary Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    _delete(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Saves a banner to the database
     * @param {BannerRequest} bannerRequest The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    create(bannerRequest: BannerRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<BannerResponse, any>>;
    /**
     *
     * @summary Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getActive(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBannerResponse, any>>;
    /**
     *
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getAllBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBannerResponse, any>>;
    /**
     *
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getAllOpenBanners(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBannerResponse, any>>;
    /**
     *
     * @summary Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getBanner(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<BannerResponse, any>>;
    /**
     *
     * @summary Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} bannerRequest The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    update(id: number, bannerRequest: BannerRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<BannerResponse, any>>;
    /**
     *
     * @summary Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    updateImage(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * ContainersApi - axios parameter creator
 * @export
 */
export declare const ContainersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new container.
     * @param {CreateContainerRequest} createContainerRequest    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContainer: (createContainerRequest: CreateContainerRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllContainers: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductsContainer: (id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicContainers: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleContainer: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContainer: (id: number, updateContainerRequest: UpdateContainerRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ContainersApi - functional programming interface
 * @export
 */
export declare const ContainersApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new container.
     * @param {CreateContainerRequest} createContainerRequest    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContainer(createContainerRequest: CreateContainerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>>;
    /**
     *
     * @summary Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>>;
    /**
     *
     * @summary Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductsContainer(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>>;
    /**
     *
     * @summary Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>>;
    /**
     *
     * @summary Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleContainer(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>>;
    /**
     *
     * @summary Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContainer(id: number, updateContainerRequest: UpdateContainerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerWithProductsResponse>>;
};
/**
 * ContainersApi - factory interface
 * @export
 */
export declare const ContainersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create a new container.
     * @param {CreateContainerRequest} createContainerRequest    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContainer(createContainerRequest: CreateContainerRequest, options?: any): AxiosPromise<ContainerWithProductsResponse>;
    /**
     *
     * @summary Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllContainers(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse>;
    /**
     *
     * @summary Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductsContainer(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse>;
    /**
     *
     * @summary Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicContainers(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse>;
    /**
     *
     * @summary Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleContainer(id: number, options?: any): AxiosPromise<ContainerWithProductsResponse>;
    /**
     *
     * @summary Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContainer(id: number, updateContainerRequest: UpdateContainerRequest, options?: any): AxiosPromise<ContainerWithProductsResponse>;
};
/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export declare class ContainersApi extends BaseAPI {
    /**
     *
     * @summary Create a new container.
     * @param {CreateContainerRequest} createContainerRequest    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    createContainer(createContainerRequest: CreateContainerRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ContainerWithProductsResponse, any>>;
    /**
     *
     * @summary Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getAllContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedContainerResponse, any>>;
    /**
     *
     * @summary Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getProductsContainer(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductResponse, any>>;
    /**
     *
     * @summary Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getPublicContainers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedContainerResponse, any>>;
    /**
     *
     * @summary Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getSingleContainer(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ContainerWithProductsResponse, any>>;
    /**
     *
     * @summary Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    updateContainer(id: number, updateContainerRequest: UpdateContainerRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ContainerWithProductsResponse, any>>;
}
/**
 * DebtorsApi - axios parameter creator
 * @export
 */
export declare const DebtorsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
     * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
     * @param {Array<number>} [userTypes] List of all user types fines should be calculated for 1 (MEMBER), 2 (ORGAN), 3 (VOUCHER), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    calculateFines: (referenceDates: Array<string>, userTypes?: Array<number>, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a fine
     * @param {number} id The id of the fine which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFine: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
     * @param {HandoutFinesRequest} handoutFinesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handoutFines: (handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Send an email to all given users about their possible future fine.
     * @param {HandoutFinesRequest} handoutFinesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    notifyAboutFutureFines: (handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all fine handout events
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    returnAllFineHandoutEvents: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all fine handout events
     * @param {number} id The id of the fine handout event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    returnSingleFineHandoutEvent: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * DebtorsApi - functional programming interface
 * @export
 */
export declare const DebtorsApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
     * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
     * @param {Array<number>} [userTypes] List of all user types fines should be calculated for 1 (MEMBER), 2 (ORGAN), 3 (VOUCHER), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    calculateFines(referenceDates: Array<string>, userTypes?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserToFineResponse>>>;
    /**
     *
     * @summary Delete a fine
     * @param {number} id The id of the fine which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFine(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
     * @param {HandoutFinesRequest} handoutFinesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handoutFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineHandoutEventResponse>>;
    /**
     *
     * @summary Send an email to all given users about their possible future fine.
     * @param {HandoutFinesRequest} handoutFinesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    notifyAboutFutureFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get all fine handout events
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    returnAllFineHandoutEvents(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFineHandoutEventResponse>>;
    /**
     *
     * @summary Get all fine handout events
     * @param {number} id The id of the fine handout event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    returnSingleFineHandoutEvent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineHandoutEventResponse>>;
};
/**
 * DebtorsApi - factory interface
 * @export
 */
export declare const DebtorsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
     * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
     * @param {Array<number>} [userTypes] List of all user types fines should be calculated for 1 (MEMBER), 2 (ORGAN), 3 (VOUCHER), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    calculateFines(referenceDates: Array<string>, userTypes?: Array<number>, options?: any): AxiosPromise<Array<UserToFineResponse>>;
    /**
     *
     * @summary Delete a fine
     * @param {number} id The id of the fine which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFine(id: number, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
     * @param {HandoutFinesRequest} handoutFinesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handoutFines(handoutFinesRequest: HandoutFinesRequest, options?: any): AxiosPromise<FineHandoutEventResponse>;
    /**
     *
     * @summary Send an email to all given users about their possible future fine.
     * @param {HandoutFinesRequest} handoutFinesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    notifyAboutFutureFines(handoutFinesRequest: HandoutFinesRequest, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Get all fine handout events
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    returnAllFineHandoutEvents(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedFineHandoutEventResponse>;
    /**
     *
     * @summary Get all fine handout events
     * @param {number} id The id of the fine handout event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    returnSingleFineHandoutEvent(id: number, options?: any): AxiosPromise<FineHandoutEventResponse>;
};
/**
 * DebtorsApi - object-oriented interface
 * @export
 * @class DebtorsApi
 * @extends {BaseAPI}
 */
export declare class DebtorsApi extends BaseAPI {
    /**
     *
     * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
     * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
     * @param {Array<number>} [userTypes] List of all user types fines should be calculated for 1 (MEMBER), 2 (ORGAN), 3 (VOUCHER), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    calculateFines(referenceDates: Array<string>, userTypes?: Array<number>, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<UserToFineResponse[], any>>;
    /**
     *
     * @summary Delete a fine
     * @param {number} id The id of the fine which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    deleteFine(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
     * @param {HandoutFinesRequest} handoutFinesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    handoutFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FineHandoutEventResponse, any>>;
    /**
     *
     * @summary Send an email to all given users about their possible future fine.
     * @param {HandoutFinesRequest} handoutFinesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    notifyAboutFutureFines(handoutFinesRequest: HandoutFinesRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Get all fine handout events
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    returnAllFineHandoutEvents(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedFineHandoutEventResponse, any>>;
    /**
     *
     * @summary Get all fine handout events
     * @param {number} id The id of the fine handout event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    returnSingleFineHandoutEvent(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FineHandoutEventResponse, any>>;
}
/**
 * EventsApi - axios parameter creator
 * @export
 */
export declare const EventsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Change the assignment of users to shifts on an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignEventShift: (eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create an event with its corresponding answers objects
     * @param {CreateEventRequest} createEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEvent: (createEventRequest: CreateEventRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create an event shift
     * @param {CreateShiftRequest} createShiftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEventShift: (createShiftRequest: CreateShiftRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete an event with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEvent: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete an event shift with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventShift: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all event shifts
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllEventShifts: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all events
     * @param {string} [name] Name of the event
     * @param {number} [createdById] ID of user that created the event
     * @param {string} [beforeDate] Get only events that start after this date
     * @param {string} [afterDate] Get only events that start before this date
     * @param {string} [type] Get only events that are this type
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllEvents: (name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get the number of times a user has been selected for the given shift
     * @param {number} id The id of the event shift
     * @param {string} [eventType] Only include events of this type
     * @param {string} [afterDate] Only include events after this date
     * @param {string} [beforeDate] Only include events before this date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventShiftCount: (id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a single event with its answers and shifts
     * @param {number} id The id of the event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleEvent: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update an event with its corresponding answers objects
     * @param {number} id The id of the event which should be returned
     * @param {UpdateEventRequest} updateEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEvent: (id: number, updateEventRequest: UpdateEventRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update an event shift
     * @param {number} id The id of the event which should be returned
     * @param {UpdateShiftRequest} updateShiftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEventShift: (id: number, updateShiftRequest: UpdateShiftRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update the availability of a user for a shift in an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEventShiftAvailability: (eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * EventsApi - functional programming interface
 * @export
 */
export declare const EventsApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Change the assignment of users to shifts on an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignEventShift(eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEventAnswerResponse>>;
    /**
     *
     * @summary Create an event with its corresponding answers objects
     * @param {CreateEventRequest} createEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEvent(createEventRequest: CreateEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>>;
    /**
     *
     * @summary Create an event shift
     * @param {CreateShiftRequest} createShiftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEventShift(createShiftRequest: CreateShiftRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventShiftResponse>>;
    /**
     *
     * @summary Delete an event with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEvent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Delete an event shift with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventShift(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get all event shifts
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllEventShifts(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEventShiftResponse>>;
    /**
     *
     * @summary Get all events
     * @param {string} [name] Name of the event
     * @param {number} [createdById] ID of user that created the event
     * @param {string} [beforeDate] Get only events that start after this date
     * @param {string} [afterDate] Get only events that start before this date
     * @param {string} [type] Get only events that are this type
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseEventResponse>>;
    /**
     *
     * @summary Get the number of times a user has been selected for the given shift
     * @param {number} id The id of the event shift
     * @param {string} [eventType] Only include events of this type
     * @param {string} [afterDate] Only include events after this date
     * @param {string} [beforeDate] Only include events before this date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventShiftCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaginatedEventShiftResponse>>>;
    /**
     *
     * @summary Get a single event with its answers and shifts
     * @param {number} id The id of the event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleEvent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>>;
    /**
     *
     * @summary Update an event with its corresponding answers objects
     * @param {number} id The id of the event which should be returned
     * @param {UpdateEventRequest} updateEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEvent(id: number, updateEventRequest: UpdateEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>>;
    /**
     *
     * @summary Update an event shift
     * @param {number} id The id of the event which should be returned
     * @param {UpdateShiftRequest} updateShiftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEventShift(id: number, updateShiftRequest: UpdateShiftRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventShiftResponse>>;
    /**
     *
     * @summary Update the availability of a user for a shift in an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEventAnswerResponse>>;
};
/**
 * EventsApi - factory interface
 * @export
 */
export declare const EventsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Change the assignment of users to shifts on an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignEventShift(eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options?: any): AxiosPromise<BaseEventAnswerResponse>;
    /**
     *
     * @summary Create an event with its corresponding answers objects
     * @param {CreateEventRequest} createEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEvent(createEventRequest: CreateEventRequest, options?: any): AxiosPromise<EventResponse>;
    /**
     *
     * @summary Create an event shift
     * @param {CreateShiftRequest} createShiftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEventShift(createShiftRequest: CreateShiftRequest, options?: any): AxiosPromise<EventShiftResponse>;
    /**
     *
     * @summary Delete an event with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEvent(id: number, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Delete an event shift with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventShift(id: number, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Get all event shifts
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllEventShifts(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedEventShiftResponse>;
    /**
     *
     * @summary Get all events
     * @param {string} [name] Name of the event
     * @param {number} [createdById] ID of user that created the event
     * @param {string} [beforeDate] Get only events that start after this date
     * @param {string} [afterDate] Get only events that start before this date
     * @param {string} [type] Get only events that are this type
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseEventResponse>;
    /**
     *
     * @summary Get the number of times a user has been selected for the given shift
     * @param {number} id The id of the event shift
     * @param {string} [eventType] Only include events of this type
     * @param {string} [afterDate] Only include events after this date
     * @param {string} [beforeDate] Only include events before this date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventShiftCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: any): AxiosPromise<Array<PaginatedEventShiftResponse>>;
    /**
     *
     * @summary Get a single event with its answers and shifts
     * @param {number} id The id of the event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleEvent(id: number, options?: any): AxiosPromise<EventResponse>;
    /**
     *
     * @summary Update an event with its corresponding answers objects
     * @param {number} id The id of the event which should be returned
     * @param {UpdateEventRequest} updateEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEvent(id: number, updateEventRequest: UpdateEventRequest, options?: any): AxiosPromise<EventResponse>;
    /**
     *
     * @summary Update an event shift
     * @param {number} id The id of the event which should be returned
     * @param {UpdateShiftRequest} updateShiftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEventShift(id: number, updateShiftRequest: UpdateShiftRequest, options?: any): AxiosPromise<EventShiftResponse>;
    /**
     *
     * @summary Update the availability of a user for a shift in an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options?: any): AxiosPromise<BaseEventAnswerResponse>;
};
/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export declare class EventsApi extends BaseAPI {
    /**
     *
     * @summary Change the assignment of users to shifts on an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    assignEventShift(eventId: number, shiftId: number, userId: number, eventAnswerAssignmentRequest: EventAnswerAssignmentRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<BaseEventAnswerResponse, any>>;
    /**
     *
     * @summary Create an event with its corresponding answers objects
     * @param {CreateEventRequest} createEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    createEvent(createEventRequest: CreateEventRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<EventResponse, any>>;
    /**
     *
     * @summary Create an event shift
     * @param {CreateShiftRequest} createShiftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    createEventShift(createShiftRequest: CreateShiftRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<EventShiftResponse, any>>;
    /**
     *
     * @summary Delete an event with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    deleteEvent(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Delete an event shift with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    deleteEventShift(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Get all event shifts
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getAllEventShifts(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedEventShiftResponse, any>>;
    /**
     *
     * @summary Get all events
     * @param {string} [name] Name of the event
     * @param {number} [createdById] ID of user that created the event
     * @param {string} [beforeDate] Get only events that start after this date
     * @param {string} [afterDate] Get only events that start before this date
     * @param {string} [type] Get only events that are this type
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getAllEvents(name?: string, createdById?: number, beforeDate?: string, afterDate?: string, type?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBaseEventResponse, any>>;
    /**
     *
     * @summary Get the number of times a user has been selected for the given shift
     * @param {number} id The id of the event shift
     * @param {string} [eventType] Only include events of this type
     * @param {string} [afterDate] Only include events after this date
     * @param {string} [beforeDate] Only include events before this date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getEventShiftCount(id: number, eventType?: string, afterDate?: string, beforeDate?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedEventShiftResponse[], any>>;
    /**
     *
     * @summary Get a single event with its answers and shifts
     * @param {number} id The id of the event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getSingleEvent(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<EventResponse, any>>;
    /**
     *
     * @summary Update an event with its corresponding answers objects
     * @param {number} id The id of the event which should be returned
     * @param {UpdateEventRequest} updateEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    updateEvent(id: number, updateEventRequest: UpdateEventRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<EventResponse, any>>;
    /**
     *
     * @summary Update an event shift
     * @param {number} id The id of the event which should be returned
     * @param {UpdateShiftRequest} updateShiftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    updateEventShift(id: number, updateShiftRequest: UpdateShiftRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<EventShiftResponse, any>>;
    /**
     *
     * @summary Update the availability of a user for a shift in an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    updateEventShiftAvailability(eventId: number, shiftId: number, userId: number, eventAnswerAvailabilityRequest: EventAnswerAvailabilityRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<BaseEventAnswerResponse, any>>;
}
/**
 * FilesApi - axios parameter creator
 * @export
 */
export declare const FilesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Upload a file with the given name.
     * @param {string} name The name of the file
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile: (name: string, file?: File, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FilesApi - functional programming interface
 * @export
 */
export declare const FilesApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Upload a file with the given name.
     * @param {string} name The name of the file
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile(name: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleFileResponse>>;
    /**
     *
     * @summary Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
};
/**
 * FilesApi - factory interface
 * @export
 */
export declare const FilesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Upload a file with the given name.
     * @param {string} name The name of the file
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile(name: string, file?: File, options?: any): AxiosPromise<SimpleFileResponse>;
    /**
     *
     * @summary Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(id: number, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(id: number, options?: any): AxiosPromise<string>;
};
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export declare class FilesApi extends BaseAPI {
    /**
     *
     * @summary Upload a file with the given name.
     * @param {string} name The name of the file
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    createFile(name: string, file?: File, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SimpleFileResponse, any>>;
    /**
     *
     * @summary Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteFile(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getFile(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<string, any>>;
}
/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export declare const InvoicesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Adds an invoice to the system.
     * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInvoice: (createInvoiceRequest: CreateInvoiceRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoice: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete invoice user defaults.
     * @param {number} id The id of the invoice user to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoiceUser: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInvoices: (toId?: number, invoiceId?: number, currentState?: GetAllInvoicesCurrentStateEnum, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get an invoice pdf.
     * @param {number} id The id of the invoice to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoicePdf: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleInvoice: (id: number, returnEntries?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get invoice user defaults.
     * @param {number} id The id of the invoice user to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleInvoiceUser: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update or create invoice user defaults.
     * @param {number} id The id of the user to update
     * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putInvoiceUser: (id: number, updateInvoiceUserRequest: UpdateInvoiceUserRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInvoice: (id: number, updateInvoiceRequest: UpdateInvoiceRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * InvoicesApi - functional programming interface
 * @export
 */
export declare const InvoicesApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Adds an invoice to the system.
     * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>>;
    /**
     *
     * @summary Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoice(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Delete invoice user defaults.
     * @param {number} id The id of the invoice user to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoiceUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInvoices(toId?: number, invoiceId?: number, currentState?: GetAllInvoicesCurrentStateEnum, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedInvoiceResponse>>;
    /**
     *
     * @summary Get an invoice pdf.
     * @param {number} id The id of the invoice to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoicePdf(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     *
     * @summary Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleInvoice(id: number, returnEntries?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>>;
    /**
     *
     * @summary Get invoice user defaults.
     * @param {number} id The id of the invoice user to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleInvoiceUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceUserResponse>>;
    /**
     *
     * @summary Update or create invoice user defaults.
     * @param {number} id The id of the user to update
     * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putInvoiceUser(id: number, updateInvoiceUserRequest: UpdateInvoiceUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceUserResponse>>;
    /**
     *
     * @summary Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInvoice(id: number, updateInvoiceRequest: UpdateInvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseInvoiceResponse>>;
};
/**
 * InvoicesApi - factory interface
 * @export
 */
export declare const InvoicesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Adds an invoice to the system.
     * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: any): AxiosPromise<InvoiceResponse>;
    /**
     *
     * @summary Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoice(id: number, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Delete invoice user defaults.
     * @param {number} id The id of the invoice user to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoiceUser(id: number, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInvoices(toId?: number, invoiceId?: number, currentState?: GetAllInvoicesCurrentStateEnum, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedInvoiceResponse>;
    /**
     *
     * @summary Get an invoice pdf.
     * @param {number} id The id of the invoice to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoicePdf(id: number, options?: any): AxiosPromise<string>;
    /**
     *
     * @summary Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleInvoice(id: number, returnEntries?: boolean, options?: any): AxiosPromise<InvoiceResponse>;
    /**
     *
     * @summary Get invoice user defaults.
     * @param {number} id The id of the invoice user to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleInvoiceUser(id: number, options?: any): AxiosPromise<InvoiceUserResponse>;
    /**
     *
     * @summary Update or create invoice user defaults.
     * @param {number} id The id of the user to update
     * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putInvoiceUser(id: number, updateInvoiceUserRequest: UpdateInvoiceUserRequest, options?: any): AxiosPromise<InvoiceUserResponse>;
    /**
     *
     * @summary Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInvoice(id: number, updateInvoiceRequest: UpdateInvoiceRequest, options?: any): AxiosPromise<BaseInvoiceResponse>;
};
/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export declare class InvoicesApi extends BaseAPI {
    /**
     *
     * @summary Adds an invoice to the system.
     * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<InvoiceResponse, any>>;
    /**
     *
     * @summary Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    deleteInvoice(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Delete invoice user defaults.
     * @param {number} id The id of the invoice user to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    deleteInvoiceUser(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getAllInvoices(toId?: number, invoiceId?: number, currentState?: GetAllInvoicesCurrentStateEnum, returnEntries?: boolean, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedInvoiceResponse, any>>;
    /**
     *
     * @summary Get an invoice pdf.
     * @param {number} id The id of the invoice to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getInvoicePdf(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<string, any>>;
    /**
     *
     * @summary Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getSingleInvoice(id: number, returnEntries?: boolean, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<InvoiceResponse, any>>;
    /**
     *
     * @summary Get invoice user defaults.
     * @param {number} id The id of the invoice user to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getSingleInvoiceUser(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<InvoiceUserResponse, any>>;
    /**
     *
     * @summary Update or create invoice user defaults.
     * @param {number} id The id of the user to update
     * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    putInvoiceUser(id: number, updateInvoiceUserRequest: UpdateInvoiceUserRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<InvoiceUserResponse, any>>;
    /**
     *
     * @summary Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    updateInvoice(id: number, updateInvoiceRequest: UpdateInvoiceRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<BaseInvoiceResponse, any>>;
}
/**
 * @export
 */
export declare const GetAllInvoicesCurrentStateEnum: {};
export type GetAllInvoicesCurrentStateEnum = typeof GetAllInvoicesCurrentStateEnum[keyof typeof GetAllInvoicesCurrentStateEnum];
/**
 * PayoutRequestsApi - axios parameter creator
 * @export
 */
export declare const PayoutRequestsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new payout request
     * @param {PayoutRequestRequest} payoutRequestRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayoutRequest: (payoutRequestRequest: PayoutRequestRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all payout requests given the filter parameters
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPayoutRequests: (requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePayoutRequest: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPayoutRequestStatus: (id: number, payoutRequestStatusRequest: PayoutRequestStatusRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * PayoutRequestsApi - functional programming interface
 * @export
 */
export declare const PayoutRequestsApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new payout request
     * @param {PayoutRequestRequest} payoutRequestRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayoutRequest(payoutRequestRequest: PayoutRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>>;
    /**
     *
     * @summary Returns all payout requests given the filter parameters
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPayoutRequests(requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBasePayoutRequestResponse>>;
    /**
     *
     * @summary Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePayoutRequest(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>>;
    /**
     *
     * @summary Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPayoutRequestStatus(id: number, payoutRequestStatusRequest: PayoutRequestStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutRequestResponse>>;
};
/**
 * PayoutRequestsApi - factory interface
 * @export
 */
export declare const PayoutRequestsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create a new payout request
     * @param {PayoutRequestRequest} payoutRequestRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayoutRequest(payoutRequestRequest: PayoutRequestRequest, options?: any): AxiosPromise<PayoutRequestResponse>;
    /**
     *
     * @summary Returns all payout requests given the filter parameters
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPayoutRequests(requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBasePayoutRequestResponse>;
    /**
     *
     * @summary Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePayoutRequest(id: number, options?: any): AxiosPromise<PayoutRequestResponse>;
    /**
     *
     * @summary Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPayoutRequestStatus(id: number, payoutRequestStatusRequest: PayoutRequestStatusRequest, options?: any): AxiosPromise<PayoutRequestResponse>;
};
/**
 * PayoutRequestsApi - object-oriented interface
 * @export
 * @class PayoutRequestsApi
 * @extends {BaseAPI}
 */
export declare class PayoutRequestsApi extends BaseAPI {
    /**
     *
     * @summary Create a new payout request
     * @param {PayoutRequestRequest} payoutRequestRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    createPayoutRequest(payoutRequestRequest: PayoutRequestRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PayoutRequestResponse, any>>;
    /**
     *
     * @summary Returns all payout requests given the filter parameters
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    getAllPayoutRequests(requestedById?: GetAllPayoutRequestsRequestedByIdParameter, approvedById?: GetAllPayoutRequestsRequestedByIdParameter, fromDate?: string, tillDate?: string, status?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBasePayoutRequestResponse, any>>;
    /**
     *
     * @summary Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    getSinglePayoutRequest(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PayoutRequestResponse, any>>;
    /**
     *
     * @summary Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    setPayoutRequestStatus(id: number, payoutRequestStatusRequest: PayoutRequestStatusRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PayoutRequestResponse, any>>;
}
/**
 * PointofsaleApi - axios parameter creator
 * @export
 */
export declare const PointofsaleApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPointOfSale: (createPointOfSaleRequest: CreatePointOfSaleRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleContainers: (id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleProducts: (id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointsOfSale: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePointOfSale: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns a Point of Sale transactions
     * @param {number} id The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions: (id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePointOfSale: (id: number, updatePointOfSaleRequest: UpdatePointOfSaleRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * PointofsaleApi - functional programming interface
 * @export
 */
export declare const PointofsaleApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPointOfSale(createPointOfSaleRequest: CreatePointOfSaleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>>;
    /**
     *
     * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>>;
    /**
     *
     * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>>;
    /**
     *
     * @summary Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointsOfSale(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPointOfSaleResponse>>;
    /**
     *
     * @summary Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePointOfSale(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>>;
    /**
     *
     * @summary Returns a Point of Sale transactions
     * @param {number} id The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>>;
    /**
     *
     * @summary Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePointOfSale(id: number, updatePointOfSaleRequest: UpdatePointOfSaleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointOfSaleWithContainersResponse>>;
};
/**
 * PointofsaleApi - factory interface
 * @export
 */
export declare const PointofsaleApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPointOfSale(createPointOfSaleRequest: CreatePointOfSaleRequest, options?: any): AxiosPromise<PointOfSaleWithContainersResponse>;
    /**
     *
     * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse>;
    /**
     *
     * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse>;
    /**
     *
     * @summary Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPointsOfSale(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedPointOfSaleResponse>;
    /**
     *
     * @summary Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSinglePointOfSale(id: number, options?: any): AxiosPromise<PointOfSaleWithContainersResponse>;
    /**
     *
     * @summary Returns a Point of Sale transactions
     * @param {number} id The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse>;
    /**
     *
     * @summary Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePointOfSale(id: number, updatePointOfSaleRequest: UpdatePointOfSaleRequest, options?: any): AxiosPromise<PointOfSaleWithContainersResponse>;
};
/**
 * PointofsaleApi - object-oriented interface
 * @export
 * @class PointofsaleApi
 * @extends {BaseAPI}
 */
export declare class PointofsaleApi extends BaseAPI {
    /**
     *
     * @summary Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    createPointOfSale(createPointOfSaleRequest: CreatePointOfSaleRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PointOfSaleWithContainersResponse, any>>;
    /**
     *
     * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointOfSaleContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedContainerResponse, any>>;
    /**
     *
     * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointOfSaleProducts(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductResponse, any>>;
    /**
     *
     * @summary Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointsOfSale(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedPointOfSaleResponse, any>>;
    /**
     *
     * @summary Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getSinglePointOfSale(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PointOfSaleWithContainersResponse, any>>;
    /**
     *
     * @summary Returns a Point of Sale transactions
     * @param {number} id The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getTransactions(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBaseTransactionResponse, any>>;
    /**
     *
     * @summary Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    updatePointOfSale(id: number, updatePointOfSaleRequest: UpdatePointOfSaleRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PointOfSaleWithContainersResponse, any>>;
}
/**
 * ProductCategoriesApi - axios parameter creator
 * @export
 */
export declare const ProductCategoriesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Post a new productCategory.
     * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProductCategory: (productCategoryRequest: ProductCategoryRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all existing productcategories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProductCategories: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProductCategory: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductCategory: (id: number, productCategoryRequest: ProductCategoryRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProductCategoriesApi - functional programming interface
 * @export
 */
export declare const ProductCategoriesApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Post a new productCategory.
     * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProductCategory(productCategoryRequest: ProductCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>>;
    /**
     *
     * @summary Returns all existing productcategories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProductCategories(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductCategoryResponse>>;
    /**
     *
     * @summary Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProductCategory(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>>;
    /**
     *
     * @summary Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductCategory(id: number, productCategoryRequest: ProductCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryResponse>>;
};
/**
 * ProductCategoriesApi - factory interface
 * @export
 */
export declare const ProductCategoriesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Post a new productCategory.
     * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProductCategory(productCategoryRequest: ProductCategoryRequest, options?: any): AxiosPromise<ProductCategoryResponse>;
    /**
     *
     * @summary Returns all existing productcategories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProductCategories(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductCategoryResponse>;
    /**
     *
     * @summary Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProductCategory(id: number, options?: any): AxiosPromise<ProductCategoryResponse>;
    /**
     *
     * @summary Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductCategory(id: number, productCategoryRequest: ProductCategoryRequest, options?: any): AxiosPromise<ProductCategoryResponse>;
};
/**
 * ProductCategoriesApi - object-oriented interface
 * @export
 * @class ProductCategoriesApi
 * @extends {BaseAPI}
 */
export declare class ProductCategoriesApi extends BaseAPI {
    /**
     *
     * @summary Post a new productCategory.
     * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    createProductCategory(productCategoryRequest: ProductCategoryRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductCategoryResponse, any>>;
    /**
     *
     * @summary Returns all existing productcategories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    getAllProductCategories(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductCategoryResponse, any>>;
    /**
     *
     * @summary Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    getSingleProductCategory(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductCategoryResponse, any>>;
    /**
     *
     * @summary Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    updateProductCategory(id: number, productCategoryRequest: ProductCategoryRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductCategoryResponse, any>>;
}
/**
 * ProductsApi - axios parameter creator
 * @export
 */
export declare const ProductsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new product.
     * @param {CreateProductRequest} createProductRequest The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProduct: (createProductRequest: CreateProductRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProducts: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProduct: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} updateProductRequest The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProduct: (id: number, updateProductRequest: UpdateProductRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductImage: (id: number, file?: File, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProductsApi - functional programming interface
 * @export
 */
export declare const ProductsApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new product.
     * @param {CreateProductRequest} createProductRequest The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProduct(createProductRequest: CreateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>>;
    /**
     *
     * @summary Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProducts(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>>;
    /**
     *
     * @summary Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProduct(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>>;
    /**
     *
     * @summary Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} updateProductRequest The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProduct(id: number, updateProductRequest: UpdateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>>;
    /**
     *
     * @summary Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductImage(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * ProductsApi - factory interface
 * @export
 */
export declare const ProductsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create a new product.
     * @param {CreateProductRequest} createProductRequest The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProduct(createProductRequest: CreateProductRequest, options?: any): AxiosPromise<ProductResponse>;
    /**
     *
     * @summary Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllProducts(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse>;
    /**
     *
     * @summary Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleProduct(id: number, options?: any): AxiosPromise<ProductResponse>;
    /**
     *
     * @summary Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} updateProductRequest The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProduct(id: number, updateProductRequest: UpdateProductRequest, options?: any): AxiosPromise<ProductResponse>;
    /**
     *
     * @summary Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProductImage(id: number, file?: File, options?: any): AxiosPromise<void>;
};
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export declare class ProductsApi extends BaseAPI {
    /**
     *
     * @summary Create a new product.
     * @param {CreateProductRequest} createProductRequest The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    createProduct(createProductRequest: CreateProductRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductResponse, any>>;
    /**
     *
     * @summary Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getAllProducts(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductResponse, any>>;
    /**
     *
     * @summary Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getSingleProduct(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductResponse, any>>;
    /**
     *
     * @summary Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} updateProductRequest The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    updateProduct(id: number, updateProductRequest: UpdateProductRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ProductResponse, any>>;
    /**
     *
     * @summary Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    updateProductImage(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * RbacApi - axios parameter creator
 * @export
 */
export declare const RbacApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Returns all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRoles: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * RbacApi - functional programming interface
 * @export
 */
export declare const RbacApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Returns all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>>;
};
/**
 * RbacApi - factory interface
 * @export
 */
export declare const RbacApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Returns all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllRoles(options?: any): AxiosPromise<Array<RoleResponse>>;
};
/**
 * RbacApi - object-oriented interface
 * @export
 * @class RbacApi
 * @extends {BaseAPI}
 */
export declare class RbacApi extends BaseAPI {
    /**
     *
     * @summary Returns all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    getAllRoles(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<RoleResponse[], any>>;
}
/**
 * RootApi - axios parameter creator
 * @export
 */
export declare const RootApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Ping the backend to check whether everything is working correctly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * RootApi - functional programming interface
 * @export
 */
export declare const RootApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Ping the backend to check whether everything is working correctly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
};
/**
 * RootApi - factory interface
 * @export
 */
export declare const RootApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Ping the backend to check whether everything is working correctly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<string>;
};
/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export declare class RootApi extends BaseAPI {
    /**
     *
     * @summary Ping the backend to check whether everything is working correctly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    ping(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<string, any>>;
}
/**
 * StripeApi - axios parameter creator
 * @export
 */
export declare const StripeApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Start the stripe deposit flow
     * @param {StripeRequest} stripeRequest The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deposit: (stripeRequest: StripeRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * StripeApi - functional programming interface
 * @export
 */
export declare const StripeApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Start the stripe deposit flow
     * @param {StripeRequest} stripeRequest The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deposit(stripeRequest: StripeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentIntentResponse>>;
};
/**
 * StripeApi - factory interface
 * @export
 */
export declare const StripeApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Start the stripe deposit flow
     * @param {StripeRequest} stripeRequest The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deposit(stripeRequest: StripeRequest, options?: any): AxiosPromise<StripePaymentIntentResponse>;
};
/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export declare class StripeApi extends BaseAPI {
    /**
     *
     * @summary Start the stripe deposit flow
     * @param {StripeRequest} stripeRequest The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    deposit(stripeRequest: StripeRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<StripePaymentIntentResponse, any>>;
}
/**
 * TestOperationsOfTheTestControllerApi - axios parameter creator
 * @export
 */
export declare const TestOperationsOfTheTestControllerApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    helloworld: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TestOperationsOfTheTestControllerApi - functional programming interface
 * @export
 */
export declare const TestOperationsOfTheTestControllerApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    helloworld(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * TestOperationsOfTheTestControllerApi - factory interface
 * @export
 */
export declare const TestOperationsOfTheTestControllerApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    helloworld(options?: any): AxiosPromise<void>;
};
/**
 * TestOperationsOfTheTestControllerApi - object-oriented interface
 * @export
 * @class TestOperationsOfTheTestControllerApi
 * @extends {BaseAPI}
 */
export declare class TestOperationsOfTheTestControllerApi extends BaseAPI {
    /**
     *
     * @summary Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestOperationsOfTheTestControllerApi
     */
    helloworld(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export declare const TransactionsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Creates a new transaction
     * @param {TransactionRequest} transactionRequest The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransaction: (transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransaction: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransactions: (fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransaction: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transactionRequest The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTransaction: (id: number, transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transactionRequest The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateTransaction: (transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TransactionsApi - functional programming interface
 * @export
 */
export declare const TransactionsApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Creates a new transaction
     * @param {TransactionRequest} transactionRequest The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransaction(transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>>;
    /**
     *
     * @summary Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransaction(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>>;
    /**
     *
     * @summary Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransaction(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>>;
    /**
     *
     * @summary Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transactionRequest The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTransaction(id: number, transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>>;
    /**
     *
     * @summary Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transactionRequest The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateTransaction(transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>>;
};
/**
 * TransactionsApi - factory interface
 * @export
 */
export declare const TransactionsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Creates a new transaction
     * @param {TransactionRequest} transactionRequest The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransaction(transactionRequest: TransactionRequest, options?: any): AxiosPromise<TransactionResponse>;
    /**
     *
     * @summary Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransaction(id: number, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse>;
    /**
     *
     * @summary Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransaction(id: number, options?: any): AxiosPromise<TransactionResponse>;
    /**
     *
     * @summary Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transactionRequest The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTransaction(id: number, transactionRequest: TransactionRequest, options?: any): AxiosPromise<TransactionResponse>;
    /**
     *
     * @summary Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transactionRequest The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateTransaction(transactionRequest: TransactionRequest, options?: any): AxiosPromise<boolean>;
};
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export declare class TransactionsApi extends BaseAPI {
    /**
     *
     * @summary Creates a new transaction
     * @param {TransactionRequest} transactionRequest The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    createTransaction(transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<TransactionResponse, any>>;
    /**
     *
     * @summary Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    deleteTransaction(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getAllTransactions(fromId?: number, createdById?: number, toId?: number, pointOfSaleId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBaseTransactionResponse, any>>;
    /**
     *
     * @summary Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getSingleTransaction(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<TransactionResponse, any>>;
    /**
     *
     * @summary Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transactionRequest The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    updateTransaction(id: number, transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<TransactionResponse, any>>;
    /**
     *
     * @summary Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transactionRequest The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    validateTransaction(transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<boolean, any>>;
}
/**
 * TransfersApi - axios parameter creator
 * @export
 */
export declare const TransfersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Post a new transfer.
     * @param {TransferRequest} transferRequest The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer: (transferRequest: TransferRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransfers: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransfer: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TransfersApi - functional programming interface
 * @export
 */
export declare const TransfersApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Post a new transfer.
     * @param {TransferRequest} transferRequest The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer(transferRequest: TransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferResponse>>;
    /**
     *
     * @summary Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransfers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransferResponse>>>;
    /**
     *
     * @summary Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransfer(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferResponse>>;
};
/**
 * TransfersApi - factory interface
 * @export
 */
export declare const TransfersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Post a new transfer.
     * @param {TransferRequest} transferRequest The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer(transferRequest: TransferRequest, options?: any): AxiosPromise<TransferResponse>;
    /**
     *
     * @summary Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTransfers(take?: number, skip?: number, options?: any): AxiosPromise<Array<TransferResponse>>;
    /**
     *
     * @summary Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleTransfer(id: number, options?: any): AxiosPromise<TransferResponse>;
};
/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export declare class TransfersApi extends BaseAPI {
    /**
     *
     * @summary Post a new transfer.
     * @param {TransferRequest} transferRequest The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createTransfer(transferRequest: TransferRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<TransferResponse, any>>;
    /**
     *
     * @summary Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getAllTransfers(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<TransferResponse[], any>>;
    /**
     *
     * @summary Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getSingleTransfer(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<TransferResponse, any>>;
}
/**
 * UsersApi - axios parameter creator
 * @export
 */
export declare const UsersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptTos: (acceptTosRequest: AcceptTosRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticateAs: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create a new user
     * @param {CreateUserRequest} createUserRequest The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: (createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserKey: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserNfc: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsers: (take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersOfUserType: (userType: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndividualUser: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get an organs members
     * @param {number} id The id of the user
     * @param {number} [take] How many members the endpoint should return
     * @param {number} [skip] How many members should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganMembers: (id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAuthenticatable: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserRoles: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersContainers: (id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all financial mutations of a user (from or to).
     * @param {number} id The id of the user to get the mutations from
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersFinancialMutations: (id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersPointsOfSale: (id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProcessingDeposits: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProducts: (id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get transactions from a user.
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactions: (id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactionsReport: (id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get transfers to or from an user.
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransfers: (id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} updateUserRequest The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: (id: number, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserKey: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} updateLocalRequest    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserLocalPassword: (id: number, updateLocalRequest: UpdateLocalRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserNfc: (id: number, updateNfcRequest: UpdateNfcRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPin: (id: number, updatePinRequest: UpdatePinRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Waive all given user\'s fines
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waiveUserFines: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UsersApi - functional programming interface
 * @export
 */
export declare const UsersApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptTos(acceptTosRequest: AcceptTosRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticateAs(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>>;
    /**
     *
     * @summary Create a new user
     * @param {CreateUserRequest} createUserRequest The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>>;
    /**
     *
     * @summary Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserKey(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserNfc(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>>;
    /**
     *
     * @summary Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>>;
    /**
     *
     * @summary Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndividualUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>>;
    /**
     *
     * @summary Get an organs members
     * @param {number} id The id of the user
     * @param {number} [take] How many members the endpoint should return
     * @param {number} [skip] How many members should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganMembers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserResponse>>;
    /**
     *
     * @summary Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAuthenticatable(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>>;
    /**
     *
     * @summary Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserRoles(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>>;
    /**
     *
     * @summary Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContainerResponse>>;
    /**
     *
     * @summary Get all financial mutations of a user (from or to).
     * @param {number} id The id of the user to get the mutations from
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFinancialMutationResponse>>;
    /**
     *
     * @summary Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPointOfSaleResponse>>;
    /**
     *
     * @summary Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProcessingDeposits(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleResponse>>>;
    /**
     *
     * @summary Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProducts(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>>;
    /**
     *
     * @summary Get transactions from a user.
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBaseTransactionResponse>>;
    /**
     *
     * @summary Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionReportResponse>>>;
    /**
     *
     * @summary Get transfers to or from an user.
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTransferResponse>>;
    /**
     *
     * @summary Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} updateUserRequest The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(id: number, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>>;
    /**
     *
     * @summary POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserKey(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateKeyResponse>>;
    /**
     *
     * @summary Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} updateLocalRequest    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserLocalPassword(id: number, updateLocalRequest: UpdateLocalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserNfc(id: number, updateNfcRequest: UpdateNfcRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPin(id: number, updatePinRequest: UpdatePinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Waive all given user\'s fines
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waiveUserFines(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UsersApi - factory interface
 * @export
 */
export declare const UsersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptTos(acceptTosRequest: AcceptTosRequest, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticateAs(id: number, options?: any): AxiosPromise<AuthenticationResponse>;
    /**
     *
     * @summary Create a new user
     * @param {CreateUserRequest} createUserRequest The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(createUserRequest: CreateUserRequest, options?: any): AxiosPromise<UserResponse>;
    /**
     *
     * @summary Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(id: number, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserKey(id: number, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserNfc(id: number, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options?: any): AxiosPromise<PaginatedUserResponse>;
    /**
     *
     * @summary Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedUserResponse>;
    /**
     *
     * @summary Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIndividualUser(id: number, options?: any): AxiosPromise<UserResponse>;
    /**
     *
     * @summary Get an organs members
     * @param {number} id The id of the user
     * @param {number} [take] How many members the endpoint should return
     * @param {number} [skip] How many members should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganMembers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedUserResponse>;
    /**
     *
     * @summary Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAuthenticatable(id: number, options?: any): AxiosPromise<Array<UserResponse>>;
    /**
     *
     * @summary Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserRoles(id: number, options?: any): AxiosPromise<Array<RoleResponse>>;
    /**
     *
     * @summary Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersContainers(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedContainerResponse>;
    /**
     *
     * @summary Get all financial mutations of a user (from or to).
     * @param {number} id The id of the user to get the mutations from
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedFinancialMutationResponse>;
    /**
     *
     * @summary Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedPointOfSaleResponse>;
    /**
     *
     * @summary Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProcessingDeposits(id: number, options?: any): AxiosPromise<Array<RoleResponse>>;
    /**
     *
     * @summary Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersProducts(id: number, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedProductResponse>;
    /**
     *
     * @summary Get transactions from a user.
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedBaseTransactionResponse>;
    /**
     *
     * @summary Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: any): AxiosPromise<Array<TransactionReportResponse>>;
    /**
     *
     * @summary Get transfers to or from an user.
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: any): AxiosPromise<PaginatedTransferResponse>;
    /**
     *
     * @summary Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} updateUserRequest The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(id: number, updateUserRequest: UpdateUserRequest, options?: any): AxiosPromise<UserResponse>;
    /**
     *
     * @summary POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserKey(id: number, options?: any): AxiosPromise<UpdateKeyResponse>;
    /**
     *
     * @summary Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} updateLocalRequest    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserLocalPassword(id: number, updateLocalRequest: UpdateLocalRequest, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserNfc(id: number, updateNfcRequest: UpdateNfcRequest, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPin(id: number, updatePinRequest: UpdatePinRequest, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Waive all given user\'s fines
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waiveUserFines(id: number, options?: any): AxiosPromise<void>;
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export declare class UsersApi extends BaseAPI {
    /**
     *
     * @summary Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    acceptTos(acceptTosRequest: AcceptTosRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    authenticateAs(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AuthenticationResponse, any>>;
    /**
     *
     * @summary Create a new user
     * @param {CreateUserRequest} createUserRequest The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<UserResponse, any>>;
    /**
     *
     * @summary Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUser(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUserKey(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUserNfc(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getAllUsers(take?: number, skip?: number, search?: string, active?: boolean, ofAge?: boolean, id?: number, type?: GetAllUsersTypeEnum, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedUserResponse, any>>;
    /**
     *
     * @summary Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getAllUsersOfUserType(userType: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedUserResponse, any>>;
    /**
     *
     * @summary Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getIndividualUser(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<UserResponse, any>>;
    /**
     *
     * @summary Get an organs members
     * @param {number} id The id of the user
     * @param {number} [take] How many members the endpoint should return
     * @param {number} [skip] How many members should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getOrganMembers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedUserResponse, any>>;
    /**
     *
     * @summary Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserAuthenticatable(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<UserResponse[], any>>;
    /**
     *
     * @summary Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserRoles(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<RoleResponse[], any>>;
    /**
     *
     * @summary Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersContainers(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedContainerResponse, any>>;
    /**
     *
     * @summary Get all financial mutations of a user (from or to).
     * @param {number} id The id of the user to get the mutations from
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersFinancialMutations(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedFinancialMutationResponse, any>>;
    /**
     *
     * @summary Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersPointsOfSale(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedPointOfSaleResponse, any>>;
    /**
     *
     * @summary Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersProcessingDeposits(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<RoleResponse[], any>>;
    /**
     *
     * @summary Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersProducts(id: number, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedProductResponse, any>>;
    /**
     *
     * @summary Get transactions from a user.
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransactions(id: number, fromId?: number, createdById?: number, toId?: number, productId?: number, productRevision?: number, fromDate?: string, tillDate?: string, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedBaseTransactionResponse, any>>;
    /**
     *
     * @summary Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransactionsReport(id: number, fromDate?: string, tillDate?: string, fromId?: number, toId?: number, exclusiveToId?: boolean, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<TransactionReportResponse[], any>>;
    /**
     *
     * @summary Get transfers to or from an user.
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransfers(id: number, take?: number, skip?: number, fromId?: number, toId?: number, id2?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedTransferResponse, any>>;
    /**
     *
     * @summary Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} updateUserRequest The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUser(id: number, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<UserResponse, any>>;
    /**
     *
     * @summary POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserKey(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<UpdateKeyResponse, any>>;
    /**
     *
     * @summary Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} updateLocalRequest    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserLocalPassword(id: number, updateLocalRequest: UpdateLocalRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserNfc(id: number, updateNfcRequest: UpdateNfcRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserPin(id: number, updatePinRequest: UpdatePinRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Waive all given user\'s fines
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    waiveUserFines(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * @export
 */
export declare const GetAllUsersTypeEnum: {
    readonly Member: "MEMBER";
    readonly Organ: "ORGAN";
    readonly Voucher: "VOUCHER";
    readonly LocalUser: "LOCAL_USER";
    readonly LocalAdmin: "LOCAL_ADMIN";
    readonly Invoice: "INVOICE";
    readonly AutomaticInvoice: "AUTOMATIC_INVOICE";
};
export type GetAllUsersTypeEnum = typeof GetAllUsersTypeEnum[keyof typeof GetAllUsersTypeEnum];
/**
 * VatGroupsApi - axios parameter creator
 * @export
 */
export declare const VatGroupsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new VAT group
     * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVatGroup: (vatGroupRequest: VatGroupRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVatGroups: (vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleVatGroup: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVatDeclarationAmounts: (year: number, period: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVatGroup: (id: number, updateVatGroupRequest: UpdateVatGroupRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * VatGroupsApi - functional programming interface
 * @export
 */
export declare const VatGroupsApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a new VAT group
     * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVatGroup(vatGroupRequest: VatGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroupResponse>>;
    /**
     *
     * @summary Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVatGroupResponse>>;
    /**
     *
     * @summary Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleVatGroup(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroupResponse>>;
    /**
     *
     * @summary Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVatDeclarationAmounts(year: number, period: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVatGroupResponse>>;
    /**
     *
     * @summary Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVatGroup(id: number, updateVatGroupRequest: UpdateVatGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VatGroupResponse>>;
};
/**
 * VatGroupsApi - factory interface
 * @export
 */
export declare const VatGroupsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create a new VAT group
     * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVatGroup(vatGroupRequest: VatGroupRequest, options?: any): AxiosPromise<VatGroupResponse>;
    /**
     *
     * @summary Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: any): AxiosPromise<PaginatedVatGroupResponse>;
    /**
     *
     * @summary Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleVatGroup(id: number, options?: any): AxiosPromise<VatGroupResponse>;
    /**
     *
     * @summary Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVatDeclarationAmounts(year: number, period: string, options?: any): AxiosPromise<PaginatedVatGroupResponse>;
    /**
     *
     * @summary Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVatGroup(id: number, updateVatGroupRequest: UpdateVatGroupRequest, options?: any): AxiosPromise<VatGroupResponse>;
};
/**
 * VatGroupsApi - object-oriented interface
 * @export
 * @class VatGroupsApi
 * @extends {BaseAPI}
 */
export declare class VatGroupsApi extends BaseAPI {
    /**
     *
     * @summary Create a new VAT group
     * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    createVatGroup(vatGroupRequest: VatGroupRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<VatGroupResponse, any>>;
    /**
     *
     * @summary Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getAllVatGroups(vatGroupId?: number, name?: string, percentage?: number, deleted?: boolean, take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedVatGroupResponse, any>>;
    /**
     *
     * @summary Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getSingleVatGroup(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<VatGroupResponse, any>>;
    /**
     *
     * @summary Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getVatDeclarationAmounts(year: number, period: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedVatGroupResponse, any>>;
    /**
     *
     * @summary Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    updateVatGroup(id: number, updateVatGroupRequest: UpdateVatGroupRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<VatGroupResponse, any>>;
}
/**
 * VouchergroupsApi - axios parameter creator
 * @export
 */
export declare const VouchergroupsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Creates a new voucher group
     * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVouchergroup: (voucherGroupRequest: VoucherGroupRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns all existing voucher groups
     * @param {number} [take] How many voucher groups the endpoint should return
     * @param {number} [skip] How many voucher groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVouchergroups: (take?: number, skip?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Returns the requested voucher group
     * @param {number} id The id of the voucher group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVouchergroupId: (id: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Updates the requested voucher group
     * @param {number} id The id of the voucher group which should be updated
     * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVoucherGroup: (id: number, voucherGroupRequest: VoucherGroupRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * VouchergroupsApi - functional programming interface
 * @export
 */
export declare const VouchergroupsApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Creates a new voucher group
     * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVouchergroup(voucherGroupRequest: VoucherGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>>;
    /**
     *
     * @summary Returns all existing voucher groups
     * @param {number} [take] How many voucher groups the endpoint should return
     * @param {number} [skip] How many voucher groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVouchergroups(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVoucherGroupResponse>>;
    /**
     *
     * @summary Returns the requested voucher group
     * @param {number} id The id of the voucher group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVouchergroupId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>>;
    /**
     *
     * @summary Updates the requested voucher group
     * @param {number} id The id of the voucher group which should be updated
     * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVoucherGroup(id: number, voucherGroupRequest: VoucherGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherGroupResponse>>;
};
/**
 * VouchergroupsApi - factory interface
 * @export
 */
export declare const VouchergroupsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Creates a new voucher group
     * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVouchergroup(voucherGroupRequest: VoucherGroupRequest, options?: any): AxiosPromise<VoucherGroupResponse>;
    /**
     *
     * @summary Returns all existing voucher groups
     * @param {number} [take] How many voucher groups the endpoint should return
     * @param {number} [skip] How many voucher groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVouchergroups(take?: number, skip?: number, options?: any): AxiosPromise<PaginatedVoucherGroupResponse>;
    /**
     *
     * @summary Returns the requested voucher group
     * @param {number} id The id of the voucher group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVouchergroupId(id: number, options?: any): AxiosPromise<VoucherGroupResponse>;
    /**
     *
     * @summary Updates the requested voucher group
     * @param {number} id The id of the voucher group which should be updated
     * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVoucherGroup(id: number, voucherGroupRequest: VoucherGroupRequest, options?: any): AxiosPromise<VoucherGroupResponse>;
};
/**
 * VouchergroupsApi - object-oriented interface
 * @export
 * @class VouchergroupsApi
 * @extends {BaseAPI}
 */
export declare class VouchergroupsApi extends BaseAPI {
    /**
     *
     * @summary Creates a new voucher group
     * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    createVouchergroup(voucherGroupRequest: VoucherGroupRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<VoucherGroupResponse, any>>;
    /**
     *
     * @summary Returns all existing voucher groups
     * @param {number} [take] How many voucher groups the endpoint should return
     * @param {number} [skip] How many voucher groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    getAllVouchergroups(take?: number, skip?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedVoucherGroupResponse, any>>;
    /**
     *
     * @summary Returns the requested voucher group
     * @param {number} id The id of the voucher group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    getVouchergroupId(id: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<VoucherGroupResponse, any>>;
    /**
     *
     * @summary Updates the requested voucher group
     * @param {number} id The id of the voucher group which should be updated
     * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    updateVoucherGroup(id: number, voucherGroupRequest: VoucherGroupRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<VoucherGroupResponse, any>>;
}
