"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * sudosos-back-end
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RootApiFp = exports.RootApiAxiosParamCreator = exports.RbacApi = exports.RbacApiFactory = exports.RbacApiFp = exports.RbacApiAxiosParamCreator = exports.ProductsApi = exports.ProductsApiFactory = exports.ProductsApiFp = exports.ProductsApiAxiosParamCreator = exports.ProductCategoriesApi = exports.ProductCategoriesApiFactory = exports.ProductCategoriesApiFp = exports.ProductCategoriesApiAxiosParamCreator = exports.PointofsaleApi = exports.PointofsaleApiFactory = exports.PointofsaleApiFp = exports.PointofsaleApiAxiosParamCreator = exports.PayoutRequestsApi = exports.PayoutRequestsApiFactory = exports.PayoutRequestsApiFp = exports.PayoutRequestsApiAxiosParamCreator = exports.InvoicesApi = exports.InvoicesApiFactory = exports.InvoicesApiFp = exports.InvoicesApiAxiosParamCreator = exports.FilesApi = exports.FilesApiFactory = exports.FilesApiFp = exports.FilesApiAxiosParamCreator = exports.ContainersApi = exports.ContainersApiFactory = exports.ContainersApiFp = exports.ContainersApiAxiosParamCreator = exports.BorrelkaartgroupsApi = exports.BorrelkaartgroupsApiFactory = exports.BorrelkaartgroupsApiFp = exports.BorrelkaartgroupsApiAxiosParamCreator = exports.BannersApi = exports.BannersApiFactory = exports.BannersApiFp = exports.BannersApiAxiosParamCreator = exports.BalanceApi = exports.BalanceApiFactory = exports.BalanceApiFp = exports.BalanceApiAxiosParamCreator = exports.AuthenticateApi = exports.AuthenticateApiFactory = exports.AuthenticateApiFp = exports.AuthenticateApiAxiosParamCreator = void 0;
exports.VatGroupsApi = exports.VatGroupsApiFactory = exports.VatGroupsApiFp = exports.VatGroupsApiAxiosParamCreator = exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.TransfersApi = exports.TransfersApiFactory = exports.TransfersApiFp = exports.TransfersApiAxiosParamCreator = exports.TransactionsApi = exports.TransactionsApiFactory = exports.TransactionsApiFp = exports.TransactionsApiAxiosParamCreator = exports.TestApi = exports.TestApiFactory = exports.TestApiFp = exports.TestApiAxiosParamCreator = exports.StripeApi = exports.StripeApiFactory = exports.StripeApiFp = exports.StripeApiAxiosParamCreator = exports.RootApi = exports.RootApiFactory = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 * AuthenticateApi - axios parameter creator
 * @export
 */
const AuthenticateApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  EAN login and hand out token
         * @param {AuthenticationEanRequest} req The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('eanAuthentication', 'req', req);
            const localVarPath = `/authentication/ean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('gewisLDAPAuthentication', 'req', req);
            const localVarPath = `/authentication/GEWIS/LDAP`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('gewisPinAuthentication', 'req', req);
            const localVarPath = `/authentication/GEWIS/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('gewisWebAuthentication', 'req', req);
            const localVarPath = `/authentication/gewisweb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Key login and hand out token.
         * @param {AuthenticationKeyRequest} req The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('keyAuthentication', 'req', req);
            const localVarPath = `/authentication/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAuthentication: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('ldapAuthentication', 'req', req);
            const localVarPath = `/authentication/LDAP`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Local login and hand out token
         * @param {AuthenticationLocalRequest} req The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('localAuthentication', 'req', req);
            const localVarPath = `/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Mock login and hand out token.
         * @param {AuthenticationMockRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('mockAuthentication', 'req', req);
            const localVarPath = `/authentication/mock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  NFC login and hand out token
         * @param {AuthenticationNfcRequest} req The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('nfcAuthentication', 'req', req);
            const localVarPath = `/authentication/nfc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  PIN login and hand out token
         * @param {AuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('pinAuthentication', 'req', req);
            const localVarPath = `/authentication/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/authentication/refreshToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Creates a reset token for the local authentication
         * @param {ResetLocalRequest} req The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('resetLocal', 'req', req);
            const localVarPath = `/authentication/local/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} req The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken: (req, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'req' is not null or undefined
            (0, common_1.assertParamExists)('resetLocalWithToken', 'req', req);
            const localVarPath = `/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(req, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AuthenticateApiAxiosParamCreator = AuthenticateApiAxiosParamCreator;
/**
 * AuthenticateApi - functional programming interface
 * @export
 */
const AuthenticateApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AuthenticateApiAxiosParamCreator)(configuration);
    return {
        /**
         *  EAN login and hand out token
         * @param {AuthenticationEanRequest} req The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.eanAuthentication(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.gewisLDAPAuthentication(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.gewisPinAuthentication(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.gewisWebAuthentication(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Key login and hand out token.
         * @param {AuthenticationKeyRequest} req The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.keyAuthentication(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAuthentication(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ldapAuthentication(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Local login and hand out token
         * @param {AuthenticationLocalRequest} req The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.localAuthentication(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Mock login and hand out token.
         * @param {AuthenticationMockRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.mockAuthentication(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  NFC login and hand out token
         * @param {AuthenticationNfcRequest} req The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.nfcAuthentication(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  PIN login and hand out token
         * @param {AuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.pinAuthentication(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.refreshToken(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Creates a reset token for the local authentication
         * @param {ResetLocalRequest} req The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetLocal(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} req The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken(req, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetLocalWithToken(req, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AuthenticateApiFp = AuthenticateApiFp;
/**
 * AuthenticateApi - factory interface
 * @export
 */
const AuthenticateApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AuthenticateApiFp)(configuration);
    return {
        /**
         *  EAN login and hand out token
         * @param {AuthenticationEanRequest} req The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication(req, options) {
            return localVarFp.eanAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication(req, options) {
            return localVarFp.gewisLDAPAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication(req, options) {
            return localVarFp.gewisPinAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication(req, options) {
            return localVarFp.gewisWebAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  Key login and hand out token.
         * @param {AuthenticationKeyRequest} req The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication(req, options) {
            return localVarFp.keyAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} req The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAuthentication(req, options) {
            return localVarFp.ldapAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  Local login and hand out token
         * @param {AuthenticationLocalRequest} req The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication(req, options) {
            return localVarFp.localAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  Mock login and hand out token.
         * @param {AuthenticationMockRequest} req The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication(req, options) {
            return localVarFp.mockAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  NFC login and hand out token
         * @param {AuthenticationNfcRequest} req The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication(req, options) {
            return localVarFp.nfcAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  PIN login and hand out token
         * @param {AuthenticationPinRequest} req The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication(req, options) {
            return localVarFp.pinAuthentication(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options) {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         *  Creates a reset token for the local authentication
         * @param {ResetLocalRequest} req The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal(req, options) {
            return localVarFp.resetLocal(req, options).then((request) => request(axios, basePath));
        },
        /**
         *  Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} req The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken(req, options) {
            return localVarFp.resetLocalWithToken(req, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AuthenticateApiFactory = AuthenticateApiFactory;
/**
 * AuthenticateApi - object-oriented interface
 * @export
 * @class AuthenticateApi
 * @extends {BaseAPI}
 */
class AuthenticateApi extends base_1.BaseAPI {
    /**
     *  EAN login and hand out token
     * @param {AuthenticationEanRequest} req The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    eanAuthentication(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).eanAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisLDAPAuthentication(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).gewisLDAPAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisPinAuthentication(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).gewisPinAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisWebAuthentication(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).gewisWebAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Key login and hand out token.
     * @param {AuthenticationKeyRequest} req The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    keyAuthentication(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).keyAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} req The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    ldapAuthentication(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).ldapAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Local login and hand out token
     * @param {AuthenticationLocalRequest} req The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    localAuthentication(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).localAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Mock login and hand out token.
     * @param {AuthenticationMockRequest} req The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    mockAuthentication(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).mockAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  NFC login and hand out token
     * @param {AuthenticationNfcRequest} req The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    nfcAuthentication(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).nfcAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  PIN login and hand out token
     * @param {AuthenticationPinRequest} req The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    pinAuthentication(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).pinAuthentication(req, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    refreshToken(options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Creates a reset token for the local authentication
     * @param {ResetLocalRequest} req The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    resetLocal(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).resetLocal(req, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} req The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    resetLocalWithToken(req, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).resetLocalWithToken(req, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AuthenticateApi = AuthenticateApi;
/**
 * BalanceApi - axios parameter creator
 * @export
 */
const BalanceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Get balance of the current user
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
         * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance: (date, minBalance, maxBalance, orderBy, orderDirection, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/balances/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }
            if (minBalance !== undefined) {
                localVarQueryParameter['minBalance'] = minBalance;
            }
            if (maxBalance !== undefined) {
                localVarQueryParameter['maxBalance'] = maxBalance;
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }
            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getBalanceId', 'id', id);
            const localVarPath = `/balances/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BalanceApiAxiosParamCreator = BalanceApiAxiosParamCreator;
/**
 * BalanceApi - functional programming interface
 * @export
 */
const BalanceApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BalanceApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Get balance of the current user
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
         * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance(date, minBalance, maxBalance, orderBy, orderDirection, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllBalance(date, minBalance, maxBalance, orderBy, orderDirection, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBalanceId(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBalances(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.BalanceApiFp = BalanceApiFp;
/**
 * BalanceApi - factory interface
 * @export
 */
const BalanceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BalanceApiFp)(configuration);
    return {
        /**
         *  Get balance of the current user
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
         * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance(date, minBalance, maxBalance, orderBy, orderDirection, take, skip, options) {
            return localVarFp.getAllBalance(date, minBalance, maxBalance, orderBy, orderDirection, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId(id, options) {
            return localVarFp.getBalanceId(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances(options) {
            return localVarFp.getBalances(options).then((request) => request(axios, basePath));
        },
    };
};
exports.BalanceApiFactory = BalanceApiFactory;
/**
 * BalanceApi - object-oriented interface
 * @export
 * @class BalanceApi
 * @extends {BaseAPI}
 */
class BalanceApi extends base_1.BaseAPI {
    /**
     *  Get balance of the current user
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {'id' | 'amount'} [orderBy] Column to order balance by - eg: id,amount
     * @param {'ASC' | 'DESC'} [orderDirection] Order direction - eg: ASC,DESC
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getAllBalance(date, minBalance, maxBalance, orderBy, orderDirection, take, skip, options) {
        return (0, exports.BalanceApiFp)(this.configuration).getAllBalance(date, minBalance, maxBalance, orderBy, orderDirection, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getBalanceId(id, options) {
        return (0, exports.BalanceApiFp)(this.configuration).getBalanceId(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getBalances(options) {
        return (0, exports.BalanceApiFp)(this.configuration).getBalances(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BalanceApi = BalanceApi;
/**
 * BannersApi - axios parameter creator
 * @export
 */
const BannersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('_delete', 'id', id);
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Saves a banner to the database
         * @param {BannerRequest} banner The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (banner, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'banner' is not null or undefined
            (0, common_1.assertParamExists)('create', 'banner', banner);
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(banner, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/banners/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/open/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getBanner', 'id', id);
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} banner The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: (id, banner, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('update', 'id', id);
            // verify required parameter 'banner' is not null or undefined
            (0, common_1.assertParamExists)('update', 'banner', banner);
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(banner, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage: (id, file, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateImage', 'id', id);
            const localVarPath = `/banners/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BannersApiAxiosParamCreator = BannersApiAxiosParamCreator;
/**
 * BannersApi - functional programming interface
 * @export
 */
const BannersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BannersApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator._delete(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Saves a banner to the database
         * @param {BannerRequest} banner The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(banner, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(banner, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getActive(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllBanners(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllOpenBanners(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBanner(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} banner The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id, banner, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.update(id, banner, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id, file, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateImage(id, file, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.BannersApiFp = BannersApiFp;
/**
 * BannersApi - factory interface
 * @export
 */
const BannersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BannersApiFp)(configuration);
    return {
        /**
         *  Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id, options) {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Saves a banner to the database
         * @param {BannerRequest} banner The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(banner, options) {
            return localVarFp.create(banner, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive(take, skip, options) {
            return localVarFp.getActive(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners(take, skip, options) {
            return localVarFp.getAllBanners(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners(take, skip, options) {
            return localVarFp.getAllOpenBanners(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner(id, options) {
            return localVarFp.getBanner(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} banner The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id, banner, options) {
            return localVarFp.update(id, banner, options).then((request) => request(axios, basePath));
        },
        /**
         *  Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id, file, options) {
            return localVarFp.updateImage(id, file, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BannersApiFactory = BannersApiFactory;
/**
 * BannersApi - object-oriented interface
 * @export
 * @class BannersApi
 * @extends {BaseAPI}
 */
class BannersApi extends base_1.BaseAPI {
    /**
     *  Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    _delete(id, options) {
        return (0, exports.BannersApiFp)(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Saves a banner to the database
     * @param {BannerRequest} banner The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    create(banner, options) {
        return (0, exports.BannersApiFp)(this.configuration).create(banner, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getActive(take, skip, options) {
        return (0, exports.BannersApiFp)(this.configuration).getActive(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getAllBanners(take, skip, options) {
        return (0, exports.BannersApiFp)(this.configuration).getAllBanners(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getAllOpenBanners(take, skip, options) {
        return (0, exports.BannersApiFp)(this.configuration).getAllOpenBanners(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getBanner(id, options) {
        return (0, exports.BannersApiFp)(this.configuration).getBanner(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} banner The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    update(id, banner, options) {
        return (0, exports.BannersApiFp)(this.configuration).update(id, banner, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    updateImage(id, file, options) {
        return (0, exports.BannersApiFp)(this.configuration).updateImage(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BannersApi = BannersApi;
/**
 * BorrelkaartgroupsApi - axios parameter creator
 * @export
 */
const BorrelkaartgroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Creates a new borrelkaart group
         * @param {BorrelkaartGroupRequest} borrelkaartgroup The borrelkaart group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBorrelkaartgroup: (borrelkaartgroup, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'borrelkaartgroup' is not null or undefined
            (0, common_1.assertParamExists)('createBorrelkaartgroup', 'borrelkaartgroup', borrelkaartgroup);
            const localVarPath = `/borrelkaartgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(borrelkaartgroup, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all existing borrelkaart groups
         * @param {number} [take] How many borrelkaart groups the endpoint should return
         * @param {number} [skip] How many borrelkaart groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getALlBorrelkaartgroups: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/borrelkaartgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the requested borrelkaart group
         * @param {number} id The id of the borrelkaart group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBorrelkaartgroupId: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getBorrelkaartgroupId', 'id', id);
            const localVarPath = `/borrelkaartgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Updates the requested borrelkaart group
         * @param {number} id The id of the borrelkaart group which should be updated
         * @param {BorrelkaartGroupRequest} borrelkaartgroup The updated borrelkaart group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBorrelkaartGroup: (id, borrelkaartgroup, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateBorrelkaartGroup', 'id', id);
            // verify required parameter 'borrelkaartgroup' is not null or undefined
            (0, common_1.assertParamExists)('updateBorrelkaartGroup', 'borrelkaartgroup', borrelkaartgroup);
            const localVarPath = `/borrelkaartgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(borrelkaartgroup, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BorrelkaartgroupsApiAxiosParamCreator = BorrelkaartgroupsApiAxiosParamCreator;
/**
 * BorrelkaartgroupsApi - functional programming interface
 * @export
 */
const BorrelkaartgroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BorrelkaartgroupsApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Creates a new borrelkaart group
         * @param {BorrelkaartGroupRequest} borrelkaartgroup The borrelkaart group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBorrelkaartgroup(borrelkaartgroup, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBorrelkaartgroup(borrelkaartgroup, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all existing borrelkaart groups
         * @param {number} [take] How many borrelkaart groups the endpoint should return
         * @param {number} [skip] How many borrelkaart groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getALlBorrelkaartgroups(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getALlBorrelkaartgroups(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the requested borrelkaart group
         * @param {number} id The id of the borrelkaart group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBorrelkaartgroupId(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBorrelkaartgroupId(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Updates the requested borrelkaart group
         * @param {number} id The id of the borrelkaart group which should be updated
         * @param {BorrelkaartGroupRequest} borrelkaartgroup The updated borrelkaart group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBorrelkaartGroup(id, borrelkaartgroup, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBorrelkaartGroup(id, borrelkaartgroup, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.BorrelkaartgroupsApiFp = BorrelkaartgroupsApiFp;
/**
 * BorrelkaartgroupsApi - factory interface
 * @export
 */
const BorrelkaartgroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BorrelkaartgroupsApiFp)(configuration);
    return {
        /**
         *  Creates a new borrelkaart group
         * @param {BorrelkaartGroupRequest} borrelkaartgroup The borrelkaart group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBorrelkaartgroup(borrelkaartgroup, options) {
            return localVarFp.createBorrelkaartgroup(borrelkaartgroup, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing borrelkaart groups
         * @param {number} [take] How many borrelkaart groups the endpoint should return
         * @param {number} [skip] How many borrelkaart groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getALlBorrelkaartgroups(take, skip, options) {
            return localVarFp.getALlBorrelkaartgroups(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested borrelkaart group
         * @param {number} id The id of the borrelkaart group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBorrelkaartgroupId(id, options) {
            return localVarFp.getBorrelkaartgroupId(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Updates the requested borrelkaart group
         * @param {number} id The id of the borrelkaart group which should be updated
         * @param {BorrelkaartGroupRequest} borrelkaartgroup The updated borrelkaart group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBorrelkaartGroup(id, borrelkaartgroup, options) {
            return localVarFp.updateBorrelkaartGroup(id, borrelkaartgroup, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BorrelkaartgroupsApiFactory = BorrelkaartgroupsApiFactory;
/**
 * BorrelkaartgroupsApi - object-oriented interface
 * @export
 * @class BorrelkaartgroupsApi
 * @extends {BaseAPI}
 */
class BorrelkaartgroupsApi extends base_1.BaseAPI {
    /**
     *  Creates a new borrelkaart group
     * @param {BorrelkaartGroupRequest} borrelkaartgroup The borrelkaart group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BorrelkaartgroupsApi
     */
    createBorrelkaartgroup(borrelkaartgroup, options) {
        return (0, exports.BorrelkaartgroupsApiFp)(this.configuration).createBorrelkaartgroup(borrelkaartgroup, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all existing borrelkaart groups
     * @param {number} [take] How many borrelkaart groups the endpoint should return
     * @param {number} [skip] How many borrelkaart groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BorrelkaartgroupsApi
     */
    getALlBorrelkaartgroups(take, skip, options) {
        return (0, exports.BorrelkaartgroupsApiFp)(this.configuration).getALlBorrelkaartgroups(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the requested borrelkaart group
     * @param {number} id The id of the borrelkaart group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BorrelkaartgroupsApi
     */
    getBorrelkaartgroupId(id, options) {
        return (0, exports.BorrelkaartgroupsApiFp)(this.configuration).getBorrelkaartgroupId(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Updates the requested borrelkaart group
     * @param {number} id The id of the borrelkaart group which should be updated
     * @param {BorrelkaartGroupRequest} borrelkaartgroup The updated borrelkaart group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BorrelkaartgroupsApi
     */
    updateBorrelkaartGroup(id, borrelkaartgroup, options) {
        return (0, exports.BorrelkaartgroupsApiFp)(this.configuration).updateBorrelkaartGroup(id, borrelkaartgroup, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BorrelkaartgroupsApi = BorrelkaartgroupsApi;
/**
 * ContainersApi - axios parameter creator
 * @export
 */
const ContainersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Approve a container update.
         * @param {number} id The id of the container update to approve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveContainer: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('approveContainer', 'id', id);
            const localVarPath = `/containers/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Create a new container.
         * @param {CreateContainerRequest} container    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer: (container, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'container' is not null or undefined
            (0, common_1.assertParamExists)('createContainer', 'container', container);
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(container, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getProductsContainer', 'id', id);
            const localVarPath = `/containers/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/containers/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleContainer', 'id', id);
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the requested updated container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleUpdatedContainer: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleUpdatedContainer', 'id', id);
            const localVarPath = `/containers/{id}/update`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all updated containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdatedContainers: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/containers/updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} container    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: (id, container, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateContainer', 'id', id);
            // verify required parameter 'container' is not null or undefined
            (0, common_1.assertParamExists)('updateContainer', 'container', container);
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(container, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ContainersApiAxiosParamCreator = ContainersApiAxiosParamCreator;
/**
 * ContainersApi - functional programming interface
 * @export
 */
const ContainersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ContainersApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Approve a container update.
         * @param {number} id The id of the container update to approve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveContainer(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.approveContainer(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Create a new container.
         * @param {CreateContainerRequest} container    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(container, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createContainer(container, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllContainers(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer(id, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProductsContainer(id, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPublicContainers(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleContainer(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the requested updated container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleUpdatedContainer(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleUpdatedContainer(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all updated containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdatedContainers(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUpdatedContainers(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} container    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(id, container, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateContainer(id, container, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ContainersApiFp = ContainersApiFp;
/**
 * ContainersApi - factory interface
 * @export
 */
const ContainersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ContainersApiFp)(configuration);
    return {
        /**
         *  Approve a container update.
         * @param {number} id The id of the container update to approve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveContainer(id, options) {
            return localVarFp.approveContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new container.
         * @param {CreateContainerRequest} container    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(container, options) {
            return localVarFp.createContainer(container, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers(take, skip, options) {
            return localVarFp.getAllContainers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer(id, take, skip, options) {
            return localVarFp.getProductsContainer(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers(take, skip, options) {
            return localVarFp.getPublicContainers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer(id, options) {
            return localVarFp.getSingleContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested updated container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleUpdatedContainer(id, options) {
            return localVarFp.getSingleUpdatedContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all updated containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdatedContainers(take, skip, options) {
            return localVarFp.getUpdatedContainers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} container    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(id, container, options) {
            return localVarFp.updateContainer(id, container, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ContainersApiFactory = ContainersApiFactory;
/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
class ContainersApi extends base_1.BaseAPI {
    /**
     *  Approve a container update.
     * @param {number} id The id of the container update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    approveContainer(id, options) {
        return (0, exports.ContainersApiFp)(this.configuration).approveContainer(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Create a new container.
     * @param {CreateContainerRequest} container    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    createContainer(container, options) {
        return (0, exports.ContainersApiFp)(this.configuration).createContainer(container, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getAllContainers(take, skip, options) {
        return (0, exports.ContainersApiFp)(this.configuration).getAllContainers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getProductsContainer(id, take, skip, options) {
        return (0, exports.ContainersApiFp)(this.configuration).getProductsContainer(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getPublicContainers(take, skip, options) {
        return (0, exports.ContainersApiFp)(this.configuration).getPublicContainers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getSingleContainer(id, options) {
        return (0, exports.ContainersApiFp)(this.configuration).getSingleContainer(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the requested updated container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getSingleUpdatedContainer(id, options) {
        return (0, exports.ContainersApiFp)(this.configuration).getSingleUpdatedContainer(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all updated containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getUpdatedContainers(take, skip, options) {
        return (0, exports.ContainersApiFp)(this.configuration).getUpdatedContainers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} container    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    updateContainer(id, container, options) {
        return (0, exports.ContainersApiFp)(this.configuration).updateContainer(id, container, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ContainersApi = ContainersApi;
/**
 * FilesApi - axios parameter creator
 * @export
 */
const FilesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Upload a file with the given name.
         * @param {File} [file] null
         * @param {string} [name] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: (file, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteFile', 'id', id);
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getFile', 'id', id);
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FilesApiAxiosParamCreator = FilesApiAxiosParamCreator;
/**
 * FilesApi - functional programming interface
 * @export
 */
const FilesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FilesApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Upload a file with the given name.
         * @param {File} [file] null
         * @param {string} [name] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(file, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createFile(file, name, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFile(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFile(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.FilesApiFp = FilesApiFp;
/**
 * FilesApi - factory interface
 * @export
 */
const FilesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FilesApiFp)(configuration);
    return {
        /**
         *  Upload a file with the given name.
         * @param {File} [file] null
         * @param {string} [name] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(file, name, options) {
            return localVarFp.createFile(file, name, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(id, options) {
            return localVarFp.deleteFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id, options) {
            return localVarFp.getFile(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FilesApiFactory = FilesApiFactory;
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
class FilesApi extends base_1.BaseAPI {
    /**
     *  Upload a file with the given name.
     * @param {File} [file] null
     * @param {string} [name] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    createFile(file, name, options) {
        return (0, exports.FilesApiFp)(this.configuration).createFile(file, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteFile(id, options) {
        return (0, exports.FilesApiFp)(this.configuration).deleteFile(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getFile(id, options) {
        return (0, exports.FilesApiFp)(this.configuration).getFile(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FilesApi = FilesApi;
/**
 * InvoicesApi - axios parameter creator
 * @export
 */
const InvoicesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Adds an invoice to the system.
         * @param {CreateInvoiceRequest} invoice The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice: (invoice, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoice' is not null or undefined
            (0, common_1.assertParamExists)('createInvoice', 'invoice', invoice);
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(invoice, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoice', 'id', id);
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices: (toId, invoiceId, state, returnEntries, fromDate, tillDate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }
            if (invoiceId !== undefined) {
                localVarQueryParameter['invoiceId'] = invoiceId;
            }
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            if (returnEntries !== undefined) {
                localVarQueryParameter['returnEntries'] = returnEntries;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice: (id, returnEntries, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleInvoice', 'id', id);
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (returnEntries !== undefined) {
                localVarQueryParameter['returnEntries'] = returnEntries;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} invoice The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice: (id, invoice, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateInvoice', 'id', id);
            // verify required parameter 'invoice' is not null or undefined
            (0, common_1.assertParamExists)('updateInvoice', 'invoice', invoice);
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(invoice, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InvoicesApiAxiosParamCreator = InvoicesApiAxiosParamCreator;
/**
 * InvoicesApi - functional programming interface
 * @export
 */
const InvoicesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InvoicesApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Adds an invoice to the system.
         * @param {CreateInvoiceRequest} invoice The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(invoice, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createInvoice(invoice, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInvoice(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice(id, returnEntries, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleInvoice(id, returnEntries, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} invoice The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(id, invoice, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateInvoice(id, invoice, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.InvoicesApiFp = InvoicesApiFp;
/**
 * InvoicesApi - factory interface
 * @export
 */
const InvoicesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InvoicesApiFp)(configuration);
    return {
        /**
         *  Adds an invoice to the system.
         * @param {CreateInvoiceRequest} invoice The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(invoice, options) {
            return localVarFp.createInvoice(invoice, options).then((request) => request(axios, basePath));
        },
        /**
         *  Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice(id, options) {
            return localVarFp.deleteInvoice(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, options) {
            return localVarFp.getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice(id, returnEntries, options) {
            return localVarFp.getSingleInvoice(id, returnEntries, options).then((request) => request(axios, basePath));
        },
        /**
         *  Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} invoice The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(id, invoice, options) {
            return localVarFp.updateInvoice(id, invoice, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InvoicesApiFactory = InvoicesApiFactory;
/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
class InvoicesApi extends base_1.BaseAPI {
    /**
     *  Adds an invoice to the system.
     * @param {CreateInvoiceRequest} invoice The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    createInvoice(invoice, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).createInvoice(invoice, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    deleteInvoice(id, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).deleteInvoice(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {number} [state] {1,2,3,4} - Filter based on Invoice State.    Possible values: 1 (CREATED), 2 (SENT), 3 (PAID), 4 (DELETED)
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).getAllInvoices(toId, invoiceId, state, returnEntries, fromDate, tillDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getSingleInvoice(id, returnEntries, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).getSingleInvoice(id, returnEntries, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} invoice The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    updateInvoice(id, invoice, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).updateInvoice(id, invoice, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InvoicesApi = InvoicesApi;
/**
 * PayoutRequestsApi - axios parameter creator
 * @export
 */
const PayoutRequestsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Create a new payout request
         * @param {PayoutRequestRequest} payoutRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest: (payoutRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'payoutRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPayoutRequest', 'payoutRequest', payoutRequest);
            const localVarPath = `/payoutrequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payoutRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all payout requests given the filter parameters
         * @param {string} [requestedById] ID of user(s) who requested a payout
         * @param {string} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests: (requestedById, approvedById, fromDate, tillDate, status, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/payoutrequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (requestedById !== undefined) {
                localVarQueryParameter['requestedById'] = requestedById;
            }
            if (approvedById !== undefined) {
                localVarQueryParameter['approvedById'] = approvedById;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSinglePayoutRequest', 'id', id);
            const localVarPath = `/payoutrequests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} state New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus: (id, state, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('setPayoutRequestStatus', 'id', id);
            // verify required parameter 'state' is not null or undefined
            (0, common_1.assertParamExists)('setPayoutRequestStatus', 'state', state);
            const localVarPath = `/payoutrequests/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(state, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PayoutRequestsApiAxiosParamCreator = PayoutRequestsApiAxiosParamCreator;
/**
 * PayoutRequestsApi - functional programming interface
 * @export
 */
const PayoutRequestsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PayoutRequestsApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Create a new payout request
         * @param {PayoutRequestRequest} payoutRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest(payoutRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPayoutRequest(payoutRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all payout requests given the filter parameters
         * @param {string} [requestedById] ID of user(s) who requested a payout
         * @param {string} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSinglePayoutRequest(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} state New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus(id, state, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.setPayoutRequestStatus(id, state, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PayoutRequestsApiFp = PayoutRequestsApiFp;
/**
 * PayoutRequestsApi - factory interface
 * @export
 */
const PayoutRequestsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PayoutRequestsApiFp)(configuration);
    return {
        /**
         *  Create a new payout request
         * @param {PayoutRequestRequest} payoutRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest(payoutRequest, options) {
            return localVarFp.createPayoutRequest(payoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all payout requests given the filter parameters
         * @param {string} [requestedById] ID of user(s) who requested a payout
         * @param {string} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options) {
            return localVarFp.getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest(id, options) {
            return localVarFp.getSinglePayoutRequest(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} state New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus(id, state, options) {
            return localVarFp.setPayoutRequestStatus(id, state, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PayoutRequestsApiFactory = PayoutRequestsApiFactory;
/**
 * PayoutRequestsApi - object-oriented interface
 * @export
 * @class PayoutRequestsApi
 * @extends {BaseAPI}
 */
class PayoutRequestsApi extends base_1.BaseAPI {
    /**
     *  Create a new payout request
     * @param {PayoutRequestRequest} payoutRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    createPayoutRequest(payoutRequest, options) {
        return (0, exports.PayoutRequestsApiFp)(this.configuration).createPayoutRequest(payoutRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all payout requests given the filter parameters
     * @param {string} [requestedById] ID of user(s) who requested a payout
     * @param {string} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options) {
        return (0, exports.PayoutRequestsApiFp)(this.configuration).getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    getSinglePayoutRequest(id, options) {
        return (0, exports.PayoutRequestsApiFp)(this.configuration).getSinglePayoutRequest(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} state New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    setPayoutRequestStatus(id, state, options) {
        return (0, exports.PayoutRequestsApiFp)(this.configuration).setPayoutRequestStatus(id, state, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PayoutRequestsApi = PayoutRequestsApi;
/**
 * PointofsaleApi - axios parameter creator
 * @export
 */
const PointofsaleApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Approve a Point of Sale update.
         * @param {number} id The id of the Point of Sale update to approve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePointOfSale: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('approvePointOfSale', 'id', id);
            const localVarPath = `/pointsofsale/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale: (pointofsale, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'pointofsale' is not null or undefined
            (0, common_1.assertParamExists)('createPointOfSale', 'pointofsale', pointofsale);
            const localVarPath = `/pointsofsale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(pointofsale, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getAllPointOfSaleContainers', 'id', id);
            const localVarPath = `/pointsofsale/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getAllPointOfSaleProducts', 'id', id);
            const localVarPath = `/pointsofsale/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/pointsofsale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSinglePointOfSale', 'id', id);
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns a single Points of Sale update
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleUpdatedPointOfSale: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleUpdatedPointOfSale', 'id', id);
            const localVarPath = `/pointsofsale/{id}/update`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns a Point of Sale transactions
         * @param {number} id          The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTransactions', 'id', id);
            const localVarPath = `/pointsofsale/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all updated Points of Sale
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdated: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/pointsofsale/updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale: (id, pointofsale, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updatePointOfSale', 'id', id);
            // verify required parameter 'pointofsale' is not null or undefined
            (0, common_1.assertParamExists)('updatePointOfSale', 'pointofsale', pointofsale);
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(pointofsale, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PointofsaleApiAxiosParamCreator = PointofsaleApiAxiosParamCreator;
/**
 * PointofsaleApi - functional programming interface
 * @export
 */
const PointofsaleApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PointofsaleApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Approve a Point of Sale update.
         * @param {number} id The id of the Point of Sale update to approve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePointOfSale(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.approvePointOfSale(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale(pointofsale, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPointOfSale(pointofsale, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers(id, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllPointOfSaleContainers(id, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts(id, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllPointOfSaleProducts(id, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllPointsOfSale(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSinglePointOfSale(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns a single Points of Sale update
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleUpdatedPointOfSale(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleUpdatedPointOfSale(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns a Point of Sale transactions
         * @param {number} id          The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(id, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactions(id, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all updated Points of Sale
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdated(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUpdated(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale(id, pointofsale, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updatePointOfSale(id, pointofsale, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PointofsaleApiFp = PointofsaleApiFp;
/**
 * PointofsaleApi - factory interface
 * @export
 */
const PointofsaleApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PointofsaleApiFp)(configuration);
    return {
        /**
         *  Approve a Point of Sale update.
         * @param {number} id The id of the Point of Sale update to approve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePointOfSale(id, options) {
            return localVarFp.approvePointOfSale(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale(pointofsale, options) {
            return localVarFp.createPointOfSale(pointofsale, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers(id, take, skip, options) {
            return localVarFp.getAllPointOfSaleContainers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts(id, take, skip, options) {
            return localVarFp.getAllPointOfSaleProducts(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale(take, skip, options) {
            return localVarFp.getAllPointsOfSale(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale(id, options) {
            return localVarFp.getSinglePointOfSale(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a single Points of Sale update
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleUpdatedPointOfSale(id, options) {
            return localVarFp.getSingleUpdatedPointOfSale(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a Point of Sale transactions
         * @param {number} id          The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(id, take, skip, options) {
            return localVarFp.getTransactions(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all updated Points of Sale
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdated(take, skip, options) {
            return localVarFp.getUpdated(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale(id, pointofsale, options) {
            return localVarFp.updatePointOfSale(id, pointofsale, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PointofsaleApiFactory = PointofsaleApiFactory;
/**
 * PointofsaleApi - object-oriented interface
 * @export
 * @class PointofsaleApi
 * @extends {BaseAPI}
 */
class PointofsaleApi extends base_1.BaseAPI {
    /**
     *  Approve a Point of Sale update.
     * @param {number} id The id of the Point of Sale update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    approvePointOfSale(id, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).approvePointOfSale(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} pointofsale The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    createPointOfSale(pointofsale, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).createPointOfSale(pointofsale, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointOfSaleContainers(id, take, skip, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getAllPointOfSaleContainers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointOfSaleProducts(id, take, skip, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getAllPointOfSaleProducts(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointsOfSale(take, skip, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getAllPointsOfSale(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getSinglePointOfSale(id, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getSinglePointOfSale(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns a single Points of Sale update
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getSingleUpdatedPointOfSale(id, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getSingleUpdatedPointOfSale(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns a Point of Sale transactions
     * @param {number} id          The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getTransactions(id, take, skip, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getTransactions(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all updated Points of Sale
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getUpdated(take, skip, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getUpdated(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} pointofsale    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    updatePointOfSale(id, pointofsale, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).updatePointOfSale(id, pointofsale, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PointofsaleApi = PointofsaleApi;
/**
 * ProductCategoriesApi - axios parameter creator
 * @export
 */
const ProductCategoriesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Post a new productCategory.
         * @param {ProductCategoryRequest} productCategory The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory: (productCategory, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productCategory' is not null or undefined
            (0, common_1.assertParamExists)('createProductCategory', 'productCategory', productCategory);
            const localVarPath = `/productcategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(productCategory, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all existing productcategories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/productcategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleProductCategory', 'id', id);
            const localVarPath = `/productcategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategory The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory: (id, productCategory, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateProductCategory', 'id', id);
            // verify required parameter 'productCategory' is not null or undefined
            (0, common_1.assertParamExists)('updateProductCategory', 'productCategory', productCategory);
            const localVarPath = `/productcategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(productCategory, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ProductCategoriesApiAxiosParamCreator = ProductCategoriesApiAxiosParamCreator;
/**
 * ProductCategoriesApi - functional programming interface
 * @export
 */
const ProductCategoriesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ProductCategoriesApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Post a new productCategory.
         * @param {ProductCategoryRequest} productCategory The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory(productCategory, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createProductCategory(productCategory, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all existing productcategories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllProductCategories(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleProductCategory(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategory The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory(id, productCategory, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateProductCategory(id, productCategory, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ProductCategoriesApiFp = ProductCategoriesApiFp;
/**
 * ProductCategoriesApi - factory interface
 * @export
 */
const ProductCategoriesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ProductCategoriesApiFp)(configuration);
    return {
        /**
         *  Post a new productCategory.
         * @param {ProductCategoryRequest} productCategory The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory(productCategory, options) {
            return localVarFp.createProductCategory(productCategory, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing productcategories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories(take, skip, options) {
            return localVarFp.getAllProductCategories(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory(id, options) {
            return localVarFp.getSingleProductCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategory The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory(id, productCategory, options) {
            return localVarFp.updateProductCategory(id, productCategory, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ProductCategoriesApiFactory = ProductCategoriesApiFactory;
/**
 * ProductCategoriesApi - object-oriented interface
 * @export
 * @class ProductCategoriesApi
 * @extends {BaseAPI}
 */
class ProductCategoriesApi extends base_1.BaseAPI {
    /**
     *  Post a new productCategory.
     * @param {ProductCategoryRequest} productCategory The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    createProductCategory(productCategory, options) {
        return (0, exports.ProductCategoriesApiFp)(this.configuration).createProductCategory(productCategory, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all existing productcategories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    getAllProductCategories(take, skip, options) {
        return (0, exports.ProductCategoriesApiFp)(this.configuration).getAllProductCategories(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    getSingleProductCategory(id, options) {
        return (0, exports.ProductCategoriesApiFp)(this.configuration).getSingleProductCategory(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategory The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    updateProductCategory(id, productCategory, options) {
        return (0, exports.ProductCategoriesApiFp)(this.configuration).updateProductCategory(id, productCategory, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductCategoriesApi = ProductCategoriesApi;
/**
 * ProductsApi - axios parameter creator
 * @export
 */
const ProductsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Approve a product update.
         * @param {number} id The id of the product update to approve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveProduct: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('approveProduct', 'id', id);
            const localVarPath = `/products/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Create a new product.
         * @param {CreateProductRequest} product The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: (product, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'product' is not null or undefined
            (0, common_1.assertParamExists)('createProduct', 'product', product);
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(product, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleProduct', 'id', id);
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the requested updated product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdateProduct: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUpdateProduct', 'id', id);
            const localVarPath = `/products/{id}/update`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all updated products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdatedProducts: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/products/updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} product The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: (id, product, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateProduct', 'id', id);
            // verify required parameter 'product' is not null or undefined
            (0, common_1.assertParamExists)('updateProduct', 'product', product);
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(product, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage: (id, file, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateProductImage', 'id', id);
            const localVarPath = `/products/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ProductsApiAxiosParamCreator = ProductsApiAxiosParamCreator;
/**
 * ProductsApi - functional programming interface
 * @export
 */
const ProductsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ProductsApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Approve a product update.
         * @param {number} id The id of the product update to approve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveProduct(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.approveProduct(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Create a new product.
         * @param {CreateProductRequest} product The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(product, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createProduct(product, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllProducts(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleProduct(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the requested updated product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdateProduct(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUpdateProduct(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all updated products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdatedProducts(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUpdatedProducts(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} product The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id, product, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateProduct(id, product, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage(id, file, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateProductImage(id, file, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ProductsApiFp = ProductsApiFp;
/**
 * ProductsApi - factory interface
 * @export
 */
const ProductsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ProductsApiFp)(configuration);
    return {
        /**
         *  Approve a product update.
         * @param {number} id The id of the product update to approve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveProduct(id, options) {
            return localVarFp.approveProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new product.
         * @param {CreateProductRequest} product The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(product, options) {
            return localVarFp.createProduct(product, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(take, skip, options) {
            return localVarFp.getAllProducts(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct(id, options) {
            return localVarFp.getSingleProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested updated product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdateProduct(id, options) {
            return localVarFp.getUpdateProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all updated products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpdatedProducts(take, skip, options) {
            return localVarFp.getUpdatedProducts(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} product The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id, product, options) {
            return localVarFp.updateProduct(id, product, options).then((request) => request(axios, basePath));
        },
        /**
         *  Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] null
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage(id, file, options) {
            return localVarFp.updateProductImage(id, file, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ProductsApiFactory = ProductsApiFactory;
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
class ProductsApi extends base_1.BaseAPI {
    /**
     *  Approve a product update.
     * @param {number} id The id of the product update to approve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    approveProduct(id, options) {
        return (0, exports.ProductsApiFp)(this.configuration).approveProduct(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Create a new product.
     * @param {CreateProductRequest} product The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    createProduct(product, options) {
        return (0, exports.ProductsApiFp)(this.configuration).createProduct(product, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getAllProducts(take, skip, options) {
        return (0, exports.ProductsApiFp)(this.configuration).getAllProducts(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getSingleProduct(id, options) {
        return (0, exports.ProductsApiFp)(this.configuration).getSingleProduct(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the requested updated product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getUpdateProduct(id, options) {
        return (0, exports.ProductsApiFp)(this.configuration).getUpdateProduct(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all updated products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getUpdatedProducts(take, skip, options) {
        return (0, exports.ProductsApiFp)(this.configuration).getUpdatedProducts(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} product The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    updateProduct(id, product, options) {
        return (0, exports.ProductsApiFp)(this.configuration).updateProduct(id, product, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] null
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    updateProductImage(id, file, options) {
        return (0, exports.ProductsApiFp)(this.configuration).updateProductImage(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductsApi = ProductsApi;
/**
 * RbacApi - axios parameter creator
 * @export
 */
const RbacApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Returns all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/rbac/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RbacApiAxiosParamCreator = RbacApiAxiosParamCreator;
/**
 * RbacApi - functional programming interface
 * @export
 */
const RbacApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RbacApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Returns all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllRoles(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.RbacApiFp = RbacApiFp;
/**
 * RbacApi - factory interface
 * @export
 */
const RbacApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RbacApiFp)(configuration);
    return {
        /**
         *  Returns all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options) {
            return localVarFp.getAllRoles(options).then((request) => request(axios, basePath));
        },
    };
};
exports.RbacApiFactory = RbacApiFactory;
/**
 * RbacApi - object-oriented interface
 * @export
 * @class RbacApi
 * @extends {BaseAPI}
 */
class RbacApi extends base_1.BaseAPI {
    /**
     *  Returns all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    getAllRoles(options) {
        return (0, exports.RbacApiFp)(this.configuration).getAllRoles(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RbacApi = RbacApi;
/**
 * RootApi - axios parameter creator
 * @export
 */
const RootApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Ping the backend to check whether everything is working correctly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RootApiAxiosParamCreator = RootApiAxiosParamCreator;
/**
 * RootApi - functional programming interface
 * @export
 */
const RootApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RootApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Ping the backend to check whether everything is working correctly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ping(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.RootApiFp = RootApiFp;
/**
 * RootApi - factory interface
 * @export
 */
const RootApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RootApiFp)(configuration);
    return {
        /**
         *  Ping the backend to check whether everything is working correctly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};
exports.RootApiFactory = RootApiFactory;
/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
class RootApi extends base_1.BaseAPI {
    /**
     *  Ping the backend to check whether everything is working correctly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    ping(options) {
        return (0, exports.RootApiFp)(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RootApi = RootApi;
/**
 * StripeApi - axios parameter creator
 * @export
 */
const StripeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Start the stripe deposit flow
         * @param {StripeRequest} stripe The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: (stripe, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'stripe' is not null or undefined
            (0, common_1.assertParamExists)('deposit', 'stripe', stripe);
            const localVarPath = `/stripe/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(stripe, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Webhook for Stripe event updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhook: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/stripe/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.StripeApiAxiosParamCreator = StripeApiAxiosParamCreator;
/**
 * StripeApi - functional programming interface
 * @export
 */
const StripeApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.StripeApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Start the stripe deposit flow
         * @param {StripeRequest} stripe The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(stripe, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deposit(stripe, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Webhook for Stripe event updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhook(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.webhook(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.StripeApiFp = StripeApiFp;
/**
 * StripeApi - factory interface
 * @export
 */
const StripeApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.StripeApiFp)(configuration);
    return {
        /**
         *  Start the stripe deposit flow
         * @param {StripeRequest} stripe The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(stripe, options) {
            return localVarFp.deposit(stripe, options).then((request) => request(axios, basePath));
        },
        /**
         *  Webhook for Stripe event updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhook(options) {
            return localVarFp.webhook(options).then((request) => request(axios, basePath));
        },
    };
};
exports.StripeApiFactory = StripeApiFactory;
/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
class StripeApi extends base_1.BaseAPI {
    /**
     *  Start the stripe deposit flow
     * @param {StripeRequest} stripe The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    deposit(stripe, options) {
        return (0, exports.StripeApiFp)(this.configuration).deposit(stripe, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Webhook for Stripe event updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    webhook(options) {
        return (0, exports.StripeApiFp)(this.configuration).webhook(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StripeApi = StripeApi;
/**
 * TestApi - axios parameter creator
 * @export
 */
const TestApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/test/helloworld`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TestApiAxiosParamCreator = TestApiAxiosParamCreator;
/**
 * TestApi - functional programming interface
 * @export
 */
const TestApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TestApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.helloworld(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TestApiFp = TestApiFp;
/**
 * TestApi - factory interface
 * @export
 */
const TestApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TestApiFp)(configuration);
    return {
        /**
         *  Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld(options) {
            return localVarFp.helloworld(options).then((request) => request(axios, basePath));
        },
    };
};
exports.TestApiFactory = TestApiFactory;
/**
 * TestApi - object-oriented interface
 * @export
 * @class TestApi
 * @extends {BaseAPI}
 */
class TestApi extends base_1.BaseAPI {
    /**
     *  Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    helloworld(options) {
        return (0, exports.TestApiFp)(this.configuration).helloworld(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TestApi = TestApi;
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
const TransactionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Creates a new transaction
         * @param {TransactionRequest} transaction The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: (transaction, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'transaction' is not null or undefined
            (0, common_1.assertParamExists)('createTransaction', 'transaction', transaction);
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transaction, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteTransaction', 'id', id);
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions: (fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }
            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }
            if (pointOfSaleId !== undefined) {
                localVarQueryParameter['pointOfSaleId'] = pointOfSaleId;
            }
            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }
            if (productRevision !== undefined) {
                localVarQueryParameter['productRevision'] = productRevision;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleTransaction', 'id', id);
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transaction The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: (id, transaction, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateTransaction', 'id', id);
            // verify required parameter 'transaction' is not null or undefined
            (0, common_1.assertParamExists)('updateTransaction', 'transaction', transaction);
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transaction, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transaction The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction: (transaction, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'transaction' is not null or undefined
            (0, common_1.assertParamExists)('validateTransaction', 'transaction', transaction);
            const localVarPath = `/transactions/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transaction, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TransactionsApiAxiosParamCreator = TransactionsApiAxiosParamCreator;
/**
 * TransactionsApi - functional programming interface
 * @export
 */
const TransactionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransactionsApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Creates a new transaction
         * @param {TransactionRequest} transaction The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(transaction, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTransaction(transaction, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTransaction(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleTransaction(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transaction The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id, transaction, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTransaction(id, transaction, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transaction The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction(transaction, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.validateTransaction(transaction, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TransactionsApiFp = TransactionsApiFp;
/**
 * TransactionsApi - factory interface
 * @export
 */
const TransactionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransactionsApiFp)(configuration);
    return {
        /**
         *  Creates a new transaction
         * @param {TransactionRequest} transaction The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(transaction, options) {
            return localVarFp.createTransaction(transaction, options).then((request) => request(axios, basePath));
        },
        /**
         *  Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id, options) {
            return localVarFp.deleteTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options) {
            return localVarFp.getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction(id, options) {
            return localVarFp.getSingleTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transaction The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id, transaction, options) {
            return localVarFp.updateTransaction(id, transaction, options).then((request) => request(axios, basePath));
        },
        /**
         *  Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transaction The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction(transaction, options) {
            return localVarFp.validateTransaction(transaction, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransactionsApiFactory = TransactionsApiFactory;
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends base_1.BaseAPI {
    /**
     *  Creates a new transaction
     * @param {TransactionRequest} transaction The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    createTransaction(transaction, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).createTransaction(transaction, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    deleteTransaction(id, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).deleteTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).getAllTransactions(fromId, createdById, toId, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getSingleTransaction(id, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).getSingleTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transaction The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    updateTransaction(id, transaction, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).updateTransaction(id, transaction, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transaction The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    validateTransaction(transaction, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).validateTransaction(transaction, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransactionsApi = TransactionsApi;
/**
 * TransfersApi - axios parameter creator
 * @export
 */
const TransfersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Post a new transfer.
         * @param {TransferRequest} transfer The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: (transfer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'transfer' is not null or undefined
            (0, common_1.assertParamExists)('createTransfer', 'transfer', transfer);
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transfer, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleTransfer', 'id', id);
            const localVarPath = `/transfers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TransfersApiAxiosParamCreator = TransfersApiAxiosParamCreator;
/**
 * TransfersApi - functional programming interface
 * @export
 */
const TransfersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransfersApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Post a new transfer.
         * @param {TransferRequest} transfer The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(transfer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTransfer(transfer, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers(take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllTransfers(take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleTransfer(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TransfersApiFp = TransfersApiFp;
/**
 * TransfersApi - factory interface
 * @export
 */
const TransfersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransfersApiFp)(configuration);
    return {
        /**
         *  Post a new transfer.
         * @param {TransferRequest} transfer The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(transfer, options) {
            return localVarFp.createTransfer(transfer, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers(take, skip, options) {
            return localVarFp.getAllTransfers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer(id, options) {
            return localVarFp.getSingleTransfer(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransfersApiFactory = TransfersApiFactory;
/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
class TransfersApi extends base_1.BaseAPI {
    /**
     *  Post a new transfer.
     * @param {TransferRequest} transfer The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createTransfer(transfer, options) {
        return (0, exports.TransfersApiFp)(this.configuration).createTransfer(transfer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getAllTransfers(take, skip, options) {
        return (0, exports.TransfersApiFp)(this.configuration).getAllTransfers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getSingleTransfer(id, options) {
        return (0, exports.TransfersApiFp)(this.configuration).getSingleTransfer(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransfersApi = TransfersApi;
/**
 * UsersApi - axios parameter creator
 * @export
 */
const UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos: (params, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'params' is not null or undefined
            (0, common_1.assertParamExists)('acceptTos', 'params', params);
            const localVarPath = `/users/acceptTos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(params, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('authenticateAs', 'id', id);
            const localVarPath = `/users/{id}/authenticate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Create a new user
         * @param {CreateUserRequest} user The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: (user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'user' is not null or undefined
            (0, common_1.assertParamExists)('createUser', 'user', user);
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(user, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteUser', 'id', id);
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteUserKey', 'id', id);
            const localVarPath = `/users/{id}/authenticator/key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteUserNfc', 'id', id);
            const localVarPath = `/users/{id}/authenticator/nfc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {number} [type] {1,2,3,4,5,6,7} - Filter based on user type. Possible values:      1 (MEMBER), 2 (ORGAN), 3 (BORRELKAART), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: (take, skip, search, active, ofAge, id, type, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }
            if (ofAge !== undefined) {
                localVarQueryParameter['ofAge'] = ofAge;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType: (userType, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userType' is not null or undefined
            (0, common_1.assertParamExists)('getAllUsersOfUserType', 'userType', userType);
            const localVarPath = `/users/usertype/{userType}`
                .replace(`{${"userType"}}`, encodeURIComponent(String(userType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getIndividualUser', 'id', id);
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get an organs members
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getOrganMembers', 'id', id);
            const localVarPath = `/users/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUserAuthenticatable', 'id', id);
            const localVarPath = `/users/{id}/authenticate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUserRoles', 'id', id);
            const localVarPath = `/users/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersContainers', 'id', id);
            const localVarPath = `/users/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get all financial mutations of a user.
         * @param {number} id The id of the user to get the mutations from
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersFinancialMutations', 'id', id);
            const localVarPath = `/users/{id}/financialmutations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersPointsOfSale', 'id', id);
            const localVarPath = `/users/{id}/pointsofsale`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersProcessingDeposits', 'id', id);
            const localVarPath = `/users/{id}/deposits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersProducts', 'id', id);
            const localVarPath = `/users/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get an user\'s transactions (from, to or created)
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions: (id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersTransactions', 'id', id);
            const localVarPath = `/users/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }
            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }
            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }
            if (productRevision !== undefined) {
                localVarQueryParameter['productRevision'] = productRevision;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactionsReport: (id, fromDate, tillDate, fromId, toId, exclusiveToId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersTransactionsReport', 'id', id);
            const localVarPath = `/users/{id}/transactions/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }
            if (exclusiveToId !== undefined) {
                localVarQueryParameter['exclusiveToId'] = exclusiveToId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get an user\'s transfers
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers: (id, take, skip, fromId, toId, id2, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersTransfers', 'id', id);
            const localVarPath = `/users/{id}/transfers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }
            if (id2 !== undefined) {
                localVarQueryParameter['id'] = id2;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the user\'s updated containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUpdatedContainers: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersUpdatedContainers', 'id', id);
            const localVarPath = `/users/{id}/containers/updated`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the user\'s updated Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUpdatedPointsOfSale: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersUpdatedPointsOfSale', 'id', id);
            const localVarPath = `/users/{id}/pointsofsale/updated`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get an user\'s updated products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUpdatedProducts: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersUpdatedProducts', 'id', id);
            const localVarPath = `/users/{id}/products/updated`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} user The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: (id, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUser', 'id', id);
            // verify required parameter 'user' is not null or undefined
            (0, common_1.assertParamExists)('updateUser', 'user', user);
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(user, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUserKey', 'id', id);
            const localVarPath = `/users/{id}/authenticator/key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} update    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword: (id, update, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUserLocalPassword', 'id', id);
            // verify required parameter 'update' is not null or undefined
            (0, common_1.assertParamExists)('updateUserLocalPassword', 'update', update);
            const localVarPath = `/users/{id}/authenticator/local`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(update, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} update    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc: (id, update, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUserNfc', 'id', id);
            // verify required parameter 'update' is not null or undefined
            (0, common_1.assertParamExists)('updateUserNfc', 'update', update);
            const localVarPath = `/users/{id}/authenticator/nfc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(update, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} update    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin: (id, update, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUserPin', 'id', id);
            // verify required parameter 'update' is not null or undefined
            (0, common_1.assertParamExists)('updateUserPin', 'update', update);
            const localVarPath = `/users/{id}/authenticator/pin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(update, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator;
/**
 * UsersApi - functional programming interface
 * @export
 */
const UsersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UsersApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos(params, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptTos(params, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.authenticateAs(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Create a new user
         * @param {CreateUserRequest} user The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createUser(user, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUser(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserKey(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserNfc(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {number} [type] {1,2,3,4,5,6,7} - Filter based on user type. Possible values:      1 (MEMBER), 2 (ORGAN), 3 (BORRELKAART), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(take, skip, search, active, ofAge, id, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllUsers(take, skip, search, active, ofAge, id, type, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType(userType, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllUsersOfUserType(userType, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getIndividualUser(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get an organs members
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganMembers(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserAuthenticatable(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserRoles(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers(id, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersContainers(id, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get all financial mutations of a user.
         * @param {number} id The id of the user to get the mutations from
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations(id, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersFinancialMutations(id, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale(id, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersPointsOfSale(id, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersProcessingDeposits(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts(id, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersProducts(id, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get an user\'s transactions (from, to or created)
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get an user\'s transfers
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers(id, take, skip, fromId, toId, id2, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersTransfers(id, take, skip, fromId, toId, id2, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the user\'s updated containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUpdatedContainers(id, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersUpdatedContainers(id, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the user\'s updated Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUpdatedPointsOfSale(id, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersUpdatedPointsOfSale(id, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get an user\'s updated products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUpdatedProducts(id, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersUpdatedProducts(id, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} user The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUser(id, user, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserKey(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} update    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword(id, update, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserLocalPassword(id, update, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} update    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc(id, update, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserNfc(id, update, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} update    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin(id, update, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserPin(id, update, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.UsersApiFp = UsersApiFp;
/**
 * UsersApi - factory interface
 * @export
 */
const UsersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UsersApiFp)(configuration);
    return {
        /**
         *  Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos(params, options) {
            return localVarFp.acceptTos(params, options).then((request) => request(axios, basePath));
        },
        /**
         *  Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs(id, options) {
            return localVarFp.authenticateAs(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new user
         * @param {CreateUserRequest} user The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user, options) {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id, options) {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey(id, options) {
            return localVarFp.deleteUserKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc(id, options) {
            return localVarFp.deleteUserNfc(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {number} [type] {1,2,3,4,5,6,7} - Filter based on user type. Possible values:      1 (MEMBER), 2 (ORGAN), 3 (BORRELKAART), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(take, skip, search, active, ofAge, id, type, options) {
            return localVarFp.getAllUsers(take, skip, search, active, ofAge, id, type, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType(userType, take, skip, options) {
            return localVarFp.getAllUsersOfUserType(userType, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser(id, options) {
            return localVarFp.getIndividualUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get an organs members
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers(id, options) {
            return localVarFp.getOrganMembers(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable(id, options) {
            return localVarFp.getUserAuthenticatable(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(id, options) {
            return localVarFp.getUserRoles(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers(id, take, skip, options) {
            return localVarFp.getUsersContainers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all financial mutations of a user.
         * @param {number} id The id of the user to get the mutations from
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations(id, take, skip, options) {
            return localVarFp.getUsersFinancialMutations(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale(id, take, skip, options) {
            return localVarFp.getUsersPointsOfSale(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits(id, options) {
            return localVarFp.getUsersProcessingDeposits(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts(id, take, skip, options) {
            return localVarFp.getUsersProducts(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get an user\'s transactions (from, to or created)
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options) {
            return localVarFp.getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options) {
            return localVarFp.getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get an user\'s transfers
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers(id, take, skip, fromId, toId, id2, options) {
            return localVarFp.getUsersTransfers(id, take, skip, fromId, toId, id2, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the user\'s updated containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUpdatedContainers(id, take, skip, options) {
            return localVarFp.getUsersUpdatedContainers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the user\'s updated Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUpdatedPointsOfSale(id, take, skip, options) {
            return localVarFp.getUsersUpdatedPointsOfSale(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get an user\'s updated products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUpdatedProducts(id, take, skip, options) {
            return localVarFp.getUsersUpdatedProducts(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} user The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id, user, options) {
            return localVarFp.updateUser(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         *  POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey(id, options) {
            return localVarFp.updateUserKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} update    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword(id, update, options) {
            return localVarFp.updateUserLocalPassword(id, update, options).then((request) => request(axios, basePath));
        },
        /**
         *  Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} update    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc(id, update, options) {
            return localVarFp.updateUserNfc(id, update, options).then((request) => request(axios, basePath));
        },
        /**
         *  Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} update    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin(id, update, options) {
            return localVarFp.updateUserPin(id, update, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UsersApiFactory = UsersApiFactory;
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends base_1.BaseAPI {
    /**
     *  Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} params \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    acceptTos(params, options) {
        return (0, exports.UsersApiFp)(this.configuration).acceptTos(params, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    authenticateAs(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).authenticateAs(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Create a new user
     * @param {CreateUserRequest} user The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    createUser(user, options) {
        return (0, exports.UsersApiFp)(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUser(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUserKey(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).deleteUserKey(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUserNfc(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).deleteUserNfc(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {number} [type] {1,2,3,4,5,6,7} - Filter based on user type. Possible values:      1 (MEMBER), 2 (ORGAN), 3 (BORRELKAART), 4 (LOCAL_USER), 5 (LOCAL_ADMIN), 6 (INVOICE), 7 (AUTOMATIC_INVOICE)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getAllUsers(take, skip, search, active, ofAge, id, type, options) {
        return (0, exports.UsersApiFp)(this.configuration).getAllUsers(take, skip, search, active, ofAge, id, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getAllUsersOfUserType(userType, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getAllUsersOfUserType(userType, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getIndividualUser(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).getIndividualUser(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get an organs members
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getOrganMembers(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).getOrganMembers(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserAuthenticatable(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUserAuthenticatable(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserRoles(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUserRoles(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersContainers(id, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersContainers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get all financial mutations of a user.
     * @param {number} id The id of the user to get the mutations from
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersFinancialMutations(id, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersFinancialMutations(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersPointsOfSale(id, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersPointsOfSale(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersProcessingDeposits(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersProcessingDeposits(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersProducts(id, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersProducts(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get an user\'s transactions (from, to or created)
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get an user\'s transfers
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransfers(id, take, skip, fromId, toId, id2, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersTransfers(id, take, skip, fromId, toId, id2, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the user\'s updated containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersUpdatedContainers(id, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersUpdatedContainers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the user\'s updated Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersUpdatedPointsOfSale(id, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersUpdatedPointsOfSale(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get an user\'s updated products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersUpdatedProducts(id, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersUpdatedProducts(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} user The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUser(id, user, options) {
        return (0, exports.UsersApiFp)(this.configuration).updateUser(id, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserKey(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).updateUserKey(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} update    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserLocalPassword(id, update, options) {
        return (0, exports.UsersApiFp)(this.configuration).updateUserLocalPassword(id, update, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} update    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserNfc(id, update, options) {
        return (0, exports.UsersApiFp)(this.configuration).updateUserNfc(id, update, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} update    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserPin(id, update, options) {
        return (0, exports.UsersApiFp)(this.configuration).updateUserPin(id, update, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UsersApi = UsersApi;
/**
 * VatGroupsApi - axios parameter creator
 * @export
 */
const VatGroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Create a new VAT group
         * @param {VatGroupRequest} vatGroup The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup: (vatGroup, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'vatGroup' is not null or undefined
            (0, common_1.assertParamExists)('createVatGroup', 'vatGroup', vatGroup);
            const localVarPath = `/vatgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(vatGroup, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups: (vatGroupId, name, percentage, deleted, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/vatgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (vatGroupId !== undefined) {
                localVarQueryParameter['vatGroupId'] = vatGroupId;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (percentage !== undefined) {
                localVarQueryParameter['percentage'] = percentage;
            }
            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleVatGroup', 'id', id);
            const localVarPath = `/vatgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts: (year, period, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'year' is not null or undefined
            (0, common_1.assertParamExists)('getVatDeclarationAmounts', 'year', year);
            // verify required parameter 'period' is not null or undefined
            (0, common_1.assertParamExists)('getVatDeclarationAmounts', 'period', period);
            const localVarPath = `/vatgroups/declaration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} vatGroup The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup: (id, vatGroup, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateVatGroup', 'id', id);
            // verify required parameter 'vatGroup' is not null or undefined
            (0, common_1.assertParamExists)('updateVatGroup', 'vatGroup', vatGroup);
            const localVarPath = `/vatgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(vatGroup, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.VatGroupsApiAxiosParamCreator = VatGroupsApiAxiosParamCreator;
/**
 * VatGroupsApi - functional programming interface
 * @export
 */
const VatGroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.VatGroupsApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Create a new VAT group
         * @param {VatGroupRequest} vatGroup The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup(vatGroup, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createVatGroup(vatGroup, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleVatGroup(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts(year, period, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVatDeclarationAmounts(year, period, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *  Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} vatGroup The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup(id, vatGroup, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateVatGroup(id, vatGroup, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.VatGroupsApiFp = VatGroupsApiFp;
/**
 * VatGroupsApi - factory interface
 * @export
 */
const VatGroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.VatGroupsApiFp)(configuration);
    return {
        /**
         *  Create a new VAT group
         * @param {VatGroupRequest} vatGroup The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup(vatGroup, options) {
            return localVarFp.createVatGroup(vatGroup, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options) {
            return localVarFp.getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup(id, options) {
            return localVarFp.getSingleVatGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts(year, period, options) {
            return localVarFp.getVatDeclarationAmounts(year, period, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} vatGroup The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup(id, vatGroup, options) {
            return localVarFp.updateVatGroup(id, vatGroup, options).then((request) => request(axios, basePath));
        },
    };
};
exports.VatGroupsApiFactory = VatGroupsApiFactory;
/**
 * VatGroupsApi - object-oriented interface
 * @export
 * @class VatGroupsApi
 * @extends {BaseAPI}
 */
class VatGroupsApi extends base_1.BaseAPI {
    /**
     *  Create a new VAT group
     * @param {VatGroupRequest} vatGroup The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    createVatGroup(vatGroup, options) {
        return (0, exports.VatGroupsApiFp)(this.configuration).createVatGroup(vatGroup, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options) {
        return (0, exports.VatGroupsApiFp)(this.configuration).getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getSingleVatGroup(id, options) {
        return (0, exports.VatGroupsApiFp)(this.configuration).getSingleVatGroup(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getVatDeclarationAmounts(year, period, options) {
        return (0, exports.VatGroupsApiFp)(this.configuration).getVatDeclarationAmounts(year, period, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} vatGroup The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    updateVatGroup(id, vatGroup, options) {
        return (0, exports.VatGroupsApiFp)(this.configuration).updateVatGroup(id, vatGroup, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VatGroupsApi = VatGroupsApi;
//# sourceMappingURL=api.js.map