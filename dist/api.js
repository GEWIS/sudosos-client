"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * sudosos-back-end
 * SudoSOS
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PointofsaleApi = exports.PointofsaleApiFactory = exports.PointofsaleApiFp = exports.PointofsaleApiAxiosParamCreator = exports.PayoutRequestsApi = exports.PayoutRequestsApiFactory = exports.PayoutRequestsApiFp = exports.PayoutRequestsApiAxiosParamCreator = exports.GetAllInvoicesCurrentStateEnum = exports.InvoicesApi = exports.InvoicesApiFactory = exports.InvoicesApiFp = exports.InvoicesApiAxiosParamCreator = exports.FilesApi = exports.FilesApiFactory = exports.FilesApiFp = exports.FilesApiAxiosParamCreator = exports.EventsApi = exports.EventsApiFactory = exports.EventsApiFp = exports.EventsApiAxiosParamCreator = exports.GetFineReportPdfFileTypeEnum = exports.DebtorsApi = exports.DebtorsApiFactory = exports.DebtorsApiFp = exports.DebtorsApiAxiosParamCreator = exports.ContainersApi = exports.ContainersApiFactory = exports.ContainersApiFp = exports.ContainersApiAxiosParamCreator = exports.BannersApi = exports.BannersApiFactory = exports.BannersApiFp = exports.BannersApiAxiosParamCreator = exports.GetAllBalanceOrderDirectionEnum = exports.GetAllBalanceUserTypesEnum = exports.BalanceApi = exports.BalanceApiFactory = exports.BalanceApiFp = exports.BalanceApiAxiosParamCreator = exports.AuthenticateApi = exports.AuthenticateApiFactory = exports.AuthenticateApiFp = exports.AuthenticateApiAxiosParamCreator = exports.UpdateInvoiceRequestStateEnum = exports.PayoutRequestStatusRequestStateEnum = exports.PayoutRequestResponseStatusEnum = exports.InvoiceStatusResponseStateEnum = exports.FinancialMutationResponseTypeEnum = exports.BasePayoutRequestResponseStatusEnum = void 0;
exports.GetUsersPurchaseReportPdfFileTypeEnum = exports.GetAllUsersTypeEnum = exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.TransfersApi = exports.TransfersApiFactory = exports.TransfersApiFp = exports.TransfersApiAxiosParamCreator = exports.TransactionsApi = exports.TransactionsApiFactory = exports.TransactionsApiFp = exports.TransactionsApiAxiosParamCreator = exports.TransactionSummariesApi = exports.TransactionSummariesApiFactory = exports.TransactionSummariesApiFp = exports.TransactionSummariesApiAxiosParamCreator = exports.TestOperationsOfTheTestControllerApi = exports.TestOperationsOfTheTestControllerApiFactory = exports.TestOperationsOfTheTestControllerApiFp = exports.TestOperationsOfTheTestControllerApiAxiosParamCreator = exports.StripeApi = exports.StripeApiFactory = exports.StripeApiFp = exports.StripeApiAxiosParamCreator = exports.ServerSettingsApi = exports.ServerSettingsApiFactory = exports.ServerSettingsApiFp = exports.ServerSettingsApiAxiosParamCreator = exports.SellerPayoutsApi = exports.SellerPayoutsApiFactory = exports.SellerPayoutsApiFp = exports.SellerPayoutsApiAxiosParamCreator = exports.RootApi = exports.RootApiFactory = exports.RootApiFp = exports.RootApiAxiosParamCreator = exports.RbacApi = exports.RbacApiFactory = exports.RbacApiFp = exports.RbacApiAxiosParamCreator = exports.ProductsApi = exports.ProductsApiFactory = exports.ProductsApiFp = exports.ProductsApiAxiosParamCreator = exports.ProductCategoriesApi = exports.ProductCategoriesApiFactory = exports.ProductCategoriesApiFp = exports.ProductCategoriesApiAxiosParamCreator = void 0;
exports.WriteoffsApi = exports.WriteoffsApiFactory = exports.WriteoffsApiFp = exports.WriteoffsApiAxiosParamCreator = exports.VouchergroupsApi = exports.VouchergroupsApiFactory = exports.VouchergroupsApiFp = exports.VouchergroupsApiAxiosParamCreator = exports.VatGroupsApi = exports.VatGroupsApiFactory = exports.VatGroupsApiFp = exports.VatGroupsApiAxiosParamCreator = exports.GetUsersSalesReportPdfFileTypeEnum = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.BasePayoutRequestResponseStatusEnum = {
    Created: 'CREATED',
    Approved: 'APPROVED',
    Denied: 'DENIED',
    Cancelled: 'CANCELLED'
};
exports.FinancialMutationResponseTypeEnum = {
    Transfer: 'transfer',
    Transaction: 'transaction'
};
exports.InvoiceStatusResponseStateEnum = {
    Created: 'CREATED',
    Sent: 'SENT',
    Paid: 'PAID',
    Deleted: 'DELETED'
};
exports.PayoutRequestResponseStatusEnum = {
    Created: 'CREATED',
    Approved: 'APPROVED',
    Denied: 'DENIED',
    Cancelled: 'CANCELLED'
};
exports.PayoutRequestStatusRequestStateEnum = {
    Created: 'CREATED',
    Approved: 'APPROVED',
    Denied: 'DENIED',
    Cancelled: 'CANCELLED'
};
exports.UpdateInvoiceRequestStateEnum = {
    Created: 'CREATED',
    Sent: 'SENT',
    Paid: 'PAID',
    Deleted: 'DELETED'
};
/**
 * AuthenticateApi - axios parameter creator
 * @export
 */
const AuthenticateApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get a JWT token for the given POS
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePointOfSale: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('authenticatePointOfSale', 'id', id);
            const localVarPath = `/authentication/pointofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary EAN login and hand out token
         * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication: (authenticationEanRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authenticationEanRequest' is not null or undefined
            (0, common_1.assertParamExists)('eanAuthentication', 'authenticationEanRequest', authenticationEanRequest);
            const localVarPath = `/authentication/ean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(authenticationEanRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get the GEWISWeb public token used by SudoSOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGEWISWebPublic: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/authentication/gewisweb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication: (authenticationLDAPRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authenticationLDAPRequest' is not null or undefined
            (0, common_1.assertParamExists)('gewisLDAPAuthentication', 'authenticationLDAPRequest', authenticationLDAPRequest);
            const localVarPath = `/authentication/GEWIS/LDAP`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(authenticationLDAPRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication: (gEWISAuthenticationPinRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'gEWISAuthenticationPinRequest' is not null or undefined
            (0, common_1.assertParamExists)('gewisPinAuthentication', 'gEWISAuthenticationPinRequest', gEWISAuthenticationPinRequest);
            const localVarPath = `/authentication/GEWIS/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(gEWISAuthenticationPinRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication: (gewiswebAuthenticationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'gewiswebAuthenticationRequest' is not null or undefined
            (0, common_1.assertParamExists)('gewisWebAuthentication', 'gewiswebAuthenticationRequest', gewiswebAuthenticationRequest);
            const localVarPath = `/authentication/gewisweb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(gewiswebAuthenticationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Key login and hand out token.
         * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication: (authenticationKeyRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authenticationKeyRequest' is not null or undefined
            (0, common_1.assertParamExists)('keyAuthentication', 'authenticationKeyRequest', authenticationKeyRequest);
            const localVarPath = `/authentication/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(authenticationKeyRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAuthentication: (authenticationLDAPRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authenticationLDAPRequest' is not null or undefined
            (0, common_1.assertParamExists)('ldapAuthentication', 'authenticationLDAPRequest', authenticationLDAPRequest);
            const localVarPath = `/authentication/LDAP`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(authenticationLDAPRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Local login and hand out token
         * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication: (authenticationLocalRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authenticationLocalRequest' is not null or undefined
            (0, common_1.assertParamExists)('localAuthentication', 'authenticationLocalRequest', authenticationLocalRequest);
            const localVarPath = `/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(authenticationLocalRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Mock login and hand out token.
         * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication: (authenticationMockRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authenticationMockRequest' is not null or undefined
            (0, common_1.assertParamExists)('mockAuthentication', 'authenticationMockRequest', authenticationMockRequest);
            const localVarPath = `/authentication/mock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(authenticationMockRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary NFC login and hand out token
         * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication: (authenticationNfcRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authenticationNfcRequest' is not null or undefined
            (0, common_1.assertParamExists)('nfcAuthentication', 'authenticationNfcRequest', authenticationNfcRequest);
            const localVarPath = `/authentication/nfc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(authenticationNfcRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary PIN login and hand out token
         * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication: (authenticationPinRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authenticationPinRequest' is not null or undefined
            (0, common_1.assertParamExists)('pinAuthentication', 'authenticationPinRequest', authenticationPinRequest);
            const localVarPath = `/authentication/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(authenticationPinRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/authentication/refreshToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Creates a reset token for the local authentication
         * @param {ResetLocalRequest} resetLocalRequest The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal: (resetLocalRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'resetLocalRequest' is not null or undefined
            (0, common_1.assertParamExists)('resetLocal', 'resetLocalRequest', resetLocalRequest);
            const localVarPath = `/authentication/local/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(resetLocalRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken: (authenticationResetTokenRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'authenticationResetTokenRequest' is not null or undefined
            (0, common_1.assertParamExists)('resetLocalWithToken', 'authenticationResetTokenRequest', authenticationResetTokenRequest);
            const localVarPath = `/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(authenticationResetTokenRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AuthenticateApiAxiosParamCreator = AuthenticateApiAxiosParamCreator;
/**
 * AuthenticateApi - functional programming interface
 * @export
 */
const AuthenticateApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AuthenticateApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get a JWT token for the given POS
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePointOfSale(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.authenticatePointOfSale(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.authenticatePointOfSale']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary EAN login and hand out token
         * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication(authenticationEanRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.eanAuthentication(authenticationEanRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.eanAuthentication']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get the GEWISWeb public token used by SudoSOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGEWISWebPublic(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGEWISWebPublic(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.getGEWISWebPublic']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication(authenticationLDAPRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.gewisLDAPAuthentication(authenticationLDAPRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.gewisLDAPAuthentication']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication(gEWISAuthenticationPinRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.gewisPinAuthentication(gEWISAuthenticationPinRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.gewisPinAuthentication']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication(gewiswebAuthenticationRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.gewisWebAuthentication(gewiswebAuthenticationRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.gewisWebAuthentication']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Key login and hand out token.
         * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication(authenticationKeyRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.keyAuthentication(authenticationKeyRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.keyAuthentication']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAuthentication(authenticationLDAPRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ldapAuthentication(authenticationLDAPRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.ldapAuthentication']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Local login and hand out token
         * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication(authenticationLocalRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.localAuthentication(authenticationLocalRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.localAuthentication']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Mock login and hand out token.
         * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication(authenticationMockRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.mockAuthentication(authenticationMockRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.mockAuthentication']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary NFC login and hand out token
         * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication(authenticationNfcRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.nfcAuthentication(authenticationNfcRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.nfcAuthentication']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary PIN login and hand out token
         * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication(authenticationPinRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.pinAuthentication(authenticationPinRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.pinAuthentication']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.refreshToken(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.refreshToken']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Creates a reset token for the local authentication
         * @param {ResetLocalRequest} resetLocalRequest The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal(resetLocalRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetLocal(resetLocalRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.resetLocal']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken(authenticationResetTokenRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetLocalWithToken(authenticationResetTokenRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['AuthenticateApi.resetLocalWithToken']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.AuthenticateApiFp = AuthenticateApiFp;
/**
 * AuthenticateApi - factory interface
 * @export
 */
const AuthenticateApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AuthenticateApiFp)(configuration);
    return {
        /**
         *
         * @summary Get a JWT token for the given POS
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePointOfSale(id, options) {
            return localVarFp.authenticatePointOfSale(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary EAN login and hand out token
         * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eanAuthentication(authenticationEanRequest, options) {
            return localVarFp.eanAuthentication(authenticationEanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the GEWISWeb public token used by SudoSOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGEWISWebPublic(options) {
            return localVarFp.getGEWISWebPublic(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisLDAPAuthentication(authenticationLDAPRequest, options) {
            return localVarFp.gewisLDAPAuthentication(authenticationLDAPRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary PIN login and hand out token.
         * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisPinAuthentication(gEWISAuthenticationPinRequest, options) {
            return localVarFp.gewisPinAuthentication(gEWISAuthenticationPinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
         * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gewisWebAuthentication(gewiswebAuthenticationRequest, options) {
            return localVarFp.gewisWebAuthentication(gewiswebAuthenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Key login and hand out token.
         * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyAuthentication(authenticationKeyRequest, options) {
            return localVarFp.keyAuthentication(authenticationKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
         * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAuthentication(authenticationLDAPRequest, options) {
            return localVarFp.ldapAuthentication(authenticationLDAPRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Local login and hand out token
         * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localAuthentication(authenticationLocalRequest, options) {
            return localVarFp.localAuthentication(authenticationLocalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Mock login and hand out token.
         * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mockAuthentication(authenticationMockRequest, options) {
            return localVarFp.mockAuthentication(authenticationMockRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary NFC login and hand out token
         * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nfcAuthentication(authenticationNfcRequest, options) {
            return localVarFp.nfcAuthentication(authenticationNfcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary PIN login and hand out token
         * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinAuthentication(authenticationPinRequest, options) {
            return localVarFp.pinAuthentication(authenticationPinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a new JWT token, lesser if the existing token is also lesser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options) {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a reset token for the local authentication
         * @param {ResetLocalRequest} resetLocalRequest The reset info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocal(resetLocalRequest, options) {
            return localVarFp.resetLocal(resetLocalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Reset local authentication using the provided token
         * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetLocalWithToken(authenticationResetTokenRequest, options) {
            return localVarFp.resetLocalWithToken(authenticationResetTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AuthenticateApiFactory = AuthenticateApiFactory;
/**
 * AuthenticateApi - object-oriented interface
 * @export
 * @class AuthenticateApi
 * @extends {BaseAPI}
 */
class AuthenticateApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get a JWT token for the given POS
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    authenticatePointOfSale(id, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).authenticatePointOfSale(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary EAN login and hand out token
     * @param {AuthenticationEanRequest} authenticationEanRequest The EAN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    eanAuthentication(authenticationEanRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).eanAuthentication(authenticationEanRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the GEWISWeb public token used by SudoSOS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    getGEWISWebPublic(options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).getGEWISWebPublic(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary LDAP login and hand out token    If user has never signed in before this also creates an GEWIS account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisLDAPAuthentication(authenticationLDAPRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).gewisLDAPAuthentication(authenticationLDAPRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary PIN login and hand out token.
     * @param {GEWISAuthenticationPinRequest} gEWISAuthenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisPinAuthentication(gEWISAuthenticationPinRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).gewisPinAuthentication(gEWISAuthenticationPinRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GEWIS login verification based on gewisweb JWT tokens. This method verifies the validity of the gewisweb JWT token, and returns a SudoSOS token if the GEWIS token is valid.
     * @param {GewiswebAuthenticationRequest} gewiswebAuthenticationRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    gewisWebAuthentication(gewiswebAuthenticationRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).gewisWebAuthentication(gewiswebAuthenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Key login and hand out token.
     * @param {AuthenticationKeyRequest} authenticationKeyRequest The key login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    keyAuthentication(authenticationKeyRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).keyAuthentication(authenticationKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary LDAP login and hand out token If user has never signed in before this also creates an account.
     * @param {AuthenticationLDAPRequest} authenticationLDAPRequest The LDAP login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    ldapAuthentication(authenticationLDAPRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).ldapAuthentication(authenticationLDAPRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Local login and hand out token
     * @param {AuthenticationLocalRequest} authenticationLocalRequest The local login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    localAuthentication(authenticationLocalRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).localAuthentication(authenticationLocalRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Mock login and hand out token.
     * @param {AuthenticationMockRequest} authenticationMockRequest The mock login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    mockAuthentication(authenticationMockRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).mockAuthentication(authenticationMockRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary NFC login and hand out token
     * @param {AuthenticationNfcRequest} authenticationNfcRequest The NFC login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    nfcAuthentication(authenticationNfcRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).nfcAuthentication(authenticationNfcRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary PIN login and hand out token
     * @param {AuthenticationPinRequest} authenticationPinRequest The PIN login.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    pinAuthentication(authenticationPinRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).pinAuthentication(authenticationPinRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a new JWT token, lesser if the existing token is also lesser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    refreshToken(options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a reset token for the local authentication
     * @param {ResetLocalRequest} resetLocalRequest The reset info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    resetLocal(resetLocalRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).resetLocal(resetLocalRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Reset local authentication using the provided token
     * @param {AuthenticationResetTokenRequest} authenticationResetTokenRequest The reset token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticateApi
     */
    resetLocalWithToken(authenticationResetTokenRequest, options) {
        return (0, exports.AuthenticateApiFp)(this.configuration).resetLocalWithToken(authenticationResetTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AuthenticateApi = AuthenticateApi;
/**
 * BalanceApi - axios parameter creator
 * @export
 */
const BalanceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get the calculated total balances in SudoSOS
         * @param {string} date The date for which to calculate the balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateTotalBalances: (date, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'date' is not null or undefined
            (0, common_1.assertParamExists)('calculateTotalBalances', 'date', date);
            const localVarPath = `/balances/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get balance of all users
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
         * @param {string} [orderBy] Column to order balance by - eg: id,amount
         * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
         * @param {boolean} [allowDeleted] Whether to include deleted users
         * @param {boolean} [inactive] Whether to only return inactive users
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance: (date, minBalance, maxBalance, hasFine, minFine, maxFine, userTypes, orderBy, orderDirection, allowDeleted, inactive, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/balances/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }
            if (minBalance !== undefined) {
                localVarQueryParameter['minBalance'] = minBalance;
            }
            if (maxBalance !== undefined) {
                localVarQueryParameter['maxBalance'] = maxBalance;
            }
            if (hasFine !== undefined) {
                localVarQueryParameter['hasFine'] = hasFine;
            }
            if (minFine !== undefined) {
                localVarQueryParameter['minFine'] = minFine;
            }
            if (maxFine !== undefined) {
                localVarQueryParameter['maxFine'] = maxFine;
            }
            if (userTypes) {
                localVarQueryParameter['userTypes'] = userTypes;
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }
            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }
            if (allowDeleted !== undefined) {
                localVarQueryParameter['allowDeleted'] = allowDeleted;
            }
            if (inactive !== undefined) {
                localVarQueryParameter['inactive'] = inactive;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getBalanceId', 'id', id);
            const localVarPath = `/balances/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BalanceApiAxiosParamCreator = BalanceApiAxiosParamCreator;
/**
 * BalanceApi - functional programming interface
 * @export
 */
const BalanceApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BalanceApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get the calculated total balances in SudoSOS
         * @param {string} date The date for which to calculate the balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateTotalBalances(date, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.calculateTotalBalances(date, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BalanceApi.calculateTotalBalances']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get balance of all users
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
         * @param {string} [orderBy] Column to order balance by - eg: id,amount
         * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
         * @param {boolean} [allowDeleted] Whether to include deleted users
         * @param {boolean} [inactive] Whether to only return inactive users
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userTypes, orderBy, orderDirection, allowDeleted, inactive, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userTypes, orderBy, orderDirection, allowDeleted, inactive, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BalanceApi.getAllBalance']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBalanceId(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BalanceApi.getBalanceId']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBalances(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BalanceApi.getBalances']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.BalanceApiFp = BalanceApiFp;
/**
 * BalanceApi - factory interface
 * @export
 */
const BalanceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BalanceApiFp)(configuration);
    return {
        /**
         *
         * @summary Get the calculated total balances in SudoSOS
         * @param {string} date The date for which to calculate the balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateTotalBalances(date, options) {
            return localVarFp.calculateTotalBalances(date, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get balance of all users
         * @param {string} [date] Timestamp to get balances for
         * @param {number} [minBalance] Minimum balance
         * @param {number} [maxBalance] Maximum balance
         * @param {boolean} [hasFine] Only users with(out) fines
         * @param {number} [minFine] Minimum fine
         * @param {number} [maxFine] Maximum fine
         * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
         * @param {string} [orderBy] Column to order balance by - eg: id,amount
         * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
         * @param {boolean} [allowDeleted] Whether to include deleted users
         * @param {boolean} [inactive] Whether to only return inactive users
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userTypes, orderBy, orderDirection, allowDeleted, inactive, take, skip, options) {
            return localVarFp.getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userTypes, orderBy, orderDirection, allowDeleted, inactive, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves the requested balance
         * @param {number} id The id of the user for which the saldo is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceId(id, options) {
            return localVarFp.getBalanceId(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get balance of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances(options) {
            return localVarFp.getBalances(options).then((request) => request(axios, basePath));
        },
    };
};
exports.BalanceApiFactory = BalanceApiFactory;
/**
 * BalanceApi - object-oriented interface
 * @export
 * @class BalanceApi
 * @extends {BaseAPI}
 */
class BalanceApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get the calculated total balances in SudoSOS
     * @param {string} date The date for which to calculate the balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    calculateTotalBalances(date, options) {
        return (0, exports.BalanceApiFp)(this.configuration).calculateTotalBalances(date, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get balance of all users
     * @param {string} [date] Timestamp to get balances for
     * @param {number} [minBalance] Minimum balance
     * @param {number} [maxBalance] Maximum balance
     * @param {boolean} [hasFine] Only users with(out) fines
     * @param {number} [minFine] Minimum fine
     * @param {number} [maxFine] Maximum fine
     * @param {GetAllBalanceUserTypesEnum} [userTypes] Filter based on user type.
     * @param {string} [orderBy] Column to order balance by - eg: id,amount
     * @param {GetAllBalanceOrderDirectionEnum} [orderDirection] Order direction
     * @param {boolean} [allowDeleted] Whether to include deleted users
     * @param {boolean} [inactive] Whether to only return inactive users
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userTypes, orderBy, orderDirection, allowDeleted, inactive, take, skip, options) {
        return (0, exports.BalanceApiFp)(this.configuration).getAllBalance(date, minBalance, maxBalance, hasFine, minFine, maxFine, userTypes, orderBy, orderDirection, allowDeleted, inactive, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves the requested balance
     * @param {number} id The id of the user for which the saldo is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getBalanceId(id, options) {
        return (0, exports.BalanceApiFp)(this.configuration).getBalanceId(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get balance of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    getBalances(options) {
        return (0, exports.BalanceApiFp)(this.configuration).getBalances(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BalanceApi = BalanceApi;
/**
 * @export
 */
exports.GetAllBalanceUserTypesEnum = {};
/**
 * @export
 */
exports.GetAllBalanceOrderDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
};
/**
 * BannersApi - axios parameter creator
 * @export
 */
const BannersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('_delete', 'id', id);
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Saves a banner to the database
         * @param {BannerRequest} bannerRequest The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (bannerRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'bannerRequest' is not null or undefined
            (0, common_1.assertParamExists)('create', 'bannerRequest', bannerRequest);
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(bannerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/banners/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/open/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getBanner', 'id', id);
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} bannerRequest The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: (id, bannerRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('update', 'id', id);
            // verify required parameter 'bannerRequest' is not null or undefined
            (0, common_1.assertParamExists)('update', 'bannerRequest', bannerRequest);
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(bannerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage: (id, file, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateImage', 'id', id);
            const localVarPath = `/banners/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BannersApiAxiosParamCreator = BannersApiAxiosParamCreator;
/**
 * BannersApi - functional programming interface
 * @export
 */
const BannersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BannersApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator._delete(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BannersApi._delete']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Saves a banner to the database
         * @param {BannerRequest} bannerRequest The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(bannerRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(bannerRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BannersApi.create']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive(take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getActive(take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BannersApi.getActive']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners(take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllBanners(take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BannersApi.getAllBanners']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners(take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllOpenBanners(take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BannersApi.getAllOpenBanners']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBanner(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BannersApi.getBanner']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} bannerRequest The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id, bannerRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.update(id, bannerRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BannersApi.update']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id, file, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateImage(id, file, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['BannersApi.updateImage']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.BannersApiFp = BannersApiFp;
/**
 * BannersApi - factory interface
 * @export
 */
const BannersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BannersApiFp)(configuration);
    return {
        /**
         *
         * @summary Deletes the requested banner
         * @param {number} id The id of the banner which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id, options) {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Saves a banner to the database
         * @param {BannerRequest} bannerRequest The banner which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(bannerRequest, options) {
            return localVarFp.create(bannerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all active banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActive(take, skip, options) {
            return localVarFp.getActive(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners(take, skip, options) {
            return localVarFp.getAllBanners(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all existing banners
         * @param {number} [take] How many banners the endpoint should return
         * @param {number} [skip] How many banners should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOpenBanners(take, skip, options) {
            return localVarFp.getAllOpenBanners(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the requested banner
         * @param {number} id The id of the banner which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner(id, options) {
            return localVarFp.getBanner(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates the requested banner
         * @param {number} id The id of the banner which should be updated
         * @param {BannerRequest} bannerRequest The updated banner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id, bannerRequest, options) {
            return localVarFp.update(id, bannerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Uploads a banner image to the given banner
         * @param {number} id The id of the banner
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id, file, options) {
            return localVarFp.updateImage(id, file, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BannersApiFactory = BannersApiFactory;
/**
 * BannersApi - object-oriented interface
 * @export
 * @class BannersApi
 * @extends {BaseAPI}
 */
class BannersApi extends base_1.BaseAPI {
    /**
     *
     * @summary Deletes the requested banner
     * @param {number} id The id of the banner which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    _delete(id, options) {
        return (0, exports.BannersApiFp)(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Saves a banner to the database
     * @param {BannerRequest} bannerRequest The banner which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    create(bannerRequest, options) {
        return (0, exports.BannersApiFp)(this.configuration).create(bannerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all active banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getActive(take, skip, options) {
        return (0, exports.BannersApiFp)(this.configuration).getActive(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getAllBanners(take, skip, options) {
        return (0, exports.BannersApiFp)(this.configuration).getAllBanners(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all existing banners
     * @param {number} [take] How many banners the endpoint should return
     * @param {number} [skip] How many banners should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getAllOpenBanners(take, skip, options) {
        return (0, exports.BannersApiFp)(this.configuration).getAllOpenBanners(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the requested banner
     * @param {number} id The id of the banner which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getBanner(id, options) {
        return (0, exports.BannersApiFp)(this.configuration).getBanner(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates the requested banner
     * @param {number} id The id of the banner which should be updated
     * @param {BannerRequest} bannerRequest The updated banner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    update(id, bannerRequest, options) {
        return (0, exports.BannersApiFp)(this.configuration).update(id, bannerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Uploads a banner image to the given banner
     * @param {number} id The id of the banner
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    updateImage(id, file, options) {
        return (0, exports.BannersApiFp)(this.configuration).updateImage(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BannersApi = BannersApi;
/**
 * ContainersApi - axios parameter creator
 * @export
 */
const ContainersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a new container.
         * @param {CreateContainerRequest} createContainerRequest    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer: (createContainerRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createContainerRequest' is not null or undefined
            (0, common_1.assertParamExists)('createContainer', 'createContainerRequest', createContainerRequest);
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createContainerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary (Soft) delete the given container. Cannot be undone.
         * @param {number} id The id of the container which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteContainer', 'id', id);
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getProductsContainer', 'id', id);
            const localVarPath = `/containers/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/containers/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleContainer', 'id', id);
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: (id, updateContainerRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateContainer', 'id', id);
            // verify required parameter 'updateContainerRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateContainer', 'updateContainerRequest', updateContainerRequest);
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateContainerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ContainersApiAxiosParamCreator = ContainersApiAxiosParamCreator;
/**
 * ContainersApi - functional programming interface
 * @export
 */
const ContainersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ContainersApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new container.
         * @param {CreateContainerRequest} createContainerRequest    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(createContainerRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createContainer(createContainerRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ContainersApi.createContainer']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary (Soft) delete the given container. Cannot be undone.
         * @param {number} id The id of the container which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteContainer(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ContainersApi.deleteContainer']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers(take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllContainers(take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ContainersApi.getAllContainers']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProductsContainer(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ContainersApi.getProductsContainer']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers(take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPublicContainers(take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ContainersApi.getPublicContainers']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleContainer(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ContainersApi.getSingleContainer']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(id, updateContainerRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateContainer(id, updateContainerRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ContainersApi.updateContainer']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.ContainersApiFp = ContainersApiFp;
/**
 * ContainersApi - factory interface
 * @export
 */
const ContainersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ContainersApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new container.
         * @param {CreateContainerRequest} createContainerRequest    The container which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(createContainerRequest, options) {
            return localVarFp.createContainer(createContainerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary (Soft) delete the given container. Cannot be undone.
         * @param {number} id The id of the container which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContainer(id, options) {
            return localVarFp.deleteContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all existing containers
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContainers(take, skip, options) {
            return localVarFp.getAllContainers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all the products in the container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsContainer(id, options) {
            return localVarFp.getProductsContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all public container
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicContainers(take, skip, options) {
            return localVarFp.getPublicContainers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the requested container
         * @param {number} id The id of the container which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleContainer(id, options) {
            return localVarFp.getSingleContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update an existing container.
         * @param {number} id The id of the container which should be updated
         * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(id, updateContainerRequest, options) {
            return localVarFp.updateContainer(id, updateContainerRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ContainersApiFactory = ContainersApiFactory;
/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
class ContainersApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create a new container.
     * @param {CreateContainerRequest} createContainerRequest    The container which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    createContainer(createContainerRequest, options) {
        return (0, exports.ContainersApiFp)(this.configuration).createContainer(createContainerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary (Soft) delete the given container. Cannot be undone.
     * @param {number} id The id of the container which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    deleteContainer(id, options) {
        return (0, exports.ContainersApiFp)(this.configuration).deleteContainer(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all existing containers
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getAllContainers(take, skip, options) {
        return (0, exports.ContainersApiFp)(this.configuration).getAllContainers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all the products in the container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getProductsContainer(id, options) {
        return (0, exports.ContainersApiFp)(this.configuration).getProductsContainer(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all public container
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getPublicContainers(take, skip, options) {
        return (0, exports.ContainersApiFp)(this.configuration).getPublicContainers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the requested container
     * @param {number} id The id of the container which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    getSingleContainer(id, options) {
        return (0, exports.ContainersApiFp)(this.configuration).getSingleContainer(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update an existing container.
     * @param {number} id The id of the container which should be updated
     * @param {UpdateContainerRequest} updateContainerRequest    The container which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    updateContainer(id, updateContainerRequest, options) {
        return (0, exports.ContainersApiFp)(this.configuration).updateContainer(id, updateContainerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ContainersApi = ContainersApi;
/**
 * DebtorsApi - axios parameter creator
 * @export
 */
const DebtorsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
         * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
         * @param {Array<string>} [userTypes] List of all user types fines should be calculated for (MEMBER, ORGAN, VOUCHER, LOCAL_USER, LOCAL_ADMIN, INVOICE, AUTOMATIC_INVOICE).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateFines: (referenceDates, userTypes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'referenceDates' is not null or undefined
            (0, common_1.assertParamExists)('calculateFines', 'referenceDates', referenceDates);
            const localVarPath = `/fines/eligible`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (userTypes) {
                localVarQueryParameter['userTypes'] = userTypes;
            }
            if (referenceDates) {
                localVarQueryParameter['referenceDates'] = referenceDates;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFine: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteFine', 'id', id);
            const localVarPath = `/fines/single/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a report of all fines
         * @param {string} [fromDate] The start date of the report, inclusive
         * @param {string} [toDate] The end date of the report, exclusive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineReport: (fromDate, toDate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/fines/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a report of all fines in pdf format
         * @param {string} fromDate The start date of the report, inclusive
         * @param {string} toDate The end date of the report, exclusive
         * @param {GetFineReportPdfFileTypeEnum} fileType The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineReportPdf: (fromDate, toDate, fileType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'fromDate' is not null or undefined
            (0, common_1.assertParamExists)('getFineReportPdf', 'fromDate', fromDate);
            // verify required parameter 'toDate' is not null or undefined
            (0, common_1.assertParamExists)('getFineReportPdf', 'toDate', toDate);
            // verify required parameter 'fileType' is not null or undefined
            (0, common_1.assertParamExists)('getFineReportPdf', 'fileType', fileType);
            const localVarPath = `/fines/report/pdf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }
            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} handoutFinesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoutFines: (handoutFinesRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'handoutFinesRequest' is not null or undefined
            (0, common_1.assertParamExists)('handoutFines', 'handoutFinesRequest', handoutFinesRequest);
            const localVarPath = `/fines/handout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(handoutFinesRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} handoutFinesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyAboutFutureFines: (handoutFinesRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'handoutFinesRequest' is not null or undefined
            (0, common_1.assertParamExists)('notifyAboutFutureFines', 'handoutFinesRequest', handoutFinesRequest);
            const localVarPath = `/fines/notify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(handoutFinesRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnAllFineHandoutEvents: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/fines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnSingleFineHandoutEvent: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('returnSingleFineHandoutEvent', 'id', id);
            const localVarPath = `/fines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.DebtorsApiAxiosParamCreator = DebtorsApiAxiosParamCreator;
/**
 * DebtorsApi - functional programming interface
 * @export
 */
const DebtorsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DebtorsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
         * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
         * @param {Array<string>} [userTypes] List of all user types fines should be calculated for (MEMBER, ORGAN, VOUCHER, LOCAL_USER, LOCAL_ADMIN, INVOICE, AUTOMATIC_INVOICE).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateFines(referenceDates, userTypes, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.calculateFines(referenceDates, userTypes, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['DebtorsApi.calculateFines']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFine(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFine(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['DebtorsApi.deleteFine']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a report of all fines
         * @param {string} [fromDate] The start date of the report, inclusive
         * @param {string} [toDate] The end date of the report, exclusive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineReport(fromDate, toDate, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFineReport(fromDate, toDate, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['DebtorsApi.getFineReport']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a report of all fines in pdf format
         * @param {string} fromDate The start date of the report, inclusive
         * @param {string} toDate The end date of the report, exclusive
         * @param {GetFineReportPdfFileTypeEnum} fileType The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineReportPdf(fromDate, toDate, fileType, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFineReportPdf(fromDate, toDate, fileType, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['DebtorsApi.getFineReportPdf']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} handoutFinesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoutFines(handoutFinesRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handoutFines(handoutFinesRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['DebtorsApi.handoutFines']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} handoutFinesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyAboutFutureFines(handoutFinesRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.notifyAboutFutureFines(handoutFinesRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['DebtorsApi.notifyAboutFutureFines']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnAllFineHandoutEvents(take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.returnAllFineHandoutEvents(take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['DebtorsApi.returnAllFineHandoutEvents']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnSingleFineHandoutEvent(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.returnSingleFineHandoutEvent(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['DebtorsApi.returnSingleFineHandoutEvent']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.DebtorsApiFp = DebtorsApiFp;
/**
 * DebtorsApi - factory interface
 * @export
 */
const DebtorsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DebtorsApiFp)(configuration);
    return {
        /**
         *
         * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
         * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
         * @param {Array<string>} [userTypes] List of all user types fines should be calculated for (MEMBER, ORGAN, VOUCHER, LOCAL_USER, LOCAL_ADMIN, INVOICE, AUTOMATIC_INVOICE).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateFines(referenceDates, userTypes, options) {
            return localVarFp.calculateFines(referenceDates, userTypes, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a fine
         * @param {number} id The id of the fine which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFine(id, options) {
            return localVarFp.deleteFine(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a report of all fines
         * @param {string} [fromDate] The start date of the report, inclusive
         * @param {string} [toDate] The end date of the report, exclusive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineReport(fromDate, toDate, options) {
            return localVarFp.getFineReport(fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a report of all fines in pdf format
         * @param {string} fromDate The start date of the report, inclusive
         * @param {string} toDate The end date of the report, exclusive
         * @param {GetFineReportPdfFileTypeEnum} fileType The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFineReportPdf(fromDate, toDate, fileType, options) {
            return localVarFp.getFineReportPdf(fromDate, toDate, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
         * @param {HandoutFinesRequest} handoutFinesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoutFines(handoutFinesRequest, options) {
            return localVarFp.handoutFines(handoutFinesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Send an email to all given users about their possible future fine.
         * @param {HandoutFinesRequest} handoutFinesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyAboutFutureFines(handoutFinesRequest, options) {
            return localVarFp.notifyAboutFutureFines(handoutFinesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all fine handout events
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnAllFineHandoutEvents(take, skip, options) {
            return localVarFp.returnAllFineHandoutEvents(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all fine handout events
         * @param {number} id The id of the fine handout event which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnSingleFineHandoutEvent(id, options) {
            return localVarFp.returnSingleFineHandoutEvent(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DebtorsApiFactory = DebtorsApiFactory;
/**
 * DebtorsApi - object-oriented interface
 * @export
 * @class DebtorsApi
 * @extends {BaseAPI}
 */
class DebtorsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Return all users that had at most -5 euros balance both now and on the reference date.    For all these users, also return their fine based on the reference date.
     * @param {Array<string>} referenceDates Dates to base the fines on. Every returned user has at    least five euros debt on every reference date. The height of the fine is based on the first date in the array.
     * @param {Array<string>} [userTypes] List of all user types fines should be calculated for (MEMBER, ORGAN, VOUCHER, LOCAL_USER, LOCAL_ADMIN, INVOICE, AUTOMATIC_INVOICE).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    calculateFines(referenceDates, userTypes, options) {
        return (0, exports.DebtorsApiFp)(this.configuration).calculateFines(referenceDates, userTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a fine
     * @param {number} id The id of the fine which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    deleteFine(id, options) {
        return (0, exports.DebtorsApiFp)(this.configuration).deleteFine(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a report of all fines
     * @param {string} [fromDate] The start date of the report, inclusive
     * @param {string} [toDate] The end date of the report, exclusive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    getFineReport(fromDate, toDate, options) {
        return (0, exports.DebtorsApiFp)(this.configuration).getFineReport(fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a report of all fines in pdf format
     * @param {string} fromDate The start date of the report, inclusive
     * @param {string} toDate The end date of the report, exclusive
     * @param {GetFineReportPdfFileTypeEnum} fileType The file type of the report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    getFineReportPdf(fromDate, toDate, fileType, options) {
        return (0, exports.DebtorsApiFp)(this.configuration).getFineReportPdf(fromDate, toDate, fileType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Handout fines to all given users. Fines will be handed out \"now\" to prevent rewriting history.
     * @param {HandoutFinesRequest} handoutFinesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    handoutFines(handoutFinesRequest, options) {
        return (0, exports.DebtorsApiFp)(this.configuration).handoutFines(handoutFinesRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Send an email to all given users about their possible future fine.
     * @param {HandoutFinesRequest} handoutFinesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    notifyAboutFutureFines(handoutFinesRequest, options) {
        return (0, exports.DebtorsApiFp)(this.configuration).notifyAboutFutureFines(handoutFinesRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all fine handout events
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    returnAllFineHandoutEvents(take, skip, options) {
        return (0, exports.DebtorsApiFp)(this.configuration).returnAllFineHandoutEvents(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all fine handout events
     * @param {number} id The id of the fine handout event which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebtorsApi
     */
    returnSingleFineHandoutEvent(id, options) {
        return (0, exports.DebtorsApiFp)(this.configuration).returnSingleFineHandoutEvent(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DebtorsApi = DebtorsApi;
/**
 * @export
 */
exports.GetFineReportPdfFileTypeEnum = {
    Pdf: 'PDF',
    Tex: 'TEX'
};
/**
 * EventsApi - axios parameter creator
 * @export
 */
const EventsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignEventShift: (eventId, shiftId, userId, eventAnswerAssignmentRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('assignEventShift', 'eventId', eventId);
            // verify required parameter 'shiftId' is not null or undefined
            (0, common_1.assertParamExists)('assignEventShift', 'shiftId', shiftId);
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('assignEventShift', 'userId', userId);
            // verify required parameter 'eventAnswerAssignmentRequest' is not null or undefined
            (0, common_1.assertParamExists)('assignEventShift', 'eventAnswerAssignmentRequest', eventAnswerAssignmentRequest);
            const localVarPath = `/events/{eventId}/shift/{shiftId}/user/{userId}/assign`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"shiftId"}}`, encodeURIComponent(String(shiftId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(eventAnswerAssignmentRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create an event with its corresponding answers objects
         * @param {CreateEventRequest} createEventRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEvent: (createEventRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createEventRequest' is not null or undefined
            (0, common_1.assertParamExists)('createEvent', 'createEventRequest', createEventRequest);
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createEventRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create an event shift
         * @param {CreateShiftRequest} createShiftRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEventShift: (createShiftRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createShiftRequest' is not null or undefined
            (0, common_1.assertParamExists)('createEventShift', 'createShiftRequest', createShiftRequest);
            const localVarPath = `/eventshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createShiftRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEvent: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteEvent', 'id', id);
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEventShift: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteEventShift', 'id', id);
            const localVarPath = `/eventshifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllEventShifts: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/eventshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllEvents: (name, createdById, beforeDate, afterDate, type, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }
            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = beforeDate;
            }
            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = afterDate;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event shift
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getEventShiftCount: (id, eventType, afterDate, beforeDate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getEventShiftCount', 'id', id);
            const localVarPath = `/eventshifts/{id}/counts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }
            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = afterDate;
            }
            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = beforeDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSingleEvent: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleEvent', 'id', id);
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} updateEventRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEvent: (id, updateEventRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateEvent', 'id', id);
            // verify required parameter 'updateEventRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateEvent', 'updateEventRequest', updateEventRequest);
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateEventRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} updateShiftRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEventShift: (id, updateShiftRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateEventShift', 'id', id);
            // verify required parameter 'updateShiftRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateEventShift', 'updateShiftRequest', updateShiftRequest);
            const localVarPath = `/eventshifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateShiftRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEventShiftAvailability: (eventId, shiftId, userId, eventAnswerAvailabilityRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('updateEventShiftAvailability', 'eventId', eventId);
            // verify required parameter 'shiftId' is not null or undefined
            (0, common_1.assertParamExists)('updateEventShiftAvailability', 'shiftId', shiftId);
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('updateEventShiftAvailability', 'userId', userId);
            // verify required parameter 'eventAnswerAvailabilityRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateEventShiftAvailability', 'eventAnswerAvailabilityRequest', eventAnswerAvailabilityRequest);
            const localVarPath = `/events/{eventId}/shift/{shiftId}/user/{userId}/availability`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"shiftId"}}`, encodeURIComponent(String(shiftId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(eventAnswerAvailabilityRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.EventsApiAxiosParamCreator = EventsApiAxiosParamCreator;
/**
 * EventsApi - functional programming interface
 * @export
 */
const EventsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.EventsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.assignEventShift']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Create an event with its corresponding answers objects
         * @param {CreateEventRequest} createEventRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEvent(createEventRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createEvent(createEventRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.createEvent']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Create an event shift
         * @param {CreateShiftRequest} createShiftRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEventShift(createShiftRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createEventShift(createShiftRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.createEventShift']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEvent(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteEvent(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.deleteEvent']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEventShift(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteEventShift(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.deleteEventShift']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllEventShifts(take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllEventShifts(take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.getAllEventShifts']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.getAllEvents']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event shift
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getEventShiftCount(id, eventType, afterDate, beforeDate, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEventShiftCount(id, eventType, afterDate, beforeDate, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.getEventShiftCount']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSingleEvent(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleEvent(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.getSingleEvent']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} updateEventRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEvent(id, updateEventRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateEvent(id, updateEventRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.updateEvent']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} updateShiftRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEventShift(id, updateShiftRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateEventShift(id, updateShiftRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.updateEventShift']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.updateEventShiftAvailability']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.EventsApiFp = EventsApiFp;
/**
 * EventsApi - factory interface
 * @export
 */
const EventsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.EventsApiFp)(configuration);
    return {
        /**
         *
         * @summary Change the assignment of users to shifts on an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options) {
            return localVarFp.assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create an event with its corresponding answers objects
         * @param {CreateEventRequest} createEventRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEvent(createEventRequest, options) {
            return localVarFp.createEvent(createEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create an event shift
         * @param {CreateShiftRequest} createShiftRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEventShift(createShiftRequest, options) {
            return localVarFp.createEventShift(createShiftRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an event with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEvent(id, options) {
            return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an event shift with its answers
         * @param {number} id The id of the event which should be deleted
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEventShift(id, options) {
            return localVarFp.deleteEventShift(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all event shifts
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllEventShifts(take, skip, options) {
            return localVarFp.getAllEventShifts(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all events
         * @param {string} [name] Name of the event
         * @param {number} [createdById] ID of user that created the event
         * @param {string} [beforeDate] Get only events that start after this date
         * @param {string} [afterDate] Get only events that start before this date
         * @param {string} [type] Get only events that are this type
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options) {
            return localVarFp.getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the number of times a user has been selected for the given shift
         * @param {number} id The id of the event shift
         * @param {string} [eventType] Only include events of this type
         * @param {string} [afterDate] Only include events after this date
         * @param {string} [beforeDate] Only include events before this date
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getEventShiftCount(id, eventType, afterDate, beforeDate, options) {
            return localVarFp.getEventShiftCount(id, eventType, afterDate, beforeDate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a single event with its answers and shifts
         * @param {number} id The id of the event which should be returned
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSingleEvent(id, options) {
            return localVarFp.getSingleEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update an event with its corresponding answers objects
         * @param {number} id The id of the event which should be returned
         * @param {UpdateEventRequest} updateEventRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEvent(id, updateEventRequest, options) {
            return localVarFp.updateEvent(id, updateEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update an event shift
         * @param {number} id The id of the event which should be returned
         * @param {UpdateShiftRequest} updateShiftRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEventShift(id, updateShiftRequest, options) {
            return localVarFp.updateEventShift(id, updateShiftRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update the availability of a user for a shift in an event
         * @param {number} eventId The id of the event
         * @param {number} shiftId The id of the shift
         * @param {number} userId The id of the user
         * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options) {
            return localVarFp.updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.EventsApiFactory = EventsApiFactory;
/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
class EventsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Change the assignment of users to shifts on an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAssignmentRequest} eventAnswerAssignmentRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options) {
        return (0, exports.EventsApiFp)(this.configuration).assignEventShift(eventId, shiftId, userId, eventAnswerAssignmentRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create an event with its corresponding answers objects
     * @param {CreateEventRequest} createEventRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    createEvent(createEventRequest, options) {
        return (0, exports.EventsApiFp)(this.configuration).createEvent(createEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create an event shift
     * @param {CreateShiftRequest} createShiftRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    createEventShift(createShiftRequest, options) {
        return (0, exports.EventsApiFp)(this.configuration).createEventShift(createShiftRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete an event with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    deleteEvent(id, options) {
        return (0, exports.EventsApiFp)(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete an event shift with its answers
     * @param {number} id The id of the event which should be deleted
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    deleteEventShift(id, options) {
        return (0, exports.EventsApiFp)(this.configuration).deleteEventShift(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all event shifts
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getAllEventShifts(take, skip, options) {
        return (0, exports.EventsApiFp)(this.configuration).getAllEventShifts(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all events
     * @param {string} [name] Name of the event
     * @param {number} [createdById] ID of user that created the event
     * @param {string} [beforeDate] Get only events that start after this date
     * @param {string} [afterDate] Get only events that start before this date
     * @param {string} [type] Get only events that are this type
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options) {
        return (0, exports.EventsApiFp)(this.configuration).getAllEvents(name, createdById, beforeDate, afterDate, type, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the number of times a user has been selected for the given shift
     * @param {number} id The id of the event shift
     * @param {string} [eventType] Only include events of this type
     * @param {string} [afterDate] Only include events after this date
     * @param {string} [beforeDate] Only include events before this date
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getEventShiftCount(id, eventType, afterDate, beforeDate, options) {
        return (0, exports.EventsApiFp)(this.configuration).getEventShiftCount(id, eventType, afterDate, beforeDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a single event with its answers and shifts
     * @param {number} id The id of the event which should be returned
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getSingleEvent(id, options) {
        return (0, exports.EventsApiFp)(this.configuration).getSingleEvent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update an event with its corresponding answers objects
     * @param {number} id The id of the event which should be returned
     * @param {UpdateEventRequest} updateEventRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    updateEvent(id, updateEventRequest, options) {
        return (0, exports.EventsApiFp)(this.configuration).updateEvent(id, updateEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update an event shift
     * @param {number} id The id of the event which should be returned
     * @param {UpdateShiftRequest} updateShiftRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    updateEventShift(id, updateShiftRequest, options) {
        return (0, exports.EventsApiFp)(this.configuration).updateEventShift(id, updateShiftRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update the availability of a user for a shift in an event
     * @param {number} eventId The id of the event
     * @param {number} shiftId The id of the shift
     * @param {number} userId The id of the user
     * @param {EventAnswerAvailabilityRequest} eventAnswerAvailabilityRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options) {
        return (0, exports.EventsApiFp)(this.configuration).updateEventShiftAvailability(eventId, shiftId, userId, eventAnswerAvailabilityRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EventsApi = EventsApi;
/**
 * FilesApi - axios parameter creator
 * @export
 */
const FilesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Upload a file with the given name.
         * @param {string} name The name of the file
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: (name, file, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            (0, common_1.assertParamExists)('createFile', 'name', name);
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteFile', 'id', id);
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getFile', 'id', id);
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FilesApiAxiosParamCreator = FilesApiAxiosParamCreator;
/**
 * FilesApi - functional programming interface
 * @export
 */
const FilesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FilesApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Upload a file with the given name.
         * @param {string} name The name of the file
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(name, file, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createFile(name, file, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['FilesApi.createFile']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFile(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['FilesApi.deleteFile']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFile(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['FilesApi.getFile']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.FilesApiFp = FilesApiFp;
/**
 * FilesApi - factory interface
 * @export
 */
const FilesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FilesApiFp)(configuration);
    return {
        /**
         *
         * @summary Upload a file with the given name.
         * @param {string} name The name of the file
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(name, file, options) {
            return localVarFp.createFile(name, file, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete the file with the given id.
         * @param {number} id The id of the file which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(id, options) {
            return localVarFp.deleteFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Download a file with the given id.
         * @param {number} id The id of the file which should be downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id, options) {
            return localVarFp.getFile(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FilesApiFactory = FilesApiFactory;
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
class FilesApi extends base_1.BaseAPI {
    /**
     *
     * @summary Upload a file with the given name.
     * @param {string} name The name of the file
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    createFile(name, file, options) {
        return (0, exports.FilesApiFp)(this.configuration).createFile(name, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete the file with the given id.
     * @param {number} id The id of the file which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteFile(id, options) {
        return (0, exports.FilesApiFp)(this.configuration).deleteFile(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Download a file with the given id.
     * @param {number} id The id of the file which should be downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getFile(id, options) {
        return (0, exports.FilesApiFp)(this.configuration).getFile(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FilesApi = FilesApi;
/**
 * InvoicesApi - axios parameter creator
 * @export
 */
const InvoicesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Adds an invoice to the system.
         * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice: (createInvoiceRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createInvoiceRequest' is not null or undefined
            (0, common_1.assertParamExists)('createInvoice', 'createInvoiceRequest', createInvoiceRequest);
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createInvoiceRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoice', 'id', id);
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete invoice user defaults.
         * @param {number} id The id of the invoice user to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceUser: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoiceUser', 'id', id);
            const localVarPath = `/invoices/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices: (toId, invoiceId, currentState, returnEntries, fromDate, tillDate, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }
            if (invoiceId !== undefined) {
                localVarQueryParameter['invoiceId'] = invoiceId;
            }
            if (currentState) {
                localVarQueryParameter['currentState'] = currentState;
            }
            if (returnEntries !== undefined) {
                localVarQueryParameter['returnEntries'] = returnEntries;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get eligible transactions for invoice creation.
         * @param {number} forId Filter on Id of the debtor
         * @param {string} fromDate Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEligibleTransactions: (forId, fromDate, tillDate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'forId' is not null or undefined
            (0, common_1.assertParamExists)('getEligibleTransactions', 'forId', forId);
            // verify required parameter 'fromDate' is not null or undefined
            (0, common_1.assertParamExists)('getEligibleTransactions', 'fromDate', fromDate);
            const localVarPath = `/invoices/eligible-transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (forId !== undefined) {
                localVarQueryParameter['forId'] = forId;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get an invoice pdf.
         * @param {number} id The id of the invoice to return
         * @param {boolean} [force] Force creation of pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePdf: (id, force, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getInvoicePdf', 'id', id);
            const localVarPath = `/invoices/{id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice: (id, returnEntries, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleInvoice', 'id', id);
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (returnEntries !== undefined) {
                localVarQueryParameter['returnEntries'] = returnEntries;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get invoice user defaults.
         * @param {number} id The id of the invoice user to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoiceUser: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleInvoiceUser', 'id', id);
            const localVarPath = `/invoices/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update or create invoice user defaults.
         * @param {number} id The id of the user to update
         * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInvoiceUser: (id, updateInvoiceUserRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('putInvoiceUser', 'id', id);
            // verify required parameter 'updateInvoiceUserRequest' is not null or undefined
            (0, common_1.assertParamExists)('putInvoiceUser', 'updateInvoiceUserRequest', updateInvoiceUserRequest);
            const localVarPath = `/invoices/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateInvoiceUserRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice: (id, updateInvoiceRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateInvoice', 'id', id);
            // verify required parameter 'updateInvoiceRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateInvoice', 'updateInvoiceRequest', updateInvoiceRequest);
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateInvoiceRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InvoicesApiAxiosParamCreator = InvoicesApiAxiosParamCreator;
/**
 * InvoicesApi - functional programming interface
 * @export
 */
const InvoicesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InvoicesApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Adds an invoice to the system.
         * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(createInvoiceRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createInvoice(createInvoiceRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.createInvoice']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInvoice(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.deleteInvoice']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete invoice user defaults.
         * @param {number} id The id of the invoice user to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceUser(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInvoiceUser(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.deleteInvoiceUser']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices(toId, invoiceId, currentState, returnEntries, fromDate, tillDate, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllInvoices(toId, invoiceId, currentState, returnEntries, fromDate, tillDate, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.getAllInvoices']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get eligible transactions for invoice creation.
         * @param {number} forId Filter on Id of the debtor
         * @param {string} fromDate Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEligibleTransactions(forId, fromDate, tillDate, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEligibleTransactions(forId, fromDate, tillDate, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.getEligibleTransactions']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get an invoice pdf.
         * @param {number} id The id of the invoice to return
         * @param {boolean} [force] Force creation of pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePdf(id, force, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoicePdf(id, force, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.getInvoicePdf']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice(id, returnEntries, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleInvoice(id, returnEntries, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.getSingleInvoice']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get invoice user defaults.
         * @param {number} id The id of the invoice user to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoiceUser(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleInvoiceUser(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.getSingleInvoiceUser']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update or create invoice user defaults.
         * @param {number} id The id of the user to update
         * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInvoiceUser(id, updateInvoiceUserRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.putInvoiceUser(id, updateInvoiceUserRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.putInvoiceUser']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(id, updateInvoiceRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateInvoice(id, updateInvoiceRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.updateInvoice']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.InvoicesApiFp = InvoicesApiFp;
/**
 * InvoicesApi - factory interface
 * @export
 */
const InvoicesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InvoicesApiFp)(configuration);
    return {
        /**
         *
         * @summary Adds an invoice to the system.
         * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(createInvoiceRequest, options) {
            return localVarFp.createInvoice(createInvoiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes an invoice.
         * @param {number} id The id of the invoice which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice(id, options) {
            return localVarFp.deleteInvoice(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete invoice user defaults.
         * @param {number} id The id of the invoice user to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceUser(id, options) {
            return localVarFp.deleteInvoiceUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all invoices in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [invoiceId] Filter on invoice ID
         * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
         * @param {string} [fromDate] Start date for selected invoices (inclusive)
         * @param {string} [tillDate] End date for selected invoices (exclusive)
         * @param {number} [take] How many entries the endpoint should return
         * @param {number} [skip] How many entries should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvoices(toId, invoiceId, currentState, returnEntries, fromDate, tillDate, take, skip, options) {
            return localVarFp.getAllInvoices(toId, invoiceId, currentState, returnEntries, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get eligible transactions for invoice creation.
         * @param {number} forId Filter on Id of the debtor
         * @param {string} fromDate Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEligibleTransactions(forId, fromDate, tillDate, options) {
            return localVarFp.getEligibleTransactions(forId, fromDate, tillDate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an invoice pdf.
         * @param {number} id The id of the invoice to return
         * @param {boolean} [force] Force creation of pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePdf(id, force, options) {
            return localVarFp.getInvoicePdf(id, force, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a single invoice in the system.
         * @param {number} id The id of the requested invoice
         * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoice(id, returnEntries, options) {
            return localVarFp.getSingleInvoice(id, returnEntries, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get invoice user defaults.
         * @param {number} id The id of the invoice user to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleInvoiceUser(id, options) {
            return localVarFp.getSingleInvoiceUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update or create invoice user defaults.
         * @param {number} id The id of the user to update
         * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInvoiceUser(id, updateInvoiceUserRequest, options) {
            return localVarFp.putInvoiceUser(id, updateInvoiceUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Adds an invoice to the system.
         * @param {number} id The id of the invoice which should be updated
         * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(id, updateInvoiceRequest, options) {
            return localVarFp.updateInvoice(id, updateInvoiceRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InvoicesApiFactory = InvoicesApiFactory;
/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
class InvoicesApi extends base_1.BaseAPI {
    /**
     *
     * @summary Adds an invoice to the system.
     * @param {CreateInvoiceRequest} createInvoiceRequest The invoice which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    createInvoice(createInvoiceRequest, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).createInvoice(createInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes an invoice.
     * @param {number} id The id of the invoice which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    deleteInvoice(id, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).deleteInvoice(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete invoice user defaults.
     * @param {number} id The id of the invoice user to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    deleteInvoiceUser(id, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).deleteInvoiceUser(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all invoices in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [invoiceId] Filter on invoice ID
     * @param {GetAllInvoicesCurrentStateEnum} [currentState] Filter based on Invoice State.
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned
     * @param {string} [fromDate] Start date for selected invoices (inclusive)
     * @param {string} [tillDate] End date for selected invoices (exclusive)
     * @param {number} [take] How many entries the endpoint should return
     * @param {number} [skip] How many entries should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getAllInvoices(toId, invoiceId, currentState, returnEntries, fromDate, tillDate, take, skip, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).getAllInvoices(toId, invoiceId, currentState, returnEntries, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get eligible transactions for invoice creation.
     * @param {number} forId Filter on Id of the debtor
     * @param {string} fromDate Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getEligibleTransactions(forId, fromDate, tillDate, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).getEligibleTransactions(forId, fromDate, tillDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an invoice pdf.
     * @param {number} id The id of the invoice to return
     * @param {boolean} [force] Force creation of pdf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getInvoicePdf(id, force, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).getInvoicePdf(id, force, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a single invoice in the system.
     * @param {number} id The id of the requested invoice
     * @param {boolean} [returnEntries] Boolean if invoice entries should be returned, defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getSingleInvoice(id, returnEntries, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).getSingleInvoice(id, returnEntries, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get invoice user defaults.
     * @param {number} id The id of the invoice user to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getSingleInvoiceUser(id, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).getSingleInvoiceUser(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update or create invoice user defaults.
     * @param {number} id The id of the user to update
     * @param {UpdateInvoiceUserRequest} updateInvoiceUserRequest The invoice user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    putInvoiceUser(id, updateInvoiceUserRequest, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).putInvoiceUser(id, updateInvoiceUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Adds an invoice to the system.
     * @param {number} id The id of the invoice which should be updated
     * @param {UpdateInvoiceRequest} updateInvoiceRequest The invoice update to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    updateInvoice(id, updateInvoiceRequest, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).updateInvoice(id, updateInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InvoicesApi = InvoicesApi;
/**
 * @export
 */
exports.GetAllInvoicesCurrentStateEnum = {};
/**
 * PayoutRequestsApi - axios parameter creator
 * @export
 */
const PayoutRequestsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a new payout request
         * @param {PayoutRequestRequest} payoutRequestRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest: (payoutRequestRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'payoutRequestRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPayoutRequest', 'payoutRequestRequest', payoutRequestRequest);
            const localVarPath = `/payoutrequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payoutRequestRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all payout requests given the filter parameters
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests: (requestedById, approvedById, fromDate, tillDate, status, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/payoutrequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (requestedById !== undefined) {
                for (const [key, value] of Object.entries(requestedById)) {
                    localVarQueryParameter[key] = value;
                }
            }
            if (approvedById !== undefined) {
                for (const [key, value] of Object.entries(approvedById)) {
                    localVarQueryParameter[key] = value;
                }
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a payout request pdf
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutRequestPdf: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getPayoutRequestPdf', 'id', id);
            const localVarPath = `/payoutrequests/{id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSinglePayoutRequest', 'id', id);
            const localVarPath = `/payoutrequests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus: (id, payoutRequestStatusRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('setPayoutRequestStatus', 'id', id);
            // verify required parameter 'payoutRequestStatusRequest' is not null or undefined
            (0, common_1.assertParamExists)('setPayoutRequestStatus', 'payoutRequestStatusRequest', payoutRequestStatusRequest);
            const localVarPath = `/payoutrequests/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(payoutRequestStatusRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PayoutRequestsApiAxiosParamCreator = PayoutRequestsApiAxiosParamCreator;
/**
 * PayoutRequestsApi - functional programming interface
 * @export
 */
const PayoutRequestsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PayoutRequestsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new payout request
         * @param {PayoutRequestRequest} payoutRequestRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest(payoutRequestRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPayoutRequest(payoutRequestRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PayoutRequestsApi.createPayoutRequest']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all payout requests given the filter parameters
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PayoutRequestsApi.getAllPayoutRequests']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a payout request pdf
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutRequestPdf(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPayoutRequestPdf(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PayoutRequestsApi.getPayoutRequestPdf']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSinglePayoutRequest(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PayoutRequestsApi.getSinglePayoutRequest']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus(id, payoutRequestStatusRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.setPayoutRequestStatus(id, payoutRequestStatusRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PayoutRequestsApi.setPayoutRequestStatus']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.PayoutRequestsApiFp = PayoutRequestsApiFp;
/**
 * PayoutRequestsApi - factory interface
 * @export
 */
const PayoutRequestsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PayoutRequestsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new payout request
         * @param {PayoutRequestRequest} payoutRequestRequest New payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayoutRequest(payoutRequestRequest, options) {
            return localVarFp.createPayoutRequest(payoutRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all payout requests given the filter parameters
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
         * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {string} [status] Status of the payout requests (OR relation)
         * @param {number} [take] How many payout requests the endpoint should return
         * @param {number} [skip] How many payout requests should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options) {
            return localVarFp.getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a payout request pdf
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutRequestPdf(id, options) {
            return localVarFp.getPayoutRequestPdf(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a single payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePayoutRequest(id, options) {
            return localVarFp.getSinglePayoutRequest(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new status for a payout request
         * @param {number} id The ID of the payout request object that should be returned
         * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayoutRequestStatus(id, payoutRequestStatusRequest, options) {
            return localVarFp.setPayoutRequestStatus(id, payoutRequestStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PayoutRequestsApiFactory = PayoutRequestsApiFactory;
/**
 * PayoutRequestsApi - object-oriented interface
 * @export
 * @class PayoutRequestsApi
 * @extends {BaseAPI}
 */
class PayoutRequestsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create a new payout request
     * @param {PayoutRequestRequest} payoutRequestRequest New payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    createPayoutRequest(payoutRequestRequest, options) {
        return (0, exports.PayoutRequestsApiFp)(this.configuration).createPayoutRequest(payoutRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all payout requests given the filter parameters
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [requestedById] ID of user(s) who requested a payout
     * @param {GetAllPayoutRequestsRequestedByIdParameter} [approvedById] ID of user(s) who approved a payout
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {string} [status] Status of the payout requests (OR relation)
     * @param {number} [take] How many payout requests the endpoint should return
     * @param {number} [skip] How many payout requests should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options) {
        return (0, exports.PayoutRequestsApiFp)(this.configuration).getAllPayoutRequests(requestedById, approvedById, fromDate, tillDate, status, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a payout request pdf
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    getPayoutRequestPdf(id, options) {
        return (0, exports.PayoutRequestsApiFp)(this.configuration).getPayoutRequestPdf(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a single payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    getSinglePayoutRequest(id, options) {
        return (0, exports.PayoutRequestsApiFp)(this.configuration).getSinglePayoutRequest(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new status for a payout request
     * @param {number} id The ID of the payout request object that should be returned
     * @param {PayoutRequestStatusRequest} payoutRequestStatusRequest New state of payout request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutRequestsApi
     */
    setPayoutRequestStatus(id, payoutRequestStatusRequest, options) {
        return (0, exports.PayoutRequestsApiFp)(this.configuration).setPayoutRequestStatus(id, payoutRequestStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PayoutRequestsApi = PayoutRequestsApi;
/**
 * PointofsaleApi - axios parameter creator
 * @export
 */
const PointofsaleApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale: (createPointOfSaleRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createPointOfSaleRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPointOfSale', 'createPointOfSaleRequest', createPointOfSaleRequest);
            const localVarPath = `/pointsofsale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPointOfSaleRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary (Soft) delete the given point of sale. Cannot be undone.
         * @param {number} id The id of the point of sale which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePointOfSale: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deletePointOfSale', 'id', id);
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getAllPointOfSaleContainers', 'id', id);
            const localVarPath = `/pointsofsale/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getAllPointOfSaleProducts', 'id', id);
            const localVarPath = `/pointsofsale/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/pointsofsale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a Point of Sale\'s associate users
         * @param {number} id The id of the Point of Sale of which to get the associate users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPointOfSaleAssociates: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getPointOfSaleAssociates', 'id', id);
            const localVarPath = `/pointsofsale/{id}/associates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSinglePointOfSale', 'id', id);
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a Point of Sale transactions
         * @param {number} id The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTransactions', 'id', id);
            const localVarPath = `/pointsofsale/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale: (id, updatePointOfSaleRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updatePointOfSale', 'id', id);
            // verify required parameter 'updatePointOfSaleRequest' is not null or undefined
            (0, common_1.assertParamExists)('updatePointOfSale', 'updatePointOfSaleRequest', updatePointOfSaleRequest);
            const localVarPath = `/pointsofsale/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updatePointOfSaleRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PointofsaleApiAxiosParamCreator = PointofsaleApiAxiosParamCreator;
/**
 * PointofsaleApi - functional programming interface
 * @export
 */
const PointofsaleApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PointofsaleApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale(createPointOfSaleRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPointOfSale(createPointOfSaleRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PointofsaleApi.createPointOfSale']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary (Soft) delete the given point of sale. Cannot be undone.
         * @param {number} id The id of the point of sale which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePointOfSale(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePointOfSale(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PointofsaleApi.deletePointOfSale']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers(id, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllPointOfSaleContainers(id, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PointofsaleApi.getAllPointOfSaleContainers']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllPointOfSaleProducts(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PointofsaleApi.getAllPointOfSaleProducts']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale(take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllPointsOfSale(take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PointofsaleApi.getAllPointsOfSale']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns a Point of Sale\'s associate users
         * @param {number} id The id of the Point of Sale of which to get the associate users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPointOfSaleAssociates(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPointOfSaleAssociates(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PointofsaleApi.getPointOfSaleAssociates']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSinglePointOfSale(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PointofsaleApi.getSinglePointOfSale']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns a Point of Sale transactions
         * @param {number} id The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(id, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactions(id, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PointofsaleApi.getTransactions']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale(id, updatePointOfSaleRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updatePointOfSale(id, updatePointOfSaleRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['PointofsaleApi.updatePointOfSale']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.PointofsaleApiFp = PointofsaleApiFp;
/**
 * PointofsaleApi - factory interface
 * @export
 */
const PointofsaleApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PointofsaleApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new Point of Sale.
         * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPointOfSale(createPointOfSaleRequest, options) {
            return localVarFp.createPointOfSale(createPointOfSaleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary (Soft) delete the given point of sale. Cannot be undone.
         * @param {number} id The id of the point of sale which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePointOfSale(id, options) {
            return localVarFp.deletePointOfSale(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleContainers(id, take, skip, options) {
            return localVarFp.getAllPointOfSaleContainers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
         * @param {number} id The id of the point of sale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointOfSaleProducts(id, options) {
            return localVarFp.getAllPointOfSaleProducts(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all existing Point of Sales
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPointsOfSale(take, skip, options) {
            return localVarFp.getAllPointsOfSale(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a Point of Sale\'s associate users
         * @param {number} id The id of the Point of Sale of which to get the associate users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPointOfSaleAssociates(id, options) {
            return localVarFp.getPointOfSaleAssociates(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the requested Point of Sale
         * @param {number} id The id of the Point of Sale which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSinglePointOfSale(id, options) {
            return localVarFp.getSinglePointOfSale(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a Point of Sale transactions
         * @param {number} id The id of the Point of Sale of which to get the transactions.
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(id, take, skip, options) {
            return localVarFp.getTransactions(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update an existing Point of Sale.
         * @param {number} id The id of the Point of Sale which should be updated
         * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePointOfSale(id, updatePointOfSaleRequest, options) {
            return localVarFp.updatePointOfSale(id, updatePointOfSaleRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PointofsaleApiFactory = PointofsaleApiFactory;
/**
 * PointofsaleApi - object-oriented interface
 * @export
 * @class PointofsaleApi
 * @extends {BaseAPI}
 */
class PointofsaleApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create a new Point of Sale.
     * @param {CreatePointOfSaleRequest} createPointOfSaleRequest The point of sale which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    createPointOfSale(createPointOfSaleRequest, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).createPointOfSale(createPointOfSaleRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary (Soft) delete the given point of sale. Cannot be undone.
     * @param {number} id The id of the point of sale which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    deletePointOfSale(id, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).deletePointOfSale(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the containers of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointOfSaleContainers(id, take, skip, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getAllPointOfSaleContainers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the products of the requested Point of Sale, empty list if POS does not exist
     * @param {number} id The id of the point of sale
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointOfSaleProducts(id, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getAllPointOfSaleProducts(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all existing Point of Sales
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getAllPointsOfSale(take, skip, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getAllPointsOfSale(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a Point of Sale\'s associate users
     * @param {number} id The id of the Point of Sale of which to get the associate users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getPointOfSaleAssociates(id, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getPointOfSaleAssociates(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the requested Point of Sale
     * @param {number} id The id of the Point of Sale which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getSinglePointOfSale(id, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getSinglePointOfSale(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a Point of Sale transactions
     * @param {number} id The id of the Point of Sale of which to get the transactions.
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    getTransactions(id, take, skip, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).getTransactions(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update an existing Point of Sale.
     * @param {number} id The id of the Point of Sale which should be updated
     * @param {UpdatePointOfSaleRequest} updatePointOfSaleRequest    The Point of Sale which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointofsaleApi
     */
    updatePointOfSale(id, updatePointOfSaleRequest, options) {
        return (0, exports.PointofsaleApiFp)(this.configuration).updatePointOfSale(id, updatePointOfSaleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PointofsaleApi = PointofsaleApi;
/**
 * ProductCategoriesApi - axios parameter creator
 * @export
 */
const ProductCategoriesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post a new productCategory.
         * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory: (productCategoryRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productCategoryRequest' is not null or undefined
            (0, common_1.assertParamExists)('createProductCategory', 'productCategoryRequest', productCategoryRequest);
            const localVarPath = `/productcategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(productCategoryRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all existing productcategories
         * @param {boolean} [onlyRoot] Whether to return only root categories
         * @param {boolean} [onlyLeaf] Whether to return only leaf categories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories: (onlyRoot, onlyLeaf, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/productcategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (onlyRoot !== undefined) {
                localVarQueryParameter['onlyRoot'] = onlyRoot;
            }
            if (onlyLeaf !== undefined) {
                localVarQueryParameter['onlyLeaf'] = onlyLeaf;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleProductCategory', 'id', id);
            const localVarPath = `/productcategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory: (id, productCategoryRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateProductCategory', 'id', id);
            // verify required parameter 'productCategoryRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateProductCategory', 'productCategoryRequest', productCategoryRequest);
            const localVarPath = `/productcategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(productCategoryRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ProductCategoriesApiAxiosParamCreator = ProductCategoriesApiAxiosParamCreator;
/**
 * ProductCategoriesApi - functional programming interface
 * @export
 */
const ProductCategoriesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ProductCategoriesApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Post a new productCategory.
         * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory(productCategoryRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createProductCategory(productCategoryRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ProductCategoriesApi.createProductCategory']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all existing productcategories
         * @param {boolean} [onlyRoot] Whether to return only root categories
         * @param {boolean} [onlyLeaf] Whether to return only leaf categories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories(onlyRoot, onlyLeaf, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllProductCategories(onlyRoot, onlyLeaf, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ProductCategoriesApi.getAllProductCategories']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleProductCategory(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ProductCategoriesApi.getSingleProductCategory']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory(id, productCategoryRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateProductCategory(id, productCategoryRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ProductCategoriesApi.updateProductCategory']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.ProductCategoriesApiFp = ProductCategoriesApiFp;
/**
 * ProductCategoriesApi - factory interface
 * @export
 */
const ProductCategoriesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ProductCategoriesApiFp)(configuration);
    return {
        /**
         *
         * @summary Post a new productCategory.
         * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory(productCategoryRequest, options) {
            return localVarFp.createProductCategory(productCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all existing productcategories
         * @param {boolean} [onlyRoot] Whether to return only root categories
         * @param {boolean} [onlyLeaf] Whether to return only leaf categories
         * @param {number} [take] How many product categories the endpoint should return
         * @param {number} [skip] How many product categories should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductCategories(onlyRoot, onlyLeaf, take, skip, options) {
            return localVarFp.getAllProductCategories(onlyRoot, onlyLeaf, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the requested productcategory
         * @param {number} id The id of the productcategory which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProductCategory(id, options) {
            return localVarFp.getSingleProductCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update an existing productcategory.
         * @param {number} id The id of the productcategory which should be returned
         * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory(id, productCategoryRequest, options) {
            return localVarFp.updateProductCategory(id, productCategoryRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ProductCategoriesApiFactory = ProductCategoriesApiFactory;
/**
 * ProductCategoriesApi - object-oriented interface
 * @export
 * @class ProductCategoriesApi
 * @extends {BaseAPI}
 */
class ProductCategoriesApi extends base_1.BaseAPI {
    /**
     *
     * @summary Post a new productCategory.
     * @param {ProductCategoryRequest} productCategoryRequest The productCategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    createProductCategory(productCategoryRequest, options) {
        return (0, exports.ProductCategoriesApiFp)(this.configuration).createProductCategory(productCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all existing productcategories
     * @param {boolean} [onlyRoot] Whether to return only root categories
     * @param {boolean} [onlyLeaf] Whether to return only leaf categories
     * @param {number} [take] How many product categories the endpoint should return
     * @param {number} [skip] How many product categories should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    getAllProductCategories(onlyRoot, onlyLeaf, take, skip, options) {
        return (0, exports.ProductCategoriesApiFp)(this.configuration).getAllProductCategories(onlyRoot, onlyLeaf, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the requested productcategory
     * @param {number} id The id of the productcategory which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    getSingleProductCategory(id, options) {
        return (0, exports.ProductCategoriesApiFp)(this.configuration).getSingleProductCategory(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update an existing productcategory.
     * @param {number} id The id of the productcategory which should be returned
     * @param {ProductCategoryRequest} productCategoryRequest The productcategory which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    updateProductCategory(id, productCategoryRequest, options) {
        return (0, exports.ProductCategoriesApiFp)(this.configuration).updateProductCategory(id, productCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductCategoriesApi = ProductCategoriesApi;
/**
 * ProductsApi - axios parameter creator
 * @export
 */
const ProductsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a new product.
         * @param {CreateProductRequest} createProductRequest The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: (createProductRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createProductRequest' is not null or undefined
            (0, common_1.assertParamExists)('createProduct', 'createProductRequest', createProductRequest);
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createProductRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary (Soft) delete the given product. Cannot be undone.
         * @param {number} id The id of the product which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteProduct', 'id', id);
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleProduct', 'id', id);
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} updateProductRequest The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: (id, updateProductRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateProduct', 'id', id);
            // verify required parameter 'updateProductRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateProduct', 'updateProductRequest', updateProductRequest);
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateProductRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage: (id, file, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateProductImage', 'id', id);
            const localVarPath = `/products/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ProductsApiAxiosParamCreator = ProductsApiAxiosParamCreator;
/**
 * ProductsApi - functional programming interface
 * @export
 */
const ProductsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ProductsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new product.
         * @param {CreateProductRequest} createProductRequest The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(createProductRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createProduct(createProductRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.createProduct']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary (Soft) delete the given product. Cannot be undone.
         * @param {number} id The id of the product which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteProduct(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.deleteProduct']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllProducts(take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.getAllProducts']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleProduct(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.getSingleProduct']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} updateProductRequest The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id, updateProductRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateProduct(id, updateProductRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.updateProduct']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage(id, file, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateProductImage(id, file, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.updateProductImage']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.ProductsApiFp = ProductsApiFp;
/**
 * ProductsApi - factory interface
 * @export
 */
const ProductsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ProductsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new product.
         * @param {CreateProductRequest} createProductRequest The product which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(createProductRequest, options) {
            return localVarFp.createProduct(createProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary (Soft) delete the given product. Cannot be undone.
         * @param {number} id The id of the product which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id, options) {
            return localVarFp.deleteProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all existing products
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(take, skip, options) {
            return localVarFp.getAllProducts(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the requested product
         * @param {number} id The id of the product which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleProduct(id, options) {
            return localVarFp.getSingleProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update an existing product.
         * @param {number} id The id of the product which should be updated
         * @param {UpdateProductRequest} updateProductRequest The product which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id, updateProductRequest, options) {
            return localVarFp.updateProduct(id, updateProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload a new image for a product
         * @param {number} id The id of the product which should be returned
         * @param {File} [file] file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage(id, file, options) {
            return localVarFp.updateProductImage(id, file, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ProductsApiFactory = ProductsApiFactory;
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
class ProductsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create a new product.
     * @param {CreateProductRequest} createProductRequest The product which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    createProduct(createProductRequest, options) {
        return (0, exports.ProductsApiFp)(this.configuration).createProduct(createProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary (Soft) delete the given product. Cannot be undone.
     * @param {number} id The id of the product which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProduct(id, options) {
        return (0, exports.ProductsApiFp)(this.configuration).deleteProduct(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all existing products
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getAllProducts(take, skip, options) {
        return (0, exports.ProductsApiFp)(this.configuration).getAllProducts(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the requested product
     * @param {number} id The id of the product which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getSingleProduct(id, options) {
        return (0, exports.ProductsApiFp)(this.configuration).getSingleProduct(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update an existing product.
     * @param {number} id The id of the product which should be updated
     * @param {UpdateProductRequest} updateProductRequest The product which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    updateProduct(id, updateProductRequest, options) {
        return (0, exports.ProductsApiFp)(this.configuration).updateProduct(id, updateProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload a new image for a product
     * @param {number} id The id of the product which should be returned
     * @param {File} [file] file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    updateProductImage(id, file, options) {
        return (0, exports.ProductsApiFp)(this.configuration).updateProductImage(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductsApi = ProductsApi;
/**
 * RbacApi - axios parameter creator
 * @export
 */
const RbacApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Add new permissions to an existing role
         * @param {number} id The ID of the role which should get the new permissions
         * @param {Array<CreatePermissionParams>} createPermissionParams The permissions that need to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissions: (id, createPermissionParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('addPermissions', 'id', id);
            // verify required parameter 'createPermissionParams' is not null or undefined
            (0, common_1.assertParamExists)('addPermissions', 'createPermissionParams', createPermissionParams);
            const localVarPath = `/rbac/roles/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPermissionParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a new role
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: (updateRoleRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'updateRoleRequest' is not null or undefined
            (0, common_1.assertParamExists)('createRole', 'updateRoleRequest', updateRoleRequest);
            const localVarPath = `/rbac/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateRoleRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a permission from an existing role
         * @param {number} id The ID of the role
         * @param {string} entity The entity of the permission
         * @param {string} action The action of the permission
         * @param {string} relation The relation of the permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission: (id, entity, action, relation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deletePermission', 'id', id);
            // verify required parameter 'entity' is not null or undefined
            (0, common_1.assertParamExists)('deletePermission', 'entity', entity);
            // verify required parameter 'action' is not null or undefined
            (0, common_1.assertParamExists)('deletePermission', 'action', action);
            // verify required parameter 'relation' is not null or undefined
            (0, common_1.assertParamExists)('deletePermission', 'relation', relation);
            const localVarPath = `/rbac/roles/{id}/permissions/{entity}/{action}/{relation}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)))
                .replace(`{${"action"}}`, encodeURIComponent(String(action)))
                .replace(`{${"relation"}}`, encodeURIComponent(String(relation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete an existing role
         * @param {number} id The ID of the role which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteRole', 'id', id);
            const localVarPath = `/rbac/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/rbac/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get all users linked to a specific role
         * @param {number} id The ID of the role that the users are linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleUsers: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getRoleUsers', 'id', id);
            const localVarPath = `/rbac/roles/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a single existing role with its permissions
         * @param {number} id The ID of the role that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRole: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleRole', 'id', id);
            const localVarPath = `/rbac/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update an existing role
         * @param {number} id The ID of the role which should be updated
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: (id, updateRoleRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateRole', 'id', id);
            // verify required parameter 'updateRoleRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateRole', 'updateRoleRequest', updateRoleRequest);
            const localVarPath = `/rbac/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateRoleRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RbacApiAxiosParamCreator = RbacApiAxiosParamCreator;
/**
 * RbacApi - functional programming interface
 * @export
 */
const RbacApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RbacApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Add new permissions to an existing role
         * @param {number} id The ID of the role which should get the new permissions
         * @param {Array<CreatePermissionParams>} createPermissionParams The permissions that need to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissions(id, createPermissionParams, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addPermissions(id, createPermissionParams, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['RbacApi.addPermissions']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Create a new role
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(updateRoleRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createRole(updateRoleRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['RbacApi.createRole']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete a permission from an existing role
         * @param {number} id The ID of the role
         * @param {string} entity The entity of the permission
         * @param {string} action The action of the permission
         * @param {string} relation The relation of the permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission(id, entity, action, relation, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePermission(id, entity, action, relation, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['RbacApi.deletePermission']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete an existing role
         * @param {number} id The ID of the role which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteRole(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['RbacApi.deleteRole']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllRoles(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['RbacApi.getAllRoles']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get all users linked to a specific role
         * @param {number} id The ID of the role that the users are linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleUsers(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRoleUsers(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['RbacApi.getRoleUsers']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a single existing role with its permissions
         * @param {number} id The ID of the role that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRole(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleRole(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['RbacApi.getSingleRole']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update an existing role
         * @param {number} id The ID of the role which should be updated
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(id, updateRoleRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateRole(id, updateRoleRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['RbacApi.updateRole']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.RbacApiFp = RbacApiFp;
/**
 * RbacApi - factory interface
 * @export
 */
const RbacApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RbacApiFp)(configuration);
    return {
        /**
         *
         * @summary Add new permissions to an existing role
         * @param {number} id The ID of the role which should get the new permissions
         * @param {Array<CreatePermissionParams>} createPermissionParams The permissions that need to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissions(id, createPermissionParams, options) {
            return localVarFp.addPermissions(id, createPermissionParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new role
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(updateRoleRequest, options) {
            return localVarFp.createRole(updateRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a permission from an existing role
         * @param {number} id The ID of the role
         * @param {string} entity The entity of the permission
         * @param {string} action The action of the permission
         * @param {string} relation The relation of the permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission(id, entity, action, relation, options) {
            return localVarFp.deletePermission(id, entity, action, relation, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an existing role
         * @param {number} id The ID of the role which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id, options) {
            return localVarFp.deleteRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all existing roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options) {
            return localVarFp.getAllRoles(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all users linked to a specific role
         * @param {number} id The ID of the role that the users are linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleUsers(id, options) {
            return localVarFp.getRoleUsers(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a single existing role with its permissions
         * @param {number} id The ID of the role that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRole(id, options) {
            return localVarFp.getSingleRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update an existing role
         * @param {number} id The ID of the role which should be updated
         * @param {UpdateRoleRequest} updateRoleRequest The role which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(id, updateRoleRequest, options) {
            return localVarFp.updateRole(id, updateRoleRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.RbacApiFactory = RbacApiFactory;
/**
 * RbacApi - object-oriented interface
 * @export
 * @class RbacApi
 * @extends {BaseAPI}
 */
class RbacApi extends base_1.BaseAPI {
    /**
     *
     * @summary Add new permissions to an existing role
     * @param {number} id The ID of the role which should get the new permissions
     * @param {Array<CreatePermissionParams>} createPermissionParams The permissions that need to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    addPermissions(id, createPermissionParams, options) {
        return (0, exports.RbacApiFp)(this.configuration).addPermissions(id, createPermissionParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new role
     * @param {UpdateRoleRequest} updateRoleRequest The role which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    createRole(updateRoleRequest, options) {
        return (0, exports.RbacApiFp)(this.configuration).createRole(updateRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a permission from an existing role
     * @param {number} id The ID of the role
     * @param {string} entity The entity of the permission
     * @param {string} action The action of the permission
     * @param {string} relation The relation of the permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    deletePermission(id, entity, action, relation, options) {
        return (0, exports.RbacApiFp)(this.configuration).deletePermission(id, entity, action, relation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete an existing role
     * @param {number} id The ID of the role which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    deleteRole(id, options) {
        return (0, exports.RbacApiFp)(this.configuration).deleteRole(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all existing roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    getAllRoles(options) {
        return (0, exports.RbacApiFp)(this.configuration).getAllRoles(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all users linked to a specific role
     * @param {number} id The ID of the role that the users are linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    getRoleUsers(id, options) {
        return (0, exports.RbacApiFp)(this.configuration).getRoleUsers(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a single existing role with its permissions
     * @param {number} id The ID of the role that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    getSingleRole(id, options) {
        return (0, exports.RbacApiFp)(this.configuration).getSingleRole(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update an existing role
     * @param {number} id The ID of the role which should be updated
     * @param {UpdateRoleRequest} updateRoleRequest The role which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacApi
     */
    updateRole(id, updateRoleRequest, options) {
        return (0, exports.RbacApiFp)(this.configuration).updateRole(id, updateRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RbacApi = RbacApi;
/**
 * RootApi - axios parameter creator
 * @export
 */
const RootApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get the current status of the backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RootApiAxiosParamCreator = RootApiAxiosParamCreator;
/**
 * RootApi - functional programming interface
 * @export
 */
const RootApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RootApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get the current status of the backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ping(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['RootApi.ping']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.RootApiFp = RootApiFp;
/**
 * RootApi - factory interface
 * @export
 */
const RootApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RootApiFp)(configuration);
    return {
        /**
         *
         * @summary Get the current status of the backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};
exports.RootApiFactory = RootApiFactory;
/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
class RootApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get the current status of the backend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    ping(options) {
        return (0, exports.RootApiFp)(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RootApi = RootApi;
/**
 * SellerPayoutsApi - axios parameter creator
 * @export
 */
const SellerPayoutsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a new seller payout
         * @param {CreateSellerPayoutRequest} createSellerPayoutRequest New seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSellerPayout: (createSellerPayoutRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createSellerPayoutRequest' is not null or undefined
            (0, common_1.assertParamExists)('createSellerPayout', 'createSellerPayoutRequest', createSellerPayoutRequest);
            const localVarPath = `/seller-payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createSellerPayoutRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSellerPayout: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteSellerPayout', 'id', id);
            const localVarPath = `/seller-payouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Return all seller payouts
         * @param {number} [requestedById] Requested by user ID
         * @param {string} [fromDate] Lower bound on seller payout creation date (inclusive)
         * @param {string} [tillDate] Upper bound on seller payout creation date (exclusive)
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSellerPayouts: (requestedById, fromDate, tillDate, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/seller-payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (requestedById !== undefined) {
                localVarQueryParameter['requestedById'] = requestedById;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a single seller payout\'s sales report
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellerPayoutReport: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSellerPayoutReport', 'id', id);
            const localVarPath = `/seller-payouts/{id}/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a single seller payout\'s sales report as PDF
         * @param {number} id ID of the seller payout that should be returned
         * @param {boolean} [force] Force the generation of the PDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellerPayoutReportPdf: (id, force, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSellerPayoutReportPdf', 'id', id);
            const localVarPath = `/seller-payouts/{id}/report/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a single seller payout
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSellerPayout: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleSellerPayout', 'id', id);
            const localVarPath = `/seller-payouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {UpdateSellerPayoutRequest} updateSellerPayoutRequest Updated seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSellerPayout: (id, updateSellerPayoutRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateSellerPayout', 'id', id);
            // verify required parameter 'updateSellerPayoutRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateSellerPayout', 'updateSellerPayoutRequest', updateSellerPayoutRequest);
            const localVarPath = `/seller-payouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateSellerPayoutRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SellerPayoutsApiAxiosParamCreator = SellerPayoutsApiAxiosParamCreator;
/**
 * SellerPayoutsApi - functional programming interface
 * @export
 */
const SellerPayoutsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SellerPayoutsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new seller payout
         * @param {CreateSellerPayoutRequest} createSellerPayoutRequest New seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSellerPayout(createSellerPayoutRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createSellerPayout(createSellerPayoutRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['SellerPayoutsApi.createSellerPayout']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSellerPayout(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSellerPayout(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['SellerPayoutsApi.deleteSellerPayout']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Return all seller payouts
         * @param {number} [requestedById] Requested by user ID
         * @param {string} [fromDate] Lower bound on seller payout creation date (inclusive)
         * @param {string} [tillDate] Upper bound on seller payout creation date (exclusive)
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSellerPayouts(requestedById, fromDate, tillDate, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllSellerPayouts(requestedById, fromDate, tillDate, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['SellerPayoutsApi.getAllSellerPayouts']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a single seller payout\'s sales report
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellerPayoutReport(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSellerPayoutReport(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['SellerPayoutsApi.getSellerPayoutReport']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a single seller payout\'s sales report as PDF
         * @param {number} id ID of the seller payout that should be returned
         * @param {boolean} [force] Force the generation of the PDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellerPayoutReportPdf(id, force, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSellerPayoutReportPdf(id, force, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['SellerPayoutsApi.getSellerPayoutReportPdf']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a single seller payout
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSellerPayout(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleSellerPayout(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['SellerPayoutsApi.getSingleSellerPayout']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {UpdateSellerPayoutRequest} updateSellerPayoutRequest Updated seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSellerPayout(id, updateSellerPayoutRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateSellerPayout(id, updateSellerPayoutRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['SellerPayoutsApi.updateSellerPayout']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.SellerPayoutsApiFp = SellerPayoutsApiFp;
/**
 * SellerPayoutsApi - factory interface
 * @export
 */
const SellerPayoutsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SellerPayoutsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new seller payout
         * @param {CreateSellerPayoutRequest} createSellerPayoutRequest New seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSellerPayout(createSellerPayoutRequest, options) {
            return localVarFp.createSellerPayout(createSellerPayoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSellerPayout(id, options) {
            return localVarFp.deleteSellerPayout(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all seller payouts
         * @param {number} [requestedById] Requested by user ID
         * @param {string} [fromDate] Lower bound on seller payout creation date (inclusive)
         * @param {string} [tillDate] Upper bound on seller payout creation date (exclusive)
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSellerPayouts(requestedById, fromDate, tillDate, take, skip, options) {
            return localVarFp.getAllSellerPayouts(requestedById, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a single seller payout\'s sales report
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellerPayoutReport(id, options) {
            return localVarFp.getSellerPayoutReport(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a single seller payout\'s sales report as PDF
         * @param {number} id ID of the seller payout that should be returned
         * @param {boolean} [force] Force the generation of the PDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellerPayoutReportPdf(id, force, options) {
            return localVarFp.getSellerPayoutReportPdf(id, force, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a single seller payout
         * @param {number} id ID of the seller payout that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSellerPayout(id, options) {
            return localVarFp.getSingleSellerPayout(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update an existing seller payout
         * @param {number} id ID of the seller payout that should be updated
         * @param {UpdateSellerPayoutRequest} updateSellerPayoutRequest Updated seller payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSellerPayout(id, updateSellerPayoutRequest, options) {
            return localVarFp.updateSellerPayout(id, updateSellerPayoutRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SellerPayoutsApiFactory = SellerPayoutsApiFactory;
/**
 * SellerPayoutsApi - object-oriented interface
 * @export
 * @class SellerPayoutsApi
 * @extends {BaseAPI}
 */
class SellerPayoutsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create a new seller payout
     * @param {CreateSellerPayoutRequest} createSellerPayoutRequest New seller payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    createSellerPayout(createSellerPayoutRequest, options) {
        return (0, exports.SellerPayoutsApiFp)(this.configuration).createSellerPayout(createSellerPayoutRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete an existing seller payout
     * @param {number} id ID of the seller payout that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    deleteSellerPayout(id, options) {
        return (0, exports.SellerPayoutsApiFp)(this.configuration).deleteSellerPayout(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return all seller payouts
     * @param {number} [requestedById] Requested by user ID
     * @param {string} [fromDate] Lower bound on seller payout creation date (inclusive)
     * @param {string} [tillDate] Upper bound on seller payout creation date (exclusive)
     * @param {number} [take] Number of write-offs to return
     * @param {number} [skip] Number of write-offs to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    getAllSellerPayouts(requestedById, fromDate, tillDate, take, skip, options) {
        return (0, exports.SellerPayoutsApiFp)(this.configuration).getAllSellerPayouts(requestedById, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a single seller payout\'s sales report
     * @param {number} id ID of the seller payout that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    getSellerPayoutReport(id, options) {
        return (0, exports.SellerPayoutsApiFp)(this.configuration).getSellerPayoutReport(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a single seller payout\'s sales report as PDF
     * @param {number} id ID of the seller payout that should be returned
     * @param {boolean} [force] Force the generation of the PDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    getSellerPayoutReportPdf(id, force, options) {
        return (0, exports.SellerPayoutsApiFp)(this.configuration).getSellerPayoutReportPdf(id, force, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a single seller payout
     * @param {number} id ID of the seller payout that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    getSingleSellerPayout(id, options) {
        return (0, exports.SellerPayoutsApiFp)(this.configuration).getSingleSellerPayout(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update an existing seller payout
     * @param {number} id ID of the seller payout that should be updated
     * @param {UpdateSellerPayoutRequest} updateSellerPayoutRequest Updated seller payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerPayoutsApi
     */
    updateSellerPayout(id, updateSellerPayoutRequest, options) {
        return (0, exports.SellerPayoutsApiFp)(this.configuration).updateSellerPayout(id, updateSellerPayoutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SellerPayoutsApi = SellerPayoutsApi;
/**
 * ServerSettingsApi - axios parameter creator
 * @export
 */
const ServerSettingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Enable/disable maintenance mode
         * @param {UpdateMaintenanceModeRequest} updateMaintenanceModeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaintenanceMode: (updateMaintenanceModeRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'updateMaintenanceModeRequest' is not null or undefined
            (0, common_1.assertParamExists)('setMaintenanceMode', 'updateMaintenanceModeRequest', updateMaintenanceModeRequest);
            const localVarPath = `/server-settings/maintenance-mode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateMaintenanceModeRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ServerSettingsApiAxiosParamCreator = ServerSettingsApiAxiosParamCreator;
/**
 * ServerSettingsApi - functional programming interface
 * @export
 */
const ServerSettingsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ServerSettingsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Enable/disable maintenance mode
         * @param {UpdateMaintenanceModeRequest} updateMaintenanceModeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaintenanceMode(updateMaintenanceModeRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.setMaintenanceMode(updateMaintenanceModeRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['ServerSettingsApi.setMaintenanceMode']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.ServerSettingsApiFp = ServerSettingsApiFp;
/**
 * ServerSettingsApi - factory interface
 * @export
 */
const ServerSettingsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ServerSettingsApiFp)(configuration);
    return {
        /**
         *
         * @summary Enable/disable maintenance mode
         * @param {UpdateMaintenanceModeRequest} updateMaintenanceModeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaintenanceMode(updateMaintenanceModeRequest, options) {
            return localVarFp.setMaintenanceMode(updateMaintenanceModeRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ServerSettingsApiFactory = ServerSettingsApiFactory;
/**
 * ServerSettingsApi - object-oriented interface
 * @export
 * @class ServerSettingsApi
 * @extends {BaseAPI}
 */
class ServerSettingsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Enable/disable maintenance mode
     * @param {UpdateMaintenanceModeRequest} updateMaintenanceModeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSettingsApi
     */
    setMaintenanceMode(updateMaintenanceModeRequest, options) {
        return (0, exports.ServerSettingsApiFp)(this.configuration).setMaintenanceMode(updateMaintenanceModeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ServerSettingsApi = ServerSettingsApi;
/**
 * StripeApi - axios parameter creator
 * @export
 */
const StripeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Start the stripe deposit flow
         * @param {StripeRequest} stripeRequest The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: (stripeRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'stripeRequest' is not null or undefined
            (0, common_1.assertParamExists)('deposit', 'stripeRequest', stripeRequest);
            const localVarPath = `/stripe/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(stripeRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get the Stripe public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripePublicKey: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/stripe/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.StripeApiAxiosParamCreator = StripeApiAxiosParamCreator;
/**
 * StripeApi - functional programming interface
 * @export
 */
const StripeApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.StripeApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Start the stripe deposit flow
         * @param {StripeRequest} stripeRequest The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(stripeRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deposit(stripeRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['StripeApi.deposit']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get the Stripe public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripePublicKey(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getStripePublicKey(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['StripeApi.getStripePublicKey']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.StripeApiFp = StripeApiFp;
/**
 * StripeApi - factory interface
 * @export
 */
const StripeApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.StripeApiFp)(configuration);
    return {
        /**
         *
         * @summary Start the stripe deposit flow
         * @param {StripeRequest} stripeRequest The deposit that should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(stripeRequest, options) {
            return localVarFp.deposit(stripeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the Stripe public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripePublicKey(options) {
            return localVarFp.getStripePublicKey(options).then((request) => request(axios, basePath));
        },
    };
};
exports.StripeApiFactory = StripeApiFactory;
/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
class StripeApi extends base_1.BaseAPI {
    /**
     *
     * @summary Start the stripe deposit flow
     * @param {StripeRequest} stripeRequest The deposit that should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    deposit(stripeRequest, options) {
        return (0, exports.StripeApiFp)(this.configuration).deposit(stripeRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the Stripe public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    getStripePublicKey(options) {
        return (0, exports.StripeApiFp)(this.configuration).getStripePublicKey(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StripeApi = StripeApi;
/**
 * TestOperationsOfTheTestControllerApi - axios parameter creator
 * @export
 */
const TestOperationsOfTheTestControllerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/test/helloworld`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TestOperationsOfTheTestControllerApiAxiosParamCreator = TestOperationsOfTheTestControllerApiAxiosParamCreator;
/**
 * TestOperationsOfTheTestControllerApi - functional programming interface
 * @export
 */
const TestOperationsOfTheTestControllerApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TestOperationsOfTheTestControllerApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.helloworld(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['TestOperationsOfTheTestControllerApi.helloworld']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.TestOperationsOfTheTestControllerApiFp = TestOperationsOfTheTestControllerApiFp;
/**
 * TestOperationsOfTheTestControllerApi - factory interface
 * @export
 */
const TestOperationsOfTheTestControllerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TestOperationsOfTheTestControllerApiFp)(configuration);
    return {
        /**
         *
         * @summary Get a beautiful Hello World email to your inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloworld(options) {
            return localVarFp.helloworld(options).then((request) => request(axios, basePath));
        },
    };
};
exports.TestOperationsOfTheTestControllerApiFactory = TestOperationsOfTheTestControllerApiFactory;
/**
 * TestOperationsOfTheTestControllerApi - object-oriented interface
 * @export
 * @class TestOperationsOfTheTestControllerApi
 * @extends {BaseAPI}
 */
class TestOperationsOfTheTestControllerApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get a beautiful Hello World email to your inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestOperationsOfTheTestControllerApi
     */
    helloworld(options) {
        return (0, exports.TestOperationsOfTheTestControllerApiFp)(this.configuration).helloworld(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TestOperationsOfTheTestControllerApi = TestOperationsOfTheTestControllerApi;
/**
 * TransactionSummariesApi - axios parameter creator
 * @export
 */
const TransactionSummariesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns a summary of all purchases within a container
         * @param {number} id The ID of the container
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSingleContainerSummary: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleContainerSummary', 'id', id);
            const localVarPath = `/transactions/summary/container/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TransactionSummariesApiAxiosParamCreator = TransactionSummariesApiAxiosParamCreator;
/**
 * TransactionSummariesApi - functional programming interface
 * @export
 */
const TransactionSummariesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransactionSummariesApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Returns a summary of all purchases within a container
         * @param {number} id The ID of the container
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSingleContainerSummary(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleContainerSummary(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['TransactionSummariesApi.getSingleContainerSummary']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.TransactionSummariesApiFp = TransactionSummariesApiFp;
/**
 * TransactionSummariesApi - factory interface
 * @export
 */
const TransactionSummariesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransactionSummariesApiFp)(configuration);
    return {
        /**
         *
         * @summary Returns a summary of all purchases within a container
         * @param {number} id The ID of the container
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSingleContainerSummary(id, options) {
            return localVarFp.getSingleContainerSummary(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransactionSummariesApiFactory = TransactionSummariesApiFactory;
/**
 * TransactionSummariesApi - object-oriented interface
 * @export
 * @class TransactionSummariesApi
 * @extends {BaseAPI}
 */
class TransactionSummariesApi extends base_1.BaseAPI {
    /**
     *
     * @summary Returns a summary of all purchases within a container
     * @param {number} id The ID of the container
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TransactionSummariesApi
     */
    getSingleContainerSummary(id, options) {
        return (0, exports.TransactionSummariesApiFp)(this.configuration).getSingleContainerSummary(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransactionSummariesApi = TransactionSummariesApi;
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
const TransactionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Creates a new transaction
         * @param {TransactionRequest} transactionRequest The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: (transactionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'transactionRequest' is not null or undefined
            (0, common_1.assertParamExists)('createTransaction', 'transactionRequest', transactionRequest);
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteTransaction', 'id', id);
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [excludeById] Your own ID to not include in transactions
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions: (fromId, createdById, toId, excludeById, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }
            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }
            if (excludeById !== undefined) {
                localVarQueryParameter['excludeById'] = excludeById;
            }
            if (pointOfSaleId !== undefined) {
                localVarQueryParameter['pointOfSaleId'] = pointOfSaleId;
            }
            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }
            if (productRevision !== undefined) {
                localVarQueryParameter['productRevision'] = productRevision;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleTransaction', 'id', id);
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transactionRequest The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: (id, transactionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateTransaction', 'id', id);
            // verify required parameter 'transactionRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateTransaction', 'transactionRequest', transactionRequest);
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transactionRequest The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction: (transactionRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'transactionRequest' is not null or undefined
            (0, common_1.assertParamExists)('validateTransaction', 'transactionRequest', transactionRequest);
            const localVarPath = `/transactions/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TransactionsApiAxiosParamCreator = TransactionsApiAxiosParamCreator;
/**
 * TransactionsApi - functional programming interface
 * @export
 */
const TransactionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransactionsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Creates a new transaction
         * @param {TransactionRequest} transactionRequest The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(transactionRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTransaction(transactionRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.createTransaction']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTransaction(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.deleteTransaction']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [excludeById] Your own ID to not include in transactions
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(fromId, createdById, toId, excludeById, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllTransactions(fromId, createdById, toId, excludeById, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.getAllTransactions']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleTransaction(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.getSingleTransaction']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transactionRequest The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id, transactionRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTransaction(id, transactionRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.updateTransaction']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transactionRequest The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction(transactionRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.validateTransaction(transactionRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['TransactionsApi.validateTransaction']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.TransactionsApiFp = TransactionsApiFp;
/**
 * TransactionsApi - factory interface
 * @export
 */
const TransactionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransactionsApiFp)(configuration);
    return {
        /**
         *
         * @summary Creates a new transaction
         * @param {TransactionRequest} transactionRequest The transaction which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(transactionRequest, options) {
            return localVarFp.createTransaction(transactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a transaction
         * @param {number} id The id of the transaction which should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id, options) {
            return localVarFp.deleteTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a list of all transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [excludeById] Your own ID to not include in transactions
         * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(fromId, createdById, toId, excludeById, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options) {
            return localVarFp.getAllTransactions(fromId, createdById, toId, excludeById, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a single transaction
         * @param {number} id The id of the transaction which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransaction(id, options) {
            return localVarFp.getSingleTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates the requested transaction
         * @param {number} id The id of the transaction which should be updated
         * @param {TransactionRequest} transactionRequest The updated transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id, transactionRequest, options) {
            return localVarFp.updateTransaction(id, transactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Function to validate the transaction immediatly after it is created
         * @param {TransactionRequest} transactionRequest The transaction which should be validated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTransaction(transactionRequest, options) {
            return localVarFp.validateTransaction(transactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransactionsApiFactory = TransactionsApiFactory;
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Creates a new transaction
     * @param {TransactionRequest} transactionRequest The transaction which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    createTransaction(transactionRequest, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).createTransaction(transactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a transaction
     * @param {number} id The id of the transaction which should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    deleteTransaction(id, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).deleteTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a list of all transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [excludeById] Your own ID to not include in transactions
     * @param {number} [pointOfSaleId] Point of sale ID for selected transactions
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getAllTransactions(fromId, createdById, toId, excludeById, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).getAllTransactions(fromId, createdById, toId, excludeById, pointOfSaleId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a single transaction
     * @param {number} id The id of the transaction which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getSingleTransaction(id, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).getSingleTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates the requested transaction
     * @param {number} id The id of the transaction which should be updated
     * @param {TransactionRequest} transactionRequest The updated transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    updateTransaction(id, transactionRequest, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).updateTransaction(id, transactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Function to validate the transaction immediatly after it is created
     * @param {TransactionRequest} transactionRequest The transaction which should be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    validateTransaction(transactionRequest, options) {
        return (0, exports.TransactionsApiFp)(this.configuration).validateTransaction(transactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransactionsApi = TransactionsApi;
/**
 * TransfersApi - axios parameter creator
 * @export
 */
const TransfersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post a new transfer.
         * @param {TransferRequest} transferRequest The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: (transferRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'transferRequest' is not null or undefined
            (0, common_1.assertParamExists)('createTransfer', 'transferRequest', transferRequest);
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transferRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleTransfer', 'id', id);
            const localVarPath = `/transfers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TransfersApiAxiosParamCreator = TransfersApiAxiosParamCreator;
/**
 * TransfersApi - functional programming interface
 * @export
 */
const TransfersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransfersApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Post a new transfer.
         * @param {TransferRequest} transferRequest The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(transferRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTransfer(transferRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['TransfersApi.createTransfer']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers(take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllTransfers(take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['TransfersApi.getAllTransfers']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleTransfer(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['TransfersApi.getSingleTransfer']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.TransfersApiFp = TransfersApiFp;
/**
 * TransfersApi - factory interface
 * @export
 */
const TransfersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransfersApiFp)(configuration);
    return {
        /**
         *
         * @summary Post a new transfer.
         * @param {TransferRequest} transferRequest The transfer which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(transferRequest, options) {
            return localVarFp.createTransfer(transferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all existing transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransfers(take, skip, options) {
            return localVarFp.getAllTransfers(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the requested transfer
         * @param {number} id The id of the transfer which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTransfer(id, options) {
            return localVarFp.getSingleTransfer(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransfersApiFactory = TransfersApiFactory;
/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
class TransfersApi extends base_1.BaseAPI {
    /**
     *
     * @summary Post a new transfer.
     * @param {TransferRequest} transferRequest The transfer which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createTransfer(transferRequest, options) {
        return (0, exports.TransfersApiFp)(this.configuration).createTransfer(transferRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all existing transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getAllTransfers(take, skip, options) {
        return (0, exports.TransfersApiFp)(this.configuration).getAllTransfers(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the requested transfer
     * @param {number} id The id of the transfer which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getSingleTransfer(id, options) {
        return (0, exports.TransfersApiFp)(this.configuration).getSingleTransfer(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransfersApi = TransfersApi;
/**
 * UsersApi - axios parameter creator
 * @export
 */
const UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos: (acceptTosRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'acceptTosRequest' is not null or undefined
            (0, common_1.assertParamExists)('acceptTos', 'acceptTosRequest', acceptTosRequest);
            const localVarPath = `/users/acceptTos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(acceptTosRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('authenticateAs', 'id', id);
            const localVarPath = `/users/{id}/authenticate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a new user
         * @param {CreateUserRequest} createUserRequest The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: (createUserRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createUserRequest' is not null or undefined
            (0, common_1.assertParamExists)('createUser', 'createUserRequest', createUserRequest);
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createUserRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteUser', 'id', id);
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteUserKey', 'id', id);
            const localVarPath = `/users/{id}/authenticator/key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteUserNfc', 'id', id);
            const localVarPath = `/users/{id}/authenticator/nfc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a user using the nfc code
         * @param {string} nfcCode The nfc code of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserNfc: (nfcCode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'nfcCode' is not null or undefined
            (0, common_1.assertParamExists)('findUserNfc', 'nfcCode', nfcCode);
            const localVarPath = `/users/nfc/{nfcCode}`
                .replace(`{${"nfcCode"}}`, encodeURIComponent(String(nfcCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: (take, skip, search, active, ofAge, id, type, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }
            if (ofAge !== undefined) {
                localVarQueryParameter['ofAge'] = ofAge;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType: (userType, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userType' is not null or undefined
            (0, common_1.assertParamExists)('getAllUsersOfUserType', 'userType', userType);
            const localVarPath = `/users/usertype/{userType}`
                .replace(`{${"userType"}}`, encodeURIComponent(String(userType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getIndividualUser', 'id', id);
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getOrganMembers', 'id', id);
            const localVarPath = `/users/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUserAuthenticatable', 'id', id);
            const localVarPath = `/users/{id}/authenticate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUserRoles', 'id', id);
            const localVarPath = `/users/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersContainers', 'id', id);
            const localVarPath = `/users/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get all financial mutations of a user (from or to).
         * @param {number} id The id of the user to get the mutations from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations: (id, fromDate, tillDate, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersFinancialMutations', 'id', id);
            const localVarPath = `/users/{id}/financialmutations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersPointsOfSale', 'id', id);
            const localVarPath = `/users/{id}/pointsofsale`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersProcessingDeposits', 'id', id);
            const localVarPath = `/users/{id}/deposits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts: (id, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersProducts', 'id', id);
            const localVarPath = `/users/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get purchase report pdf for the given user
         * @param {number} id The id of the user to get the purchase report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {GetUsersPurchaseReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPurchaseReportPdf: (id, fromDate, tillDate, fileType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersPurchaseReportPdf', 'id', id);
            // verify required parameter 'fromDate' is not null or undefined
            (0, common_1.assertParamExists)('getUsersPurchaseReportPdf', 'fromDate', fromDate);
            // verify required parameter 'tillDate' is not null or undefined
            (0, common_1.assertParamExists)('getUsersPurchaseReportPdf', 'tillDate', tillDate);
            const localVarPath = `/users/{id}/transactions/purchases/report/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get purchases report for the given user
         * @param {number} id The id of the user to get the purchases report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPurchasesReport: (id, fromDate, tillDate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersPurchasesReport', 'id', id);
            // verify required parameter 'fromDate' is not null or undefined
            (0, common_1.assertParamExists)('getUsersPurchasesReport', 'fromDate', fromDate);
            // verify required parameter 'tillDate' is not null or undefined
            (0, common_1.assertParamExists)('getUsersPurchasesReport', 'tillDate', tillDate);
            const localVarPath = `/users/{id}/transactions/purchases/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSalesReport: (id, fromDate, tillDate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersSalesReport', 'id', id);
            // verify required parameter 'fromDate' is not null or undefined
            (0, common_1.assertParamExists)('getUsersSalesReport', 'fromDate', fromDate);
            // verify required parameter 'tillDate' is not null or undefined
            (0, common_1.assertParamExists)('getUsersSalesReport', 'tillDate', tillDate);
            const localVarPath = `/users/{id}/transactions/sales/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {string} [description] Description of the report
         * @param {GetUsersSalesReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSalesReportPdf: (id, fromDate, tillDate, description, fileType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersSalesReportPdf', 'id', id);
            // verify required parameter 'fromDate' is not null or undefined
            (0, common_1.assertParamExists)('getUsersSalesReportPdf', 'fromDate', fromDate);
            // verify required parameter 'tillDate' is not null or undefined
            (0, common_1.assertParamExists)('getUsersSalesReportPdf', 'tillDate', tillDate);
            const localVarPath = `/users/{id}/transactions/sales/report/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get transactions from a user.
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions: (id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersTransactions', 'id', id);
            const localVarPath = `/users/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }
            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }
            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }
            if (productRevision !== undefined) {
                localVarQueryParameter['productRevision'] = productRevision;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUsersTransactionsReport: (id, fromDate, tillDate, fromId, toId, exclusiveToId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersTransactionsReport', 'id', id);
            const localVarPath = `/users/{id}/transactions/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }
            if (exclusiveToId !== undefined) {
                localVarQueryParameter['exclusiveToId'] = exclusiveToId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get transfers to or from an user.
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers: (id, take, skip, fromId, toId, id2, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getUsersTransfers', 'id', id);
            const localVarPath = `/users/{id}/transfers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (fromId !== undefined) {
                localVarQueryParameter['fromId'] = fromId;
            }
            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }
            if (id2 !== undefined) {
                localVarQueryParameter['id'] = id2;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} updateUserRequest The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: (id, updateUserRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUser', 'id', id);
            // verify required parameter 'updateUserRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateUser', 'updateUserRequest', updateUserRequest);
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateUserRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUserKey', 'id', id);
            const localVarPath = `/users/{id}/authenticator/key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} updateLocalRequest    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword: (id, updateLocalRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUserLocalPassword', 'id', id);
            // verify required parameter 'updateLocalRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateUserLocalPassword', 'updateLocalRequest', updateLocalRequest);
            const localVarPath = `/users/{id}/authenticator/local`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateLocalRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc: (id, updateNfcRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUserNfc', 'id', id);
            // verify required parameter 'updateNfcRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateUserNfc', 'updateNfcRequest', updateNfcRequest);
            const localVarPath = `/users/{id}/authenticator/nfc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateNfcRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin: (id, updatePinRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUserPin', 'id', id);
            // verify required parameter 'updatePinRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateUserPin', 'updatePinRequest', updatePinRequest);
            const localVarPath = `/users/{id}/authenticator/pin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updatePinRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {WaiveFinesRequest} [waiveFinesRequest] Optional body, see https://github.com/GEWIS/sudosos-backend/pull/344
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waiveUserFines: (id, waiveFinesRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('waiveUserFines', 'id', id);
            const localVarPath = `/users/{id}/fines/waive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(waiveFinesRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator;
/**
 * UsersApi - functional programming interface
 * @export
 */
const UsersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UsersApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos(acceptTosRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptTos(acceptTosRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.acceptTos']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.authenticateAs(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.authenticateAs']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Create a new user
         * @param {CreateUserRequest} createUserRequest The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createUser(createUserRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.createUser']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUser(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.deleteUser']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserKey(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.deleteUserKey']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserNfc(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.deleteUserNfc']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a user using the nfc code
         * @param {string} nfcCode The nfc code of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserNfc(nfcCode, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findUserNfc(nfcCode, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.findUserNfc']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(take, skip, search, active, ofAge, id, type, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllUsers(take, skip, search, active, ofAge, id, type, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getAllUsers']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType(userType, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllUsersOfUserType(userType, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getAllUsersOfUserType']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getIndividualUser(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getIndividualUser']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers(id, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganMembers(id, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getOrganMembers']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserAuthenticatable(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUserAuthenticatable']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserRoles(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUserRoles']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers(id, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersContainers(id, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersContainers']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get all financial mutations of a user (from or to).
         * @param {number} id The id of the user to get the mutations from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations(id, fromDate, tillDate, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersFinancialMutations(id, fromDate, tillDate, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersFinancialMutations']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale(id, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersPointsOfSale(id, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersPointsOfSale']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersProcessingDeposits(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersProcessingDeposits']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts(id, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersProducts(id, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersProducts']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get purchase report pdf for the given user
         * @param {number} id The id of the user to get the purchase report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {GetUsersPurchaseReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPurchaseReportPdf(id, fromDate, tillDate, fileType, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersPurchaseReportPdf(id, fromDate, tillDate, fileType, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersPurchaseReportPdf']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get purchases report for the given user
         * @param {number} id The id of the user to get the purchases report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPurchasesReport(id, fromDate, tillDate, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersPurchasesReport(id, fromDate, tillDate, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersPurchasesReport']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSalesReport(id, fromDate, tillDate, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersSalesReport(id, fromDate, tillDate, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersSalesReport']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {string} [description] Description of the report
         * @param {GetUsersSalesReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSalesReportPdf(id, fromDate, tillDate, description, fileType, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersSalesReportPdf(id, fromDate, tillDate, description, fileType, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersSalesReportPdf']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get transactions from a user.
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersTransactions']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersTransactionsReport']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get transfers to or from an user.
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers(id, take, skip, fromId, toId, id2, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersTransfers(id, take, skip, fromId, toId, id2, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.getUsersTransfers']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} updateUserRequest The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id, updateUserRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUser(id, updateUserRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.updateUser']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserKey(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.updateUserKey']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} updateLocalRequest    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword(id, updateLocalRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserLocalPassword(id, updateLocalRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.updateUserLocalPassword']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc(id, updateNfcRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserNfc(id, updateNfcRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.updateUserNfc']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin(id, updatePinRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserPin(id, updatePinRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.updateUserPin']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {WaiveFinesRequest} [waiveFinesRequest] Optional body, see https://github.com/GEWIS/sudosos-backend/pull/344
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waiveUserFines(id, waiveFinesRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.waiveUserFines(id, waiveFinesRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['UsersApi.waiveUserFines']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.UsersApiFp = UsersApiFp;
/**
 * UsersApi - factory interface
 * @export
 */
const UsersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UsersApiFp)(configuration);
    return {
        /**
         *
         * @summary Accept the Terms of Service if you have not accepted it yet
         * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptTos(acceptTosRequest, options) {
            return localVarFp.acceptTos(acceptTosRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Authenticate as another user
         * @param {number} id The id of the user that should be authenticated as
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAs(id, options) {
            return localVarFp.authenticateAs(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new user
         * @param {CreateUserRequest} createUserRequest The user which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest, options) {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a single user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id, options) {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a users key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKey(id, options) {
            return localVarFp.deleteUserKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a nfc code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserNfc(id, options) {
            return localVarFp.deleteUserNfc(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a user using the nfc code
         * @param {string} nfcCode The nfc code of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserNfc(nfcCode, options) {
            return localVarFp.findUserNfc(nfcCode, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a list of all users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {string} [search] Filter based on first name
         * @param {boolean} [active] Filter based if the user is active
         * @param {boolean} [ofAge] Filter based if the user is 18+
         * @param {number} [id] Filter based on user ID
         * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(take, skip, search, active, ofAge, id, type, options) {
            return localVarFp.getAllUsers(take, skip, search, active, ofAge, id, type, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all users of user type
         * @param {string} userType The userType of the requested users
         * @param {number} [take] How many users the endpoint should return
         * @param {number} [skip] How many users should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsersOfUserType(userType, take, skip, options) {
            return localVarFp.getAllUsersOfUserType(userType, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an individual user
         * @param {number} id userID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndividualUser(id, options) {
            return localVarFp.getIndividualUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an organs members
         * @param {number} id The id of the user
         * @param {number} [take] How many members the endpoint should return
         * @param {number} [skip] How many members should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganMembers(id, take, skip, options) {
            return localVarFp.getOrganMembers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all users that the user can authenticate as
         * @param {number} id The id of the user to get authentications of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthenticatable(id, options) {
            return localVarFp.getUserAuthenticatable(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all roles assigned to the user.
         * @param {number} id The id of the user to get the roles from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(id, options) {
            return localVarFp.getUserRoles(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the user\'s containers
         * @param {number} id The id of the user
         * @param {number} [take] How many containers the endpoint should return
         * @param {number} [skip] How many containers should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersContainers(id, take, skip, options) {
            return localVarFp.getUsersContainers(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all financial mutations of a user (from or to).
         * @param {number} id The id of the user to get the mutations from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFinancialMutations(id, fromDate, tillDate, take, skip, options) {
            return localVarFp.getUsersFinancialMutations(id, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the user\'s Points of Sale
         * @param {number} id The id of the user
         * @param {number} [take] How many points of sale the endpoint should return
         * @param {number} [skip] How many points of sale should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPointsOfSale(id, take, skip, options) {
            return localVarFp.getUsersPointsOfSale(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all deposits of a user that are still being processed by Stripe
         * @param {number} id The id of the user to get the deposits from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProcessingDeposits(id, options) {
            return localVarFp.getUsersProcessingDeposits(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an user\'s products
         * @param {number} id The id of the user
         * @param {number} [take] How many products the endpoint should return
         * @param {number} [skip] How many products should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersProducts(id, take, skip, options) {
            return localVarFp.getUsersProducts(id, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get purchase report pdf for the given user
         * @param {number} id The id of the user to get the purchase report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {GetUsersPurchaseReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPurchaseReportPdf(id, fromDate, tillDate, fileType, options) {
            return localVarFp.getUsersPurchaseReportPdf(id, fromDate, tillDate, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get purchases report for the given user
         * @param {number} id The id of the user to get the purchases report for
         * @param {string} fromDate Start date for selected purchases (inclusive)
         * @param {string} tillDate End date for selected purchases (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPurchasesReport(id, fromDate, tillDate, options) {
            return localVarFp.getUsersPurchasesReport(id, fromDate, tillDate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSalesReport(id, fromDate, tillDate, options) {
            return localVarFp.getUsersSalesReport(id, fromDate, tillDate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get sales report for the given user
         * @param {number} id The id of the user to get the sales report for
         * @param {string} fromDate Start date for selected sales (inclusive)
         * @param {string} tillDate End date for selected sales (exclusive)
         * @param {string} [description] Description of the report
         * @param {GetUsersSalesReportPdfFileTypeEnum} [fileType] The file type of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersSalesReportPdf(id, fromDate, tillDate, description, fileType, options) {
            return localVarFp.getUsersSalesReportPdf(id, fromDate, tillDate, description, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get transactions from a user.
         * @param {number} id The id of the user that should be involved in all returned transactions
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [createdById] User that created selected transaction
         * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
         * @param {number} [productId] Product ID for selected transactions
         * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options) {
            return localVarFp.getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get transaction report for the given user
         * @param {number} id The id of the user to get the transaction report from
         * @param {string} [fromDate] Start date for selected transactions (inclusive)
         * @param {string} [tillDate] End date for selected transactions (exclusive)
         * @param {number} [fromId] From-user for selected transactions
         * @param {number} [toId] To-user for selected transactions
         * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options) {
            return localVarFp.getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get transfers to or from an user.
         * @param {number} id The id of the user that should be involved in all returned transfers
         * @param {number} [take] How many transfers the endpoint should return
         * @param {number} [skip] How many transfers should be skipped (for pagination)
         * @param {number} [fromId] From-user for selected transfers
         * @param {number} [toId] To-user for selected transfers
         * @param {number} [id2] ID of selected transfers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTransfers(id, take, skip, fromId, toId, id2, options) {
            return localVarFp.getUsersTransfers(id, take, skip, fromId, toId, id2, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a user
         * @param {number} id The id of the user
         * @param {UpdateUserRequest} updateUserRequest The user which should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id, updateUserRequest, options) {
            return localVarFp.updateUser(id, updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary POST an users update to new key code
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserKey(id, options) {
            return localVarFp.updateUserKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a user\'s local password
         * @param {number} id The id of the user
         * @param {UpdateLocalRequest} updateLocalRequest    The password update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLocalPassword(id, updateLocalRequest, options) {
            return localVarFp.updateUserLocalPassword(id, updateLocalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a users NFC code
         * @param {number} id The id of the user
         * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNfc(id, updateNfcRequest, options) {
            return localVarFp.updateUserNfc(id, updateNfcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put an users pin code
         * @param {number} id The id of the user
         * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPin(id, updatePinRequest, options) {
            return localVarFp.updateUserPin(id, updatePinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Waive all given user\'s fines
         * @param {number} id The id of the user
         * @param {WaiveFinesRequest} [waiveFinesRequest] Optional body, see https://github.com/GEWIS/sudosos-backend/pull/344
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waiveUserFines(id, waiveFinesRequest, options) {
            return localVarFp.waiveUserFines(id, waiveFinesRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UsersApiFactory = UsersApiFactory;
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends base_1.BaseAPI {
    /**
     *
     * @summary Accept the Terms of Service if you have not accepted it yet
     * @param {AcceptTosRequest} acceptTosRequest \&quot;Tosrequest body\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    acceptTos(acceptTosRequest, options) {
        return (0, exports.UsersApiFp)(this.configuration).acceptTos(acceptTosRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Authenticate as another user
     * @param {number} id The id of the user that should be authenticated as
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    authenticateAs(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).authenticateAs(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new user
     * @param {CreateUserRequest} createUserRequest The user which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    createUser(createUserRequest, options) {
        return (0, exports.UsersApiFp)(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a single user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUser(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a users key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUserKey(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).deleteUserKey(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a nfc code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUserNfc(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).deleteUserNfc(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a user using the nfc code
     * @param {string} nfcCode The nfc code of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    findUserNfc(nfcCode, options) {
        return (0, exports.UsersApiFp)(this.configuration).findUserNfc(nfcCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a list of all users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {string} [search] Filter based on first name
     * @param {boolean} [active] Filter based if the user is active
     * @param {boolean} [ofAge] Filter based if the user is 18+
     * @param {number} [id] Filter based on user ID
     * @param {GetAllUsersTypeEnum} [type] Filter based on user type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getAllUsers(take, skip, search, active, ofAge, id, type, options) {
        return (0, exports.UsersApiFp)(this.configuration).getAllUsers(take, skip, search, active, ofAge, id, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all users of user type
     * @param {string} userType The userType of the requested users
     * @param {number} [take] How many users the endpoint should return
     * @param {number} [skip] How many users should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getAllUsersOfUserType(userType, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getAllUsersOfUserType(userType, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an individual user
     * @param {number} id userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getIndividualUser(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).getIndividualUser(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an organs members
     * @param {number} id The id of the user
     * @param {number} [take] How many members the endpoint should return
     * @param {number} [skip] How many members should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getOrganMembers(id, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getOrganMembers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all users that the user can authenticate as
     * @param {number} id The id of the user to get authentications of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserAuthenticatable(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUserAuthenticatable(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all roles assigned to the user.
     * @param {number} id The id of the user to get the roles from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserRoles(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUserRoles(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the user\'s containers
     * @param {number} id The id of the user
     * @param {number} [take] How many containers the endpoint should return
     * @param {number} [skip] How many containers should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersContainers(id, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersContainers(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all financial mutations of a user (from or to).
     * @param {number} id The id of the user to get the mutations from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersFinancialMutations(id, fromDate, tillDate, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersFinancialMutations(id, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the user\'s Points of Sale
     * @param {number} id The id of the user
     * @param {number} [take] How many points of sale the endpoint should return
     * @param {number} [skip] How many points of sale should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersPointsOfSale(id, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersPointsOfSale(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all deposits of a user that are still being processed by Stripe
     * @param {number} id The id of the user to get the deposits from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersProcessingDeposits(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersProcessingDeposits(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an user\'s products
     * @param {number} id The id of the user
     * @param {number} [take] How many products the endpoint should return
     * @param {number} [skip] How many products should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersProducts(id, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersProducts(id, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get purchase report pdf for the given user
     * @param {number} id The id of the user to get the purchase report for
     * @param {string} fromDate Start date for selected purchases (inclusive)
     * @param {string} tillDate End date for selected purchases (exclusive)
     * @param {GetUsersPurchaseReportPdfFileTypeEnum} [fileType] The file type of the report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersPurchaseReportPdf(id, fromDate, tillDate, fileType, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersPurchaseReportPdf(id, fromDate, tillDate, fileType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get purchases report for the given user
     * @param {number} id The id of the user to get the purchases report for
     * @param {string} fromDate Start date for selected purchases (inclusive)
     * @param {string} tillDate End date for selected purchases (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersPurchasesReport(id, fromDate, tillDate, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersPurchasesReport(id, fromDate, tillDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get sales report for the given user
     * @param {number} id The id of the user to get the sales report for
     * @param {string} fromDate Start date for selected sales (inclusive)
     * @param {string} tillDate End date for selected sales (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersSalesReport(id, fromDate, tillDate, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersSalesReport(id, fromDate, tillDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get sales report for the given user
     * @param {number} id The id of the user to get the sales report for
     * @param {string} fromDate Start date for selected sales (inclusive)
     * @param {string} tillDate End date for selected sales (exclusive)
     * @param {string} [description] Description of the report
     * @param {GetUsersSalesReportPdfFileTypeEnum} [fileType] The file type of the report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersSalesReportPdf(id, fromDate, tillDate, description, fileType, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersSalesReportPdf(id, fromDate, tillDate, description, fileType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get transactions from a user.
     * @param {number} id The id of the user that should be involved in all returned transactions
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [createdById] User that created selected transaction
     * @param {number} [toId] To-user for selected transactions transactions. Requires ContainerId
     * @param {number} [productId] Product ID for selected transactions
     * @param {number} [productRevision] Product Revision for selected transactions. Requires ProductID
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersTransactions(id, fromId, createdById, toId, productId, productRevision, fromDate, tillDate, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get transaction report for the given user
     * @param {number} id The id of the user to get the transaction report from
     * @param {string} [fromDate] Start date for selected transactions (inclusive)
     * @param {string} [tillDate] End date for selected transactions (exclusive)
     * @param {number} [fromId] From-user for selected transactions
     * @param {number} [toId] To-user for selected transactions
     * @param {boolean} [exclusiveToId] If all sub-transactions should be to the toId user, default true
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersTransactionsReport(id, fromDate, tillDate, fromId, toId, exclusiveToId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get transfers to or from an user.
     * @param {number} id The id of the user that should be involved in all returned transfers
     * @param {number} [take] How many transfers the endpoint should return
     * @param {number} [skip] How many transfers should be skipped (for pagination)
     * @param {number} [fromId] From-user for selected transfers
     * @param {number} [toId] To-user for selected transfers
     * @param {number} [id2] ID of selected transfers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersTransfers(id, take, skip, fromId, toId, id2, options) {
        return (0, exports.UsersApiFp)(this.configuration).getUsersTransfers(id, take, skip, fromId, toId, id2, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a user
     * @param {number} id The id of the user
     * @param {UpdateUserRequest} updateUserRequest The user which should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUser(id, updateUserRequest, options) {
        return (0, exports.UsersApiFp)(this.configuration).updateUser(id, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary POST an users update to new key code
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserKey(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).updateUserKey(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a user\'s local password
     * @param {number} id The id of the user
     * @param {UpdateLocalRequest} updateLocalRequest    The password update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserLocalPassword(id, updateLocalRequest, options) {
        return (0, exports.UsersApiFp)(this.configuration).updateUserLocalPassword(id, updateLocalRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a users NFC code
     * @param {number} id The id of the user
     * @param {UpdateNfcRequest} updateNfcRequest    The NFC code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserNfc(id, updateNfcRequest, options) {
        return (0, exports.UsersApiFp)(this.configuration).updateUserNfc(id, updateNfcRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put an users pin code
     * @param {number} id The id of the user
     * @param {UpdatePinRequest} updatePinRequest    The PIN code to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUserPin(id, updatePinRequest, options) {
        return (0, exports.UsersApiFp)(this.configuration).updateUserPin(id, updatePinRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Waive all given user\'s fines
     * @param {number} id The id of the user
     * @param {WaiveFinesRequest} [waiveFinesRequest] Optional body, see https://github.com/GEWIS/sudosos-backend/pull/344
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    waiveUserFines(id, waiveFinesRequest, options) {
        return (0, exports.UsersApiFp)(this.configuration).waiveUserFines(id, waiveFinesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UsersApi = UsersApi;
/**
 * @export
 */
exports.GetAllUsersTypeEnum = {
    Member: 'MEMBER',
    Organ: 'ORGAN',
    Voucher: 'VOUCHER',
    LocalUser: 'LOCAL_USER',
    LocalAdmin: 'LOCAL_ADMIN',
    Invoice: 'INVOICE',
    AutomaticInvoice: 'AUTOMATIC_INVOICE'
};
/**
 * @export
 */
exports.GetUsersPurchaseReportPdfFileTypeEnum = {
    Pdf: 'PDF',
    Tex: 'TEX'
};
/**
 * @export
 */
exports.GetUsersSalesReportPdfFileTypeEnum = {
    Pdf: 'PDF',
    Tex: 'TEX'
};
/**
 * VatGroupsApi - axios parameter creator
 * @export
 */
const VatGroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a new VAT group
         * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup: (vatGroupRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'vatGroupRequest' is not null or undefined
            (0, common_1.assertParamExists)('createVatGroup', 'vatGroupRequest', vatGroupRequest);
            const localVarPath = `/vatgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(vatGroupRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups: (vatGroupId, name, percentage, deleted, take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/vatgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (vatGroupId !== undefined) {
                localVarQueryParameter['vatGroupId'] = vatGroupId;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (percentage !== undefined) {
                localVarQueryParameter['percentage'] = percentage;
            }
            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleVatGroup', 'id', id);
            const localVarPath = `/vatgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts: (year, period, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'year' is not null or undefined
            (0, common_1.assertParamExists)('getVatDeclarationAmounts', 'year', year);
            // verify required parameter 'period' is not null or undefined
            (0, common_1.assertParamExists)('getVatDeclarationAmounts', 'period', period);
            const localVarPath = `/vatgroups/declaration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup: (id, updateVatGroupRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateVatGroup', 'id', id);
            // verify required parameter 'updateVatGroupRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateVatGroup', 'updateVatGroupRequest', updateVatGroupRequest);
            const localVarPath = `/vatgroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateVatGroupRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.VatGroupsApiAxiosParamCreator = VatGroupsApiAxiosParamCreator;
/**
 * VatGroupsApi - functional programming interface
 * @export
 */
const VatGroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.VatGroupsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new VAT group
         * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup(vatGroupRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createVatGroup(vatGroupRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['VatGroupsApi.createVatGroup']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['VatGroupsApi.getAllVatGroups']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleVatGroup(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['VatGroupsApi.getSingleVatGroup']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts(year, period, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVatDeclarationAmounts(year, period, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['VatGroupsApi.getVatDeclarationAmounts']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup(id, updateVatGroupRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateVatGroup(id, updateVatGroupRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['VatGroupsApi.updateVatGroup']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.VatGroupsApiFp = VatGroupsApiFp;
/**
 * VatGroupsApi - factory interface
 * @export
 */
const VatGroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.VatGroupsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new VAT group
         * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVatGroup(vatGroupRequest, options) {
            return localVarFp.createVatGroup(vatGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a list of all VAT groups
         * @param {number} [vatGroupId] ID of the VAT group
         * @param {string} [name] Name of the VAT group
         * @param {number} [percentage] VAT percentage
         * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
         * @param {number} [take] How many transactions the endpoint should return
         * @param {number} [skip] How many transactions should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options) {
            return localVarFp.getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the requested VAT group
         * @param {number} id The ID of the VAT group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleVatGroup(id, options) {
            return localVarFp.getSingleVatGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the VAT collections needed for VAT declarations
         * @param {number} year Calendar year for VAT declarations
         * @param {string} period Period for VAT declarations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatDeclarationAmounts(year, period, options) {
            return localVarFp.getVatDeclarationAmounts(year, period, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new VAT group
         * @param {number} id The ID of the VAT group which should be updated
         * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVatGroup(id, updateVatGroupRequest, options) {
            return localVarFp.updateVatGroup(id, updateVatGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.VatGroupsApiFactory = VatGroupsApiFactory;
/**
 * VatGroupsApi - object-oriented interface
 * @export
 * @class VatGroupsApi
 * @extends {BaseAPI}
 */
class VatGroupsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create a new VAT group
     * @param {VatGroupRequest} vatGroupRequest The VAT group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    createVatGroup(vatGroupRequest, options) {
        return (0, exports.VatGroupsApiFp)(this.configuration).createVatGroup(vatGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a list of all VAT groups
     * @param {number} [vatGroupId] ID of the VAT group
     * @param {string} [name] Name of the VAT group
     * @param {number} [percentage] VAT percentage
     * @param {boolean} [deleted] Whether the VAT groups should be hidden if zero
     * @param {number} [take] How many transactions the endpoint should return
     * @param {number} [skip] How many transactions should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options) {
        return (0, exports.VatGroupsApiFp)(this.configuration).getAllVatGroups(vatGroupId, name, percentage, deleted, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the requested VAT group
     * @param {number} id The ID of the VAT group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getSingleVatGroup(id, options) {
        return (0, exports.VatGroupsApiFp)(this.configuration).getSingleVatGroup(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the VAT collections needed for VAT declarations
     * @param {number} year Calendar year for VAT declarations
     * @param {string} period Period for VAT declarations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    getVatDeclarationAmounts(year, period, options) {
        return (0, exports.VatGroupsApiFp)(this.configuration).getVatDeclarationAmounts(year, period, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new VAT group
     * @param {number} id The ID of the VAT group which should be updated
     * @param {UpdateVatGroupRequest} updateVatGroupRequest The VAT group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatGroupsApi
     */
    updateVatGroup(id, updateVatGroupRequest, options) {
        return (0, exports.VatGroupsApiFp)(this.configuration).updateVatGroup(id, updateVatGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VatGroupsApi = VatGroupsApi;
/**
 * VouchergroupsApi - axios parameter creator
 * @export
 */
const VouchergroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Creates a new voucher group
         * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVouchergroup: (voucherGroupRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'voucherGroupRequest' is not null or undefined
            (0, common_1.assertParamExists)('createVouchergroup', 'voucherGroupRequest', voucherGroupRequest);
            const localVarPath = `/vouchergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(voucherGroupRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVouchergroups: (take, skip, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/vouchergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchergroupId: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getVouchergroupId', 'id', id);
            const localVarPath = `/vouchergroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherGroup: (id, voucherGroupRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateVoucherGroup', 'id', id);
            // verify required parameter 'voucherGroupRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateVoucherGroup', 'voucherGroupRequest', voucherGroupRequest);
            const localVarPath = `/vouchergroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(voucherGroupRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.VouchergroupsApiAxiosParamCreator = VouchergroupsApiAxiosParamCreator;
/**
 * VouchergroupsApi - functional programming interface
 * @export
 */
const VouchergroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.VouchergroupsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Creates a new voucher group
         * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVouchergroup(voucherGroupRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createVouchergroup(voucherGroupRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['VouchergroupsApi.createVouchergroup']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVouchergroups(take, skip, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllVouchergroups(take, skip, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['VouchergroupsApi.getAllVouchergroups']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchergroupId(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVouchergroupId(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['VouchergroupsApi.getVouchergroupId']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherGroup(id, voucherGroupRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateVoucherGroup(id, voucherGroupRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['VouchergroupsApi.updateVoucherGroup']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.VouchergroupsApiFp = VouchergroupsApiFp;
/**
 * VouchergroupsApi - factory interface
 * @export
 */
const VouchergroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.VouchergroupsApiFp)(configuration);
    return {
        /**
         *
         * @summary Creates a new voucher group
         * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVouchergroup(voucherGroupRequest, options) {
            return localVarFp.createVouchergroup(voucherGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all existing voucher groups
         * @param {number} [take] How many voucher groups the endpoint should return
         * @param {number} [skip] How many voucher groups should be skipped (for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVouchergroups(take, skip, options) {
            return localVarFp.getAllVouchergroups(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the requested voucher group
         * @param {number} id The id of the voucher group which should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchergroupId(id, options) {
            return localVarFp.getVouchergroupId(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates the requested voucher group
         * @param {number} id The id of the voucher group which should be updated
         * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherGroup(id, voucherGroupRequest, options) {
            return localVarFp.updateVoucherGroup(id, voucherGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.VouchergroupsApiFactory = VouchergroupsApiFactory;
/**
 * VouchergroupsApi - object-oriented interface
 * @export
 * @class VouchergroupsApi
 * @extends {BaseAPI}
 */
class VouchergroupsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Creates a new voucher group
     * @param {VoucherGroupRequest} voucherGroupRequest The voucher group which should be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    createVouchergroup(voucherGroupRequest, options) {
        return (0, exports.VouchergroupsApiFp)(this.configuration).createVouchergroup(voucherGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all existing voucher groups
     * @param {number} [take] How many voucher groups the endpoint should return
     * @param {number} [skip] How many voucher groups should be skipped (for pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    getAllVouchergroups(take, skip, options) {
        return (0, exports.VouchergroupsApiFp)(this.configuration).getAllVouchergroups(take, skip, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the requested voucher group
     * @param {number} id The id of the voucher group which should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    getVouchergroupId(id, options) {
        return (0, exports.VouchergroupsApiFp)(this.configuration).getVouchergroupId(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates the requested voucher group
     * @param {number} id The id of the voucher group which should be updated
     * @param {VoucherGroupRequest} voucherGroupRequest The updated voucher group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VouchergroupsApi
     */
    updateVoucherGroup(id, voucherGroupRequest, options) {
        return (0, exports.VouchergroupsApiFp)(this.configuration).updateVoucherGroup(id, voucherGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VouchergroupsApi = VouchergroupsApi;
/**
 * WriteoffsApi - axios parameter creator
 * @export
 */
const WriteoffsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Creates a new write-off in the system. Creating a write-off will also close and delete the user\'s account.
         * @param {WriteOffRequest} writeOffRequest New write off
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWriteOff: (writeOffRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'writeOffRequest' is not null or undefined
            (0, common_1.assertParamExists)('createWriteOff', 'writeOffRequest', writeOffRequest);
            const localVarPath = `/writeoffs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(writeOffRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all write-offs in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [amount] Filter on the amount of the write-off
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {string} [fromDate] Start date for selected write-offs (inclusive)
         * @param {string} [tillDate] End date for selected write-offs (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWriteOffs: (toId, amount, take, skip, fromDate, tillDate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/writeoffs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (toId !== undefined) {
                localVarQueryParameter['toId'] = toId;
            }
            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }
            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }
            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (tillDate !== undefined) {
                localVarQueryParameter['tillDate'] = tillDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a single write-off
         * @param {number} id The ID of the write-off object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWriteOff: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getSingleWriteOff', 'id', id);
            const localVarPath = `/writeoffs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.WriteoffsApiAxiosParamCreator = WriteoffsApiAxiosParamCreator;
/**
 * WriteoffsApi - functional programming interface
 * @export
 */
const WriteoffsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.WriteoffsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Creates a new write-off in the system. Creating a write-off will also close and delete the user\'s account.
         * @param {WriteOffRequest} writeOffRequest New write off
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWriteOff(writeOffRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWriteOff(writeOffRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['WriteoffsApi.createWriteOff']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns all write-offs in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [amount] Filter on the amount of the write-off
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {string} [fromDate] Start date for selected write-offs (inclusive)
         * @param {string} [tillDate] End date for selected write-offs (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWriteOffs(toId, amount, take, skip, fromDate, tillDate, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllWriteOffs(toId, amount, take, skip, fromDate, tillDate, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['WriteoffsApi.getAllWriteOffs']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a single write-off
         * @param {number} id The ID of the write-off object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWriteOff(id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSingleWriteOff(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = base_1.operationServerMap['WriteoffsApi.getSingleWriteOff']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
exports.WriteoffsApiFp = WriteoffsApiFp;
/**
 * WriteoffsApi - factory interface
 * @export
 */
const WriteoffsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.WriteoffsApiFp)(configuration);
    return {
        /**
         *
         * @summary Creates a new write-off in the system. Creating a write-off will also close and delete the user\'s account.
         * @param {WriteOffRequest} writeOffRequest New write off
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWriteOff(writeOffRequest, options) {
            return localVarFp.createWriteOff(writeOffRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all write-offs in the system.
         * @param {number} [toId] Filter on Id of the debtor
         * @param {number} [amount] Filter on the amount of the write-off
         * @param {number} [take] Number of write-offs to return
         * @param {number} [skip] Number of write-offs to skip
         * @param {string} [fromDate] Start date for selected write-offs (inclusive)
         * @param {string} [tillDate] End date for selected write-offs (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWriteOffs(toId, amount, take, skip, fromDate, tillDate, options) {
            return localVarFp.getAllWriteOffs(toId, amount, take, skip, fromDate, tillDate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a single write-off
         * @param {number} id The ID of the write-off object that should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWriteOff(id, options) {
            return localVarFp.getSingleWriteOff(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.WriteoffsApiFactory = WriteoffsApiFactory;
/**
 * WriteoffsApi - object-oriented interface
 * @export
 * @class WriteoffsApi
 * @extends {BaseAPI}
 */
class WriteoffsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Creates a new write-off in the system. Creating a write-off will also close and delete the user\'s account.
     * @param {WriteOffRequest} writeOffRequest New write off
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteoffsApi
     */
    createWriteOff(writeOffRequest, options) {
        return (0, exports.WriteoffsApiFp)(this.configuration).createWriteOff(writeOffRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all write-offs in the system.
     * @param {number} [toId] Filter on Id of the debtor
     * @param {number} [amount] Filter on the amount of the write-off
     * @param {number} [take] Number of write-offs to return
     * @param {number} [skip] Number of write-offs to skip
     * @param {string} [fromDate] Start date for selected write-offs (inclusive)
     * @param {string} [tillDate] End date for selected write-offs (exclusive)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteoffsApi
     */
    getAllWriteOffs(toId, amount, take, skip, fromDate, tillDate, options) {
        return (0, exports.WriteoffsApiFp)(this.configuration).getAllWriteOffs(toId, amount, take, skip, fromDate, tillDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a single write-off
     * @param {number} id The ID of the write-off object that should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteoffsApi
     */
    getSingleWriteOff(id, options) {
        return (0, exports.WriteoffsApiFp)(this.configuration).getSingleWriteOff(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WriteoffsApi = WriteoffsApi;
//# sourceMappingURL=api.js.map